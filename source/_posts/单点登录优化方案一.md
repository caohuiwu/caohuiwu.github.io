---
title: 单点登录优化方案一
date: 2019-03-15 19:54:22
tags: SSO CAS tomcat session
categories: 单点登录
---
针对现有统一登录系统问题，进行了一些尝试，这篇文章是尝试过程中使用的方案一。
## 一、针对cas server单点问题

cas交互流程大致如下：
> * 拦截到web应用的请求，验证登录状态，若未登录则跳转到登录页
> * 登录成功，web应用的tomcat存储session，cas-server保存TGT信息，cas-client-core保存ST和session的对应关系
> * 登出时由cas-server返回ST信息，cas-client-core根据ST删除自己存储在内存的ST和session信息。（web应用在接入cas的时候需要继承cas-client-core）

针对现有cas单点部署情况及会遇到的问题，进行了分布式集群部署的尝试。

<!--more-->

》》解决分布式，主要是解决session共享

    1、Tomcat的session共享。
    2、CAS的ST、TGT的共享。
    3、cas-client-core共享ST和session的对应关系


##### 1.1、tomcat-session-redis 共享
1、引入tomcat-redis-session-manager插件。

2、修改tomcat的 context.xml 配置文件，添加如下配置：

    <!-- tomcat-redis-session共享配置 -->
    <Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" />
    <Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager"
    sentinels="jzztsentienl01.redis.djdns.cn:58783,jzztsentienl02.redis.djdns.cn:58783,jzztsentienl03.redis.djdns.cn:58783"
    sentinelMaster="my58783master"
    timeout="3000"
    maxInactiveInterval="60" />

3、在tomcat 的lib下添加以下包

    tomcat-redis-cache-manager.jar
    注意:tomcat8,与tomcat7包有所不同,请按版本添加，详细查看官网。


##### 1.2、CAS的ST、TGT的共享

1、ST根据TGT生成，然后保存

    public ServiceTicket grantServiceTicket(
            final String ticketGrantingTicketId,
            final Service service, final Credential... credentials)
            throws AuthenticationException, TicketException {

        final TicketGrantingTicket ticketGrantingTicket = getTicket(ticketGrantingTicketId, TicketGrantingTicket.class);
        final RegisteredService registeredService = this.servicesManager.findServiceBy(service);

        ............省略代码

        final String ticketPrefix = authentications.size() == 1 ? ServiceTicket.PREFIX : ServiceTicket.PROXY_TICKET_PREFIX;
        final String ticketId = serviceTicketUniqueTicketIdGenerator.getNewTicketId(ticketPrefix);
        final ServiceTicket serviceTicket = ticketGrantingTicket.grantServiceTicket(
                ticketId,
                service,
                this.serviceTicketExpirationPolicy,
                currentAuthentication != null);

        this.ticketRegistry.addTicket(serviceTicket);//查看2中的DbTicketRegistry

        logger.info("Granted ticket [{}] for service [{}] for user [{}]",
                serviceTicket.getId(), service.getId(), principal.getId());

        return serviceTicket;
    }

2、实现自定义的TicketRegistry，以下为简略代码。

    public final class DbTicketRegistry extends AbstractDistributedTicketRegistry implements DisposableBean {
        private int tgtTimeout;
        private int stTimeout;
        @Override
        public void addTicket(final Ticket ticket) {
            logger.debug("Adding ticket {}", ticket);
            try {
                this.saveTicket(ticket);
            } catch (final Exception e) {
                logger.error("Failed adding {} ，error:{} 。", ticket,e);
            }
        }
        
        private void saveTicket(final Ticket ticket) throws Exception{
             try {
                ITicketGrantingTicketService ticketGrantingTicketService =  UumUtil.getApplicationContext().getBean(ITicketGrantingTicketService.class); 
                if(ticket instanceof ServiceTicketImpl){
                    //st采用了Redis存储
                    RedisCacheClientUtil.syncAdd(ticket.getId(), ticket, 1000, RedisCacheClientUtil.DEFAULT_TIMEOUT);
                 }
                if(ticket instanceof TicketGrantingTicketImpl){
                    //TGT采用了DB存储
                    TicketGrantingTicketDTO ticketGrantingTicketDTO = getDbTicket((TicketGrantingTicketImpl)ticket,ticketGrantingTicketService);
                    ticketGrantingTicketService.save(ticketGrantingTicketDTO);
                 }
             } catch (final Exception e) {
                 logger.error("Failed save {} ，error:{} 。", ticket,e);
             }
        }
    }


3、cas-client-core共享ST和session的对应关系，退出票据删除

cas-client-core利用HashMapBackedSessionMappingStorage实现了ST和session的内存存储
    
    //添加
    @Override
    public void addSessionById(String mappingId, HttpSession session) {
        String STKey = getKey(mappingId);
        StandardSessionFacade standardSessionFacade = (StandardSessionFacade) session;
        RedisSession redisSession = null;
        try {
            redisSession = (RedisSession) getValue(standardSessionFacade, "session");
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        if (null == redisSession) {
            log.error("get redisSession fail");
            return;
        }
 
        sessionRedisTemplate.opsForValue().set(STKey, jdkSerializer.serialize(redisSession));
        String sessionKey = getKey(session.getId());
        stringRedisTemplate.opsForValue().set(sessionKey, STKey);
        log.debug("cas-client add session, mappingId:" + mappingId + " sessionId:" + session.getId());
    }
    
    //删除
    private void destroySession(final HttpServletRequest request) {
        final String logoutMessage;
        final String token = XmlUtils.getTextForElement(logoutMessage, "SessionIndex");
        if (CommonUtils.isNotBlank(token)) {
            final HttpSession session = this.sessionMappingStorage.removeSessionByMappingId(token);
            if (session != null) {
                final String sessionID = session.getId();
                logger.debug("Invalidating session [{}] for token [{}]", sessionID, token);
                try {
                    session.invalidate();
                } catch (final IllegalStateException e) {
                    logger.debug("Error invalidating session.", e);
                }
                this.logoutStrategy.logout(request);
            }
        }
    }
    
[参考文档](https://blog.csdn.net/dodolzg/article/details/43833545)    

## 二、针对RPC接口

    1、高耦合问题：确定接口的职责，例如只获取用户信息，只返回用户基本信息，但是改造成本高，业务改动大，不建议做。
    2、数据量大问题：加入分页限制，不全部返回。


## 三、成果

    1、分布式改造后，解决了单点节点崩溃服务不可用问题。
    2、加入分页限制后，解决了RPC调用造成的超时问题。
    3、即使分布式+分页改造，依然没有解决登录耗时问题，主要是单点登录设计缺陷，需要获取的用户信息过多。



