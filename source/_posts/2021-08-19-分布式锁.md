---
title: 《分布式》分布式锁
date: 2021-08-19
categories:
  - [ zookeeper ]
  - [ redis ]
  - [ 分布式系统 ]
tags:
  - [ 分布式锁]
---


<style>
.my-code {
   color: red;
}
.orange {
   color: orange
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>

# 一、分布式锁
**分布式锁**是用于分布式系统中控制共享资源访问的机制，确保同一时间只有一个节点（进程/线程）能访问特定资源，从而避免并发问题。

<!--more-->

**常见实现方式**
- 基于数据库的分布式锁
- 基于Redis的分布式锁
- 基于Zookeeper的分布式锁

# 二、方案1：基于数据库的分布式锁（悲观锁）
实现方式
- **唯一索引**：利用唯一性约束实现锁（如插入一条记录代表获取锁）
- **行级锁**：通过`select ... FOR UPDATE`锁定记录。

```sql
-- 唯一索引实现锁示例
CREATE TABLE distributed_lock (
  id INT PRIMARY KEY,
  lock_key VARCHAR(64) UNIQUE,
  expire_time DATETIME
);

-- 获取锁（利用唯一性约束）
INSERT INTO distributed_lock (lock_key, expire_time) VALUES ('order_lock', NOW() + 10s);
-- 释放锁
DELETE FROM distributed_lock WHERE lock_key = 'order_lock';
```

# 三、方案2：基于Redis的分布式锁
**实现原理**
- 利用Redis的`SETNX`（`set if not exists`）命令和过期时间（`expire`）特性。

**关键命令**：
- `set key value NX EX expire`：原子性的设置键值对，若键不存在且设置过期时间。
- **LUA脚本解锁**：确保解锁时仅删除自己的锁（通过校验值value）。
```lua
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

代码示例：
```java
public boolean tryLock(String lockKey, String uuid, int expireSeconds) {
    // 使用 Redis 的 setIfAbsent 实现加锁
    return redisTemplate.opsForValue().setIfAbsent(lockKey, uuid, expireSeconds, TimeUnit.SECONDS);
}

public void unlock(String lockKey, String uuid) {
    // 使用 Lua 脚本确保原子性
    String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
    redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), Arrays.asList(lockKey), uuid);
}
```

缺点：
- **主从同步问题**：主节点宕机后，从节点可能未同步过期时间，导致锁失效。
- **需要处理续期**：若业务执行时间超过锁的过期时间，需通过LUA脚本或重入机制续期。
  - 例如**A线程**未执行完成，锁过期，**B线程**可以去获取锁，导致数据不一致。


## 3.1、主从同步问题

### 3.1.1、方案一：redLock
```java
// 并行加锁（Java 示例）
public boolean tryRedLock(String key, String value, int expireMs, List<Jedis> nodes) {
    long start = System.currentTimeMillis();
    List<Future<Boolean>> futures = new ArrayList<>();
    ExecutorService executor = Executors.newFixedThreadPool(nodes.size());
    
    for (Jedis node : nodes) {
        final String finalKey = key;
        final String finalValue = value;
        futures.add(executor.submit(() -> {
            try {
                // 使用 Lua 脚本原子加锁
                String script = "if redis.call('get', KEYS[1]) == false then return redis.call('set', KEYS[1], ARGV[1], 'EX', ARGV[2]) else return 0 end";
                return node.eval(script, List.of(finalKey), finalValue, String.valueOf(expireMs)) != null;
            } catch (Exception e) {
                return false;
            }
        }));
    }
    int successCount = 0;
    for (Future<Boolean> future : futures) {
        try {
            if (future.get(100, TimeUnit.MILLISECONDS)) {
                successCount++;
            }
        } catch (Exception e) {
            // 超时或失败，忽略
        }
    }
    // 要求至少 2/3 节点成功
    return successCount > nodes.size() * 2 / 3;
}
```
`Redlock` 的个人看法是，尽量不用它，而且它的性能不如单机版 Redis，部署成本也高

### 3.1.2、方案二：Redisson multiLock
示例代码：
```java
// 配置多个独立的 Redis 节点
Config config = new Config();
config.useSingleServer().setAddress("redis://192.168.244.130:6379");
config.useSingleServer().setAddress("redis://192.168.244.131:6379");
config.useSingleServer().setAddress("redis://192.168.244.132:6379");

RedissonClient redisson = Redisson.create(config);

// 使用 multiLock 获取锁
RLock lock1 = redisson.getLock("lock1");
RLock lock2 = redisson.getLock("lock2");
RLock lock3 = redisson.getLock("lock3");
RLock multiLock = redisson.getMultiLock(lock1, lock2, lock3);

try {
    multiLock.lock(); // 必须所有节点都成功获取锁
    // 业务逻辑
} finally {
    multiLock.unlock(); // 必须所有节点都释放锁
}
```

源码如下：
```java
public class RedissonMultiLock implements RLock {
    @Override
    public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        long newLeaseTime = -1;
        if (leaseTime > 0) {
            if (waitTime > 0) {
                newLeaseTime = unit.toMillis(waitTime)*2;
            } else {
                newLeaseTime = unit.toMillis(leaseTime);
            }
        }

        long time = System.currentTimeMillis();
        long remainTime = -1;
        if (waitTime > 0) {
            remainTime = unit.toMillis(waitTime);
        }
        long lockWaitTime = calcLockWaitTime(remainTime);

        int failedLocksLimit = failedLocksLimit();
        List<RLock> acquiredLocks = new ArrayList<>(locks.size());
        //循环遍历，导致网络延迟叠加
        for (ListIterator<RLock> iterator = locks.listIterator(); iterator.hasNext();) {
            RLock lock = iterator.next();
            boolean lockAcquired;
            try {
                if (waitTime <= 0 && leaseTime <= 0) {
                    lockAcquired = lock.tryLock();
                } else {
                    long awaitTime = Math.min(lockWaitTime, remainTime);
                    lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);
                }
            } catch (RedisResponseTimeoutException e) {
                unlockInner(Arrays.asList(lock));
                lockAcquired = false;
            } catch (Exception e) {
                lockAcquired = false;
            }

            if (lockAcquired) {
                acquiredLocks.add(lock);
            } else {
                if (locks.size() - acquiredLocks.size() == failedLocksLimit()) {
                    break;
                }

                if (failedLocksLimit == 0) {
                    unlockInner(acquiredLocks);
                    if (waitTime <= 0) {
                        return false;
                    }
                    failedLocksLimit = failedLocksLimit();
                    acquiredLocks.clear();
                    // reset iterator
                    while (iterator.hasPrevious()) {
                        iterator.previous();
                    }
                } else {
                    failedLocksLimit--;
                }
            }

            if (remainTime > 0) {
                remainTime -= System.currentTimeMillis() - time;
                time = System.currentTimeMillis();
                if (remainTime <= 0) {
                    unlockInner(acquiredLocks);
                    return false;
                }
            }
        }
        if (leaseTime > 0) {
            acquiredLocks.stream()
                    .map(l -> (RedissonBaseLock) l)
                    .map(l -> l.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS))
                    .forEach(f -> f.toCompletableFuture().join());
        }
        return true;
    }
}
```


影响：
- **多节点操作的延迟**： multiLock 需要同时操作多个Redis节点，导致网络延迟叠加。
- **资源消耗**：每个锁操作都需要在多个节点上执行原子命令，增加Redis服务器的计算和内存开销。

优化建议：
- 减少节点数量
- **集群模式**：使用Redis集群模式替代多主从架构，减少跨节点通信的复杂度。

### 3.1.3、方案三：采用Redisson + Redis Cluster集群模式

`redis cluster`通过**数据分片、自动故障转移、去中心化架构**和**多节点冗余**，从根本上解决了传统主从模式的单点故障、同步延迟和扩展性问题。其设计确保了高可用性、数据一致性和水平扩展能力，是分布式场景下`Redis`的首选方案。


## 3.2、锁失效问题（如何自动续期？）
锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。

当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。

这个方案其实也不能完美解决问题，那怎么办呢？

是否可以设计这样的方案：**加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。**
- `Redisson` 是一个 Java 语言实现的 `Redis SDK` 客户端，在使用分布式锁时，它就采用了「**自动续期**」的方案来避免锁过期，这个守护线程我们一般也把它叫做「**看门狗**」线程。

### 3.2.1、watch dog 看门狗
`Redisson`看门狗机制， 只要客户端加锁成功，就会启动一个 `Watch Dog`。
- **自动续期锁的有效期**：若业务执行时间超过锁的默认过期时间（默认30秒），看门狗会自动延迟锁的过期时间，确保锁在业务执行期间不被提前释放。
- **异常处理**：如果客户端崩溃或网络中断，看门狗停止工作，锁会在最后一次续期的过期时间（默认30秒）后自动释放。
- **锁的获取**：当调用`lock()`或`tryLock()`时，若未指定锁的过期时间（`leaseTime`），`Redisson`会默认启用看门狗机制。
  - 默认锁的过期时间为30秒（可通过配置修改）
```java
RLock lock = redisson.getLock("anyLock");
boolean res = lock.lock();
// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁（这种方式不会启动看门狗，因为明确了过期时间）
boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
if (res) {
   try {
     ...
   } finally {
       lock.unlock();
   }
}
```

### 3.2.2、看门狗解析
```java
public class RedissonLock extends RedissonBaseLock {
    @Override
    public void lock() {
        try {
            lock(-1, null, false);
        } catch (InterruptedException e) {
            throw new IllegalStateException();
        }
    }
    private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException {
        long threadId = Thread.currentThread().getId();
        //尝试获取锁
        Long ttl = tryAcquire(-1, leaseTime, unit, threadId);
        // lock acquired，成功获取锁
        if (ttl == null) {
            return;
        }
        //未获取到锁，订阅锁释放通知
        CompletableFuture<RedissonLockEntry> future = subscribe(threadId);
        pubSub.timeout(future);//为订阅操作设置超时时间，防止无限期等待
        RedissonLockEntry entry;
        //同步订阅（处理中断）
        if (interruptibly) {
            //线程在等待订阅结果时，若被中断，抛出InterruptedException。适用于需要响应外部中断的场景（如超时控制或紧急退出）
            entry = commandExecutor.getInterrupted(future);
        } else {
            //禁止中断，线程会一直阻塞直到订阅完成或超时。忽略中断信号
            entry = commandExecutor.get(future);
        }
        try {
            //循环重试获取锁
            while (true) {
                ttl = tryAcquire(-1, leaseTime, unit, threadId);
                // 获取成功
                if (ttl == null) {
                    break;
                }
                // 根据锁的剩余时间阻塞等待
                if (ttl >= 0) {
                    //得到一个Semaphore信号量对象，这是jdk的内置对象，Semaphore#tryAcquire表示阻塞并等待唤醒
                    try {
                        entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                    } catch (InterruptedException e) {
                        if (interruptibly) {
                            throw e;
                        }
                        entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                    }
                } else {
                    if (interruptibly) {
                        entry.getLatch().acquire();
                    } else {
                        entry.getLatch().acquireUninterruptibly();
                    }
                }
            }
        } finally {
            unsubscribe(entry, threadId);//取消订阅
        }
//        get(lockAsync(leaseTime, unit));
    }
}
```

#### 3.2.2.1、尝试获取锁：`tryAcquire()`
尝试获取锁的核心方法：
```java
private Long tryAcquire(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
    return get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));
}
 
private <T> RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
    RFuture<Long> ttlRemainingFuture;
    if (leaseTime > 0) {
        // 调用lua脚本，尝试加锁
        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
    } else {
        // 这里的if、else的区别就在于，如果没有设置leaseTime，就使用默认的internalLockLeaseTime（默认30秒）
        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,
                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
    }
    CompletionStage<Long> f = ttlRemainingFuture.thenApply(ttlRemaining -> {
        // ttlRemaining：剩余过期时间
        // 如果ttlRemaining为空，也就是tryLockInnerAsync方法中的lua执行结果返回空，证明获取锁成功
        if (ttlRemaining == null) {
            if (leaseTime > 0) {
                internalLockLeaseTime = unit.toMillis(leaseTime);
            } else {
                // 如果没有设置锁的持有时间（leaseTime），则启动看门狗，定时给锁续期，防止业务逻辑未执行完成锁就过期了
                scheduleExpirationRenewal(threadId);
            }
        }
        //未获取到锁，返回锁的剩余时间
        return ttlRemaining;
    });
    return new CompletableFutureWrapper<>(f);
}
```
Lua脚本如下：
```lua
-- Lua脚本（关键部分）
local lockKey = KEYS[1] -- 锁的键名
local threadId = ARGV[1] -- 当前线程ID（UUID + 线程ID）
local lockValue = ARGV[2] -- 锁的值（通常为1）
local leaseTime = tonumber(ARGV[3]) -- 锁的租约时间（毫秒）

-- 尝试设置锁（HSET）
if redis.call("hset", lockKey, threadId, lockValue) == 1 then
    -- 设置过期时间（防止业务超时未释放）
    redis.call("pexpire", lockKey, leaseTime)
    return nil -- 获取成功
else
    -- 返回锁的剩余时间（让客户端等待）
    return redis.call("pttl", lockKey)
end
```

#### 3.2.2.2、未获取到锁，`订阅`锁释放事件
- **目的**：当线程未立即获取到锁时，通过订阅锁的释放通知，避免空轮询，提高效率。

执行逻辑如下：
```java
private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException {
    long threadId = Thread.currentThread().getId();
    //尝试获取锁
    Long ttl = tryAcquire(-1, leaseTime, unit, threadId);
    // lock acquired，成功获取锁
    if (ttl == null) {
        return;
    }
    //未获取到锁，订阅锁释放通知
    CompletableFuture<RedissonLockEntry> future = subscribe(threadId);
    pubSub.timeout(future);//为订阅操作设置超时时间，防止无限期等待
    RedissonLockEntry entry;
    //同步订阅（处理中断）
    if (interruptibly) {
        //线程在等待订阅结果时，若被中断，抛出InterruptedException。适用于需要响应外部中断的场景（如超时控制或紧急退出）
        entry = commandExecutor.getInterrupted(future);
    } else {
        //禁止中断，线程会一直阻塞直到订阅完成或超时。忽略中断信号
        entry = commandExecutor.get(future);
    }
    try {
        //循环重试获取锁
        while (true) {
            ttl = tryAcquire(-1, leaseTime, unit, threadId);
            // 获取成功
            if (ttl == null) {
                break;
            }
            // 根据锁的剩余时间阻塞等待
            if (ttl >= 0) {
                //得到一个Semaphore信号量对象，这是jdk的内置对象，Semaphore#tryAcquire表示阻塞并等待唤醒
                try {
                    entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } catch (InterruptedException e) {
                    if (interruptibly) {
                        throw e;
                    }
                    entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                }
            } else {
                if (interruptibly) {
                    entry.getLatch().acquire();
                } else {
                    entry.getLatch().acquireUninterruptibly();
                }
            }
        }
    } finally {
        unsubscribe(entry, threadId);//取消订阅
    }
}
```
- **方式**：通过`subscribe()`方法订阅锁的释放事件。
- 根据`interruptibly`参数决定是否允许线程在等待订阅结果时响应中断。

##### `subscribe()`订阅
通过订阅Redis的`Pub/Sub`频道，监听锁释放事件。
```java
protected CompletableFuture<RedissonLockEntry> subscribe(long threadId) {
  return pubSub.subscribe(getEntryName() + ":" + threadId,
            getChannelName() + ":" + getLockName(threadId));
}
```
- 通过`subscribe(threadId)`向Redis注册一个订阅请求，生成一个唯一的频道（如`redisson_lock__channel:{lockName}`）。
- 返回`CompletableFuture<RedissonLockEntry>`，表示异步订阅操作的结果
- `RedissonLockEntry`：包含一个`信号量（Semaphore）`或计数器（`CountDownLatch`），用于阻塞线程直至锁释放事件触发。

`pubSub.subscribe()`具体逻辑：主要就是构建一个`CompletableFuture`。
```java
public CompletableFuture<E> subscribe(String entryName, String channelName) {
  AsyncSemaphore semaphore = service.getSemaphore(new ChannelName(channelName));
  CompletableFuture<E> newPromise = new CompletableFuture<>();
  semaphore.acquire().thenAccept(c -> {
    if (newPromise.isDone()) {
      semaphore.release();
      return;
    }
    E entry = entries.get(entryName);
    if (entry != null) {
      entry.acquire();
      semaphore.release();
      entry.getPromise().whenComplete((r, e) -> {
        if (e != null) {
          newPromise.completeExceptionally(e);
          return;
        }
        newPromise.complete(r);
      });
      return;
    }
    //内容太多，省略
  });
  return newPromise;
}
```

##### 信号量唤醒
```java
public class SemaphorePubSub extends PublishSubscribe<RedissonLockEntry> {
    public SemaphorePubSub(PublishSubscribeService service) {
        super(service);
    }
    @Override
    protected RedissonLockEntry createEntry(CompletableFuture<RedissonLockEntry> newPromise) {
        return new RedissonLockEntry(newPromise);
    }
    @Override
    protected void onMessage(RedissonLockEntry value, Long message) {
        value.tryRunListener();
        //这里就是唤醒信号量的地方
        value.getLatch().release(Math.min(value.acquired(), message.intValue()));
    }
}
```

#### 3.2.2.3、启动看门狗：`scheduleExpirationRenewal()`
回到“尝试获取锁：`tryAcquire()`”逻辑，内部会执行`scheduleExpirationRenewal()`方法
```java
// 启动看门狗线程（在tryAcquire成功后）
private void scheduleExpirationRenewal() {
    watchdog = new WatchdogTimerTask();
    watchdog.schedule(0, internalLockLeaseTime / 3); // 默认每10秒续期（30秒/3）
}

// 续期任务（Lua脚本）
private class WatchdogTimerTask extends TimerTask {
    public void run() {
        renewExpiration(); // 通过Lua脚本延长锁的TTL
    }
}
```
- **定时任务间隔**：默认为 i`nternalLockLeaseTime / 3`，如30秒/3=10秒
- **递归续期**：每次续期成功后，递归调用 `renewExpiration()`，重新启动定时任务，形成循环续期
- **Lua续期脚本**：
```lua
//检查当前线程是否持有锁
if redis.call("hexists", KEYS[1], ARGV[1]) == 1 then
    // 如果持有锁，则延长锁的过期时间
    redis.call("pexpire", KEYS[1], ARGV[2])
    return 1
end
return 0
```
检查当前线程是否持有锁，若持有则延迟过期时间。

**看门狗不启动的条件**：
- 显示指定了 `leaseTime & leaseTime > 0`：锁在指定时间后自动过期，无需续期。


#### 3.2.2.4、锁的可重入
线程标识与计数器
- 每个线程的锁对应一个**Hash结构**，存储以下信息
  - **线程ID**：标识当前锁的持有者
  - **计数器**（counter）：记录同一线程获取锁的次数
- **示例存储结构**：`HSET myLock:threadId "thread-123" 3`
  - `thread-123`是线程标识。
  - `3` 标识该线程已持有锁3次。

LUA脚本
```lua
-- 加锁 Lua 脚本片段
if redis.call("HEXISTS", KEYS[1], ARGV[1]) == 0 then
    -- 锁不存在，创建锁
    redis.call("HSET", KEYS[1], ARGV[1], 1)
    redis.call("PEXPIRE", KEYS[1], ARGV[2])
    return nil
else
    -- 检查是否为当前线程持有
    local count = redis.call("HGET", KEYS[1], ARGV[1])
    if count then
        redis.call("HINCRBY", KEYS[1], ARGV[1], 1)  -- 递增计数器
        return nil
    else
        -- 其他线程持有，返回剩余时间
        return redis.call("PTTL", KEYS[1])
    end
end
```


# 四、方案3：基于Zookeeper的分布式锁

## 4.1、实现原理
- **临时有序节点**
  - 客户端在ZK的锁路径下创建**临时有序节点**（
  - 临时节点的生命周期与客户端会话绑定，客户端断开时节点自动删除，**避免死锁**。
  - 有序性确保锁请求按顺序排队，**实现公平锁**。
- `watcher`监听
  - 客户端判断自己是否为当前最小序号节点
    - **是**：获得锁，执行业务逻辑
    - **否**：监听前一个节点的删除事件，前序节点释放锁后触发重新抢锁。
- **避免羊群效应**（`herd effect`）
  - 每个客户端仅监听前一个节点，而非所有节点，减少ZK事件通知压力。


## 4.2、代码实现
锁路径设计：`/orders/{订单ID}/{临时节点}`
```java
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;

public class OrderLock implements Watcher {
  private static final String LOCK_ROOT = "/order_lock"; // 锁的根节点路径
  private static final String LOCK_PREFIX = "lock_";     // 临时节点前缀
  private ZooKeeper zk;
  private String currentLockNode; // 当前客户端创建的节点路径
  private CountDownLatch connectedSignal = new CountDownLatch(1); // 连接信号

  // 构造函数：连接ZooKeeper服务器
  public OrderLock(String connectString) throws IOException, InterruptedException {
    zk = new ZooKeeper(connectString, 3000, this); // 连接超时3秒
    connectedSignal.await(); // 等待连接成功
    ensureRootNodeExists();  // 确保根节点存在
  }

  // 确保根节点存在
  private void ensureRootNodeExists() throws KeeperException, InterruptedException {
    Stat stat = zk.exists(LOCK_ROOT, false);
    if (stat == null) {
      zk.create(LOCK_ROOT, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }
  }

  // 获取指定订单号的分布式锁
  public void acquireLock(String orderId) throws KeeperException, InterruptedException {
    String orderLockPath = LOCK_ROOT + "/" + orderId; // 订单锁的父路径（如：/order_lock/123）

    // 确保订单锁的父路径存在
    Stat stat = zk.exists(orderLockPath, false);
    if (stat == null) {
      zk.create(orderLockPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }

    // 在订单锁路径下创建临时顺序节点（如：/order_lock/123/lock_0000000001）
    currentLockNode = zk.create(
            orderLockPath + "/" + LOCK_PREFIX,
            new byte[0],
            ZooDefs.Ids.OPEN_ACL_UNSAFE,
            CreateMode.EPHEMERAL_SEQUENTIAL
    );

    while (true) {
      // 获取该订单锁路径下的所有子节点（临时顺序节点）
      List<String> children = zk.getChildren(orderLockPath, false);
      Collections.sort(children); // 按序号升序排序

      // 提取当前节点名称（如：lock_0000000001）
      String currentNodeName = currentLockNode.substring(currentLockNode.lastIndexOf("/") + 1);

      // 判断是否为最小节点
      if (children.get(0).equals(currentNodeName)) {
        System.out.println("Lock acquired for order: " + orderId);
        return; // 成功获取锁
      } else {
        // 监听前驱节点（序号比当前小的最近节点）
        String prevNode = children.get(children.indexOf(currentNodeName) - 1);
        zk.exists(orderLockPath + "/" + prevNode, this); // 注册Watcher
        connectedSignal.await(); // 等待通知
      }
    }
  }

  // 释放锁
  public void releaseLock() throws KeeperException, InterruptedException {
    if (currentLockNode != null) {
      zk.delete(currentLockNode, -1); // 删除临时节点
      System.out.println("Lock released for order: " + currentLockNode);
      currentLockNode = null;
    }
  }

  // Watcher回调：当监听的节点被删除时触发
  @Override
  public void process(WatchedEvent event) {
    if (event.getType() == Event.EventType.NodeDeleted) {
      System.out.println("Node deleted: " + event.getPath());
      connectedSignal.countDown(); // 触发等待线程继续执行
    }
  }

  public static void main(String[] args) throws Exception {
    OrderLock lock = new OrderLock("127.0.0.1:2181");
    try {
      // 示例：获取订单号为123的锁
      lock.acquireLock("123");
      // 执行业务逻辑（如更新订单状态）
      System.out.println("Processing order 123...");
      Thread.sleep(2000); // 模拟业务处理时间
    } finally {
      lock.releaseLock();
    }
    lock.zk.close();
  }
}
```
- **锁的层级结构**
  - **根节点**：`/order_lock` （持久化节点）
  - **订单锁父节点**：`/order_lock/{orderId}` （如`/order_lock/123`，持久化节点）
  - **临时顺序节点**：`/order_lock/{orderId}/lock_00000001` （临时顺序节点）



## 4.2、锁的重入
ZK原生实现不直接支持重入
- **问题根源**：ZK的分布式锁基于临时有序节点，每次加锁都会创建一个新节点。

解决方案：
- 在ZK节点数据中记录线程标识和重入次数，并在客户端维护重入状态。
```java
public class ZkReentrantLock {
    private final ThreadLocal<Integer> holdCount = ThreadLocal.withInitial(() -> 0);
    private final String lockData; // 格式: threadId|count

    public void lock() {
        if (isOwner()) { // 检查当前线程是否已持有锁
            holdCount.set(holdCount.get() + 1);
            return;
        }
        // 创建ZK节点并竞争锁
        createZkNode();
        waitForLock();
        holdCount.set(1);
    }

    public void unlock() {
        if (!isOwner()) {
            throw new IllegalMonitorStateException("非锁持有者");
        }
        int count = holdCount.get() - 1;
        if (count == 0) {
            deleteZkNode(); // 删除节点，释放锁
            holdCount.remove();
        } else {
            holdCount.set(count);
        }
    }

    private boolean isOwner() {
        // 检查ZK节点数据中的线程ID是否与当前线程匹配
        String data = getZkNodeData(currentPath);
        return data != null && data.startsWith(Thread.currentThread().getId() + "|");
    }
}
```



# 五、对比其他方案

| **方案**       | **优点**                          | **缺点**                          | **适用场景**               |
|----------------|-----------------------------------|-----------------------------------|---------------------------|
| **ZK原生实现** | 强一致性、公平锁、天然防死锁       | 代码复杂、需处理会话和重试逻辑     | 对可靠性要求极高的低频场景  |
| **Curator**    | 简化开发、支持高级锁特性           | 依赖Curator库                     | 生产环境首选                |
| **Redis锁**    | 高性能、低延迟                     | 弱一致性、需处理锁续约和脑裂问题   | 高并发允许最终一致性场景    |







