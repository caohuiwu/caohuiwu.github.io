---
title: 序列化方式
date: 2021-07-02
categories:
  - [序列化]
---


<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>

# 一、序列化
**序列化**：将数据结构或对象转换成**二进制串字节流**或其他可存储/传输的格式（如JSON、XML等）
<!--more-->

> <code class="red">二进制串在Java里面所指的是byte[]</code>

## 1.1、核心目的
- **持久化存储**：将对象保存到文件、数据库或磁盘中。
- **网络传输**：通过网络（如HTTP、TCP）将数据发送到其他系统或设备。
- **跨平台通信**：不同编程语言或系统间的数据交换（如Java对象传给Python程序）


# 二、IDL（Interface description language）
接口描述语言（`IDL`），采用`IDL`撰写的协议约定称之为`IDL`文件
- 语言、平台无关
- `IDL`的目的是撰写`IDL`文件，而`IDL`文件被`IDL Compiler`编译后能够产生一些代码（`Stub/Skeleton`）


# 三、序列化方式

## 3.1、XML
- 本质上是一种描述语言，并且具有自我描述（`Self-describing`）的属性，所以XML自身就被用于XML序列化的`IDL`
- 空间和时间开销都比较大，对于对性能要求在ms级别的服务，不推荐使用

## 3.2、JSON

### 3.2.1、优点
- 可读性高
- `XML`所产生序列化之后文件的大小接近`JSON`的两倍
- 具备`Javascript`的先天性支持，所以被广泛应用于`Web browser`的应用常景中，是`Ajax`的事实标准协议
- 与XML相比，其协议比较简单，解析速度比较快
- 具有良好的可扩展性和兼容性

### 3.2.2、应用场景
- 公司之间传输数据量相对小，实时性要求相对低（例如秒级别）的服务
- 基于Web browser的Ajax请求

不适合场景：
- 采用JSON进行序列化的额外空间开销比较大，对于大数据量服务或持久化，这意味着巨大的内存和磁盘开销，这种场景不适合
- 在性能要求为ms级别，不建议使用
- JSON实在是太简单了，或者说太像各种语言里面的类了，所以采用JSON进行序列化不需要IDL(没有IDL，意思是没有统一的描述语言)

## 3.3、Thrift
Thrift有两层含义
- apache thrift：跨语言RPC框架，Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架

示例如下：
```text
struct Address
{
1: required string city;
2: optional string postcode;
3: optional string street;
}
struct UserInfo
{
1: required string userid;
2: required i32 name;
3: optional list
 address;
}
```

### 3.3.1、技术架构

#### 3.3.1.1、IDL（接口定义语言）
- 定义数据类型（如结构体、枚举）和服务接口
- 示例
```thrift
// 定义一个结构体
struct User {
    1: i32 id,
    2: string name,
    3: bool active = true  // 默认值
}

// 定义服务接口
service UserService {
    User getUser(1: i32 userId) throws (1: UserNotFoundException error),
    void createUser(1: User user)
}
```
**支持数据类型**
- **基本类型**
- **结构体类型**：
  - `struct`: 定义的结构体对象
- **容器类型**：
  - `list`: 有序元素列表
- **异常类型**：
  - `exception`: 异常类型
- **服务类型**：
  - `service`: 具体对应服务的类

**限定修饰符**
- **Required**: 表示是一个必须字段
- **Optional**：表示是一个可选字段


#### 3.3.1.2、协议
- `二进制协议`：高效紧凑，适合高性能场景。
- `JSON协议`：可读性强，适合调试。
- `Compact protocol`：压缩格式，体积比二进制更小。

#### 3.3.1.3、传输层（Transport）
- 支持TCP、HTTP、内存传输，灵活适配不同通信场景。


> 由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）
> Thrift的序列化和框架紧耦合，无法支持向持久层直接读写数据，所以不适合做数据持久化序列化协议

## 3.4、Protobuf
`Protocol buffers`（简称`Protobuf`）是由Google开发的序列化框架，用于结构化数据的序列化和跨语言通信。与thrift类似，但设计理念和功能有所不同。

### 3.4.1、定义数据结构
通过`Protocol buffers`定义语言（`.proto`文件）定义数据结构
```text
// 示例：定义一个 User 结构体
syntax = "proto3";  // 指定 proto 版本
package example;

message User {
    int32 id = 1;          // 必须字段
    string name = 2;       // 必须字段
    bool active = 3;       // 可选字段（proto3 中默认不设置则为 false）
    repeated string emails = 4;  // 数组类型
}
```

`message`字段定义说明：

| optional | unit64 | id   | = 3     | [defalut = MALE]; |
|----------|--------|------|---------|-------------------|
| 字段规则     | 字段类型   | 字段名称 | 字段唯一标识符 | 可选的选项：默认值         |
                                                 
> 字段规则
> `required`：必须包含该字段一次
> `optional`：包含该字段零次或一次
> `repeated`：该字段可以重复任意多次，生成的代码是一个列表


### 3.4.2、自动生成代码
通过`protoc`编译器将`.proto`文件生成目标语言代码（如`Java、Python、C++`等），包含序列化/反序列化逻辑。
```bash
protoc --java_out=./src user.proto  # 生成 Java 代码
protoc --python_out=./src user.proto  # 生成 Python 代码
```

生成的Java代码内容
```java
// 包名对应 .proto 中的 package
package example;
public final class User {
    // 字段对应的 getter/setter 方法
    public int getId() { return id_; }
    public User setId(int value) { id_ = value; return this; }

    public String getName() { return name_; }
    public User setName(String value) { name_ = value; return this; }
    // emails 是一个列表
    public List<String> getEmailsList() { return emails_; }
    public User addEmails(String value) { emails_.add(value); return this; }
    // 序列化方法
    public byte[] toByteArray() throws IOException {
        return getDescriptor().newMessageMarshaller(this).toByteArray(this);
    }
    // 反序列化方法
    public static User parseFrom(byte[] data) throws InvalidProtocolBufferException {
        return getDescriptor().newMessageBuilder().mergeFrom(data).build().getElement();
    }
}
```

如何使用生成的Java代码
```java
import example.User;
public class Main {
    public static void main(String[] args) throws Exception {
        // 创建 User 对象
        User user = User.newBuilder()
            .setId(123)
            .setName("Alice")
            .addEmails("alice@example.com")
            .build();

        // 序列化为字节数组
        byte[] data = user.toByteArray();
        System.out.println("Serialized size: " + data.length + " bytes");
    }
}
```


### 3.4.3、序列化协议
`protobuf`主要支持二进制协议，通过`Varint`编码压缩数据，体积小且高效。例如
- **整数编码**：使用`Varint`（可变长度编码）压缩数值（如`7`用1个字节存储，`1000`用2字节）。
- **结构体编码**：字段ID与值的组合（如字段`id=1`的值`123`编码为`08 7b`)


对于下面的数据，用`JSON`需要`103bytes`，而`Protocol Buffers`只需要`50bytes`。
```text
{"id":9223372036854775807,"username":"edgar","mobile":"13412345678","mail":"edgar@github.com","age":30}
```

## 3.5、Hessian
Hessian是一个轻量级的远程过程调用（RPC）协议，基于HTTP实现，提供类似RMI（remote Method Invocation）的功能。使用二进制协议进行数据序列化，适合跨语言通信和传输二进制数据。


### 3.5.1、工作原理
- 必须实现`Serializable`接口
- 无需 `serialVersionUID`

定义可序列化的类
```java
public class User implements Serializable {
    private String name;
    private int age;

    // 构造函数、getter/setter 方法
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    // ... getters and setters
}
```
序列化对象
```java
import com.caucho.hessian.io.Hessian2Output;
import java.io.ByteArrayOutputStream;

public class HessianSerializer {
    public static void main(String[] args) throws Exception {
        // 1. 创建对象
        User user = new User("张三", 25);

        // 2. 初始化输出流
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        Hessian2Output hessian2Output = new Hessian2Output(byteArrayOutputStream);

        // 3. 序列化对象
        hessian2Output.writeObject(user);
        hessian2Output.close();

        // 4. 获取字节数组
        byte[] serializedData = byteArrayOutputStream.toByteArray();
        System.out.println("Serialized size: " + serializedData.length + " bytes");
    }
}
```


### 3.5.2、序列化的内部机制
数据编码规则
- **基本类型优化** ：Hessian对常用类型进行编码优化，例如：
  - `int/short/byte`编码为'I'
  - `long` -> "L"
  - `float/double` -> 'D'
  - `String` -> 'S' + UTF-8字符串
  - `boolean` -> 'T'（真） 或 'F'（假）
- **复杂对象处理**：hessian将对象的属性转换为 Map结构，例如：
```text
M className=Person propertyName=name I 123 propertyName=age S "Alice"
```
这种方式允许自描述，但可能导致**父类与子类同名字段覆盖**（父类字段会覆盖子类字段）


#### 1. 整数（int）
- 编码规则：
使用'I'标记表示`int/short/byte`类型，后续紧跟4字节的整数值（大端序）
- 示例：序列化 `int value = 100;`
二进制字节： `0x49 0x00 0x00 0x00 64`
（`0x49`对应ASCII字符'I'，后跟 `0x00 0x00 0x00 64` 表示十进制100）

#### 2. 长整形（long）
- 编码规则：
使用'L'标记，后续紧跟8字节的长整数值（大端序）
- 示例：序列化`long value = 123456789L`
二进制字节: `0x4C 0x00 0x07 0x5B 0xC9 0x00 0x00 0x00 0x00`
（`0x4C`对应'L'，后跟 `0x00 0x07 0x5B 0xC9 0x00 0x00 0x00 0x00` 表示123456789）

#### 3. 简单对象（如User类）
```java
public class User implements Serializable {
    private String name;
    private int age;
    // 构造函数、getter/setter
}
```
序列化`User("Alice", 30);`
```text
73 00 0F 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 55 73 65 72  // 类名：com.example.User
74 00 05 41 6C 69 63 65                                  // name字段值："Alice"（字符串）
69 00 00 00 1E                                          // age字段值：30（int类型）
```
1. **类名字段**
- 类型标识符：0x73
- 类名内容：
  - 00 0F -> 类名长度为15（十六进制 0F 对应十进制15）
  - 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 55 73 65 72 -> UTF-8编码的com.example.User
    - 63 = 'c', 6F = 'o', 6D = 'm', 2E = '.', 65 = 'e', 78 = 'x', 61 = 'a', 6D = 'm', 70 = 'p', 6C = 'l', 65 = 'e', 2E = '.', 55 = 'U', 73 = 's', 65 = 'e', 72 = 'r'。
2. 字段值序列化
- name 字段（字符串类型）
  - 类型标识符：0x74（对应字符 't'），表示字符串类型。
  - 字符串内容：
    - 00 05 → 字符串长度为 5（"Alice"）。
    - 41 6C 69 63 65 → UTF-8编码的 "Alice"：
    - 41 = 'A', 6C = 'l', 69 = 'i', 63 = 'c', 65 = 'e'。
- age 字段（整数类型）
  - 类型标识符：0x69（对应字符 'i'），表示 int 类型。
  - 整数值：
    - 00 00 00 1E → 四字节大端序表示的 30（0x1E = 30）。



> 相较于Protobuf和Thrift，由于Hessian不需要通过IDL来定义数据和服务，对于序列化的数据只需要实现Serializable接口即可，所以使用上相比Protobuf和Thrift更加容易


## 3.6、JDK序列化

JDK序列化二进制的整体结构，由以下部分组成
```text
[流头] + [对象图] + [结束标记]
```

### 3.6.1、流头（stream header）
固定字节：
- 魔数数字：`0xAC ED`  （2字节）
- 版本号：`0x00 05` （2字节，表示Java5或更高版本）
- 示例：`AC ED 00 05`


### 3.6.2、对象图（Object Graph）

#### 3.6.2.1、类描述符（class Descriptor）
- 类型标识符：`0x73` 表示类描述符的开始
- 类名：使用UTF-8编码的类全限定名（如 `Ljava/lang/String`）。
- 序列化`VersionUID`
- 字段列表

示例：序列化User类的类描述符二进制片段
```text
73 00 0A 4C 6A 61 76 61 2F 6C 61 6E 67 2F 55 73 65 72  // 类名：java/lang/User
00 00 00 01 72 00 03 6E 61 6D 4C 00 03 61 67 65 74  // 字段名：name, age
```

#### 3.6.2.2、对象数据（Object Data）
- 对象头：标识对象的开始和类型
  - 非代理对象：`0x73`
  - 代理对象：`0x71`
- 字段值：按字段顺序存储，类型由类描述符决定
  - 基本类型：直接二进制形式存储
  - 对象引用：存储句柄表索引（如0x70后跟4字节索引）
  - 字符串：用0x73标记后跟UTF-8编码的字符串

示例：序列化`User("Alice", 30)`的字段数据
```text
72 00 03 6E 61 6D 74 00 05 41 6C 69 63 65  // 字段name的值："Alice"
74 00 00 00 1E  // 字段age的值：30（int）
```

### 3.6.3、结束标识
`0x77`表示序列化结束。



### 具体示例
```java
class User implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    // 构造函数、getter/setter
}
```
序列化后的二进制字节（十六进制表示）
```text
AC ED 00 05 73 72 00 04 55 73 65 72 12 E2 A0 A4 F7 81 89 60 89 67 02 00 02 4C 00 03 61 67 65 74 00 03 4E 61 6D 65 00 04 00 00 00 02 74 00 05 41 6C 69 63 65 74 00 1E
```
1. **流头**
  - AC ED 00 05：魔术数字和版本号
2. **类描述符**
- 73：类描述符开始
- 72 00 04 55 73 65 72：类名User
  - 0x72：字符串长度
  - 0x04：长度
  - 55 73 65 72：User的UTF-8编码
- 12 E2 A0 A4 F7 81 89 60 89 67： serialVersionUID
3. **字段数据**：
- 74 00 05 41 6C 69 63 65：字符串Alice
  - 0x74：标记字符串
  - 0x05：长度5
  - 41 6C 69 63 65：是Alice
- 74 00 1E：整数30（0x1E是十六进制的30）





## 3.7、JDK & Hessian对比
```java
class User implements Serializable {
    private String name;
    private int age;
}
```
User("Alice", 30)

JDK
```text
AC ED 00 05 73 72 00 04 55 73 65 72 12 E2 A0 A4 F7 81 89 60 89 67 02 00 02 4C 00 03 61 67 65 4C 00 04 6E 61 6D 65 54 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 56 00 02 00 02 78 70 00 00 00 1E 74 00 05 41 6C 69 63 65 78 00
```
Hessian
```text
73 00 0F 63 6F 6D 2E 65 78 61 6D 70 6C 65 2E 55 73 65 72  // 类名：com.example.User
74 00 05 41 6C 69 63 65                                  // name字段值："Alice"
69 00 00 00 1E                                          // age字段值：30（int类型）
```

| 序列化方式   | 二进制体积     | 体积差异原因                                  |
|---------|-----------|-----------------------------------------|
| JDK     | 约50字节（示例） | 包含类描述符、元数据（如serialVersionUID)、继承关系等冗余信息 |
| Hessian | 约27字节（示例） | 仅传输类名和字段值，无冗余元数据，类型标识符更紧凑               |


