---
title: 《spring》容器启动 -step11- 填充Bean
date: 2021-01-13
categories:
  - [spring, 容器, 创建Bean]
---

    这是spring系列的第七篇文章，主要介绍的是容器启动中的第11个步骤，创建bean的三大流程的populateBean。

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #6260ff;
}
</style>

# 一、Spring
`spring框架`是Java生态中最主流的轻量级开源应用框架，其核心目标是简化企业级应用开发，通过`IOC（控制反转）`和`AOP（面向切面编程）`两大核心机制实现解耦、模块化和可维护性。

<!-- more -->


# 二、doCreateBean
继续回顾一下Bean的创建流程：

首先需要了解是Spring它创建Bean的流程，大致调用栈绘图如下：
![Bean创建流程](2021-01-12-spring-容器启动-步骤11-实例化Bean/Bean创建流程.png)

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {

    // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器
    BeanWrapper instanceWrapper = null;
    // 单例模型，则从未完成的 FactoryBean 缓存中删除
    if (mbd.isSingleton()) {
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
  // 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化
    if (instanceWrapper == null) {
        //实例化
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    // 包装的实例对象
    final Object bean = instanceWrapper.getWrappedInstance();
    // 包装的实例对象的类型
    Class<?> beanType = instanceWrapper.getWrappedClass();
    if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
    }

  // 检测是否有后置处理
  // 如果有后置处理，则允许后置处理修改 BeanDefinition
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
              // applyMergedBeanDefinitionPostProcessors
              // 后置处理修改 BeanDefinition
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }
            mbd.postProcessed = true;
        }
    }

  // 解决单例模式的循环依赖
  // 单例模式 & 允许循环依赖&当前单例 bean 是否正在被创建
    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
            isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
      // 提前将创建的 bean 实例加入到ObjectFactory 中
      // 这里是为了后期避免循环依赖
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
    }

    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        //属性注入
        populateBean(beanName, mbd, instanceWrapper);
        //初始化
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
   //.循环依赖处理
    if (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, false);
        if (earlySingletonReference != null) {
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            }
            else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                for (String dependentBean : dependentBeans) {
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
            }
        }
    }
  // 注册 bean
    registerDisposableBeanIfNecessary(beanName, bean, mbd);

    return exposedObject;
}
```
大概流程如下：
- createBeanInstance() 实例化 bean
- populateBean() 属性填充
- 循环依赖的处理
- initializeBean() 初始化 bean



# 三、流程3：populateBean() 属性填充
`populateBean`方法主要负责对`@Autowired、@Resource、@Value`等注解标注的属性进行填充，一些普通的成员变量则通过反射或者构造函数、set 方法等注入。
```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
  // 基础校验
  if (bw == null) {
    ....
  }
  /*
      InstantiationAwareBeanPostProcessor的后置处理 postProcessAfterInstantiation用于用户扩展
      用户实现一个InstantiationAwareBeanPostProcessor 类型的后置处理器，
      并通过postProcessAfterInstantiation 方法向 bean 的成员变量注入自定义的信息。
   */
  if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
      for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
          if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
              return;
          }
      }
  }
  // 获取到属性列表
  PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
  // 根据名称或类型注入依赖
  int resolvedAutowireMode = mbd.getResolvedAutowireMode();
  if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
      // 通过属性名称注入依赖
      if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
          autowireByName(beanName, mbd, bw, newPvs);
      }
      // 通过属性类型注入依赖
      if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
          autowireByType(beanName, mbd, bw, newPvs);
      }
      pvs = newPvs;
  }

  boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
  boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

  // InstantiationAwareBeanPostProcessor的postProcessProperties后置处理
  PropertyDescriptor[] filteredPds = null;
  if (hasInstAwareBpps) {
      if (pvs == null) {
          pvs = mbd.getPropertyValues();
      }
      for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
          // 对属性进行后置处理
          PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
          if (pvsToUse == null) {
              if (filteredPds == null) {
                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
              }
              pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
              if (pvsToUse == null) {
                  return;
              }
          }
          pvs = pvsToUse;
      }
  }
  if (needsDepCheck) {
      if (filteredPds == null) {
          filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      }
      checkDependencies(beanName, mbd, filteredPds, pvs);
  }

  // 应用属性值到 bean 对象中
  if (pvs != null) {
      applyPropertyValues(beanName, mbd, bw, pvs);
  }
}
```
方法流程总结：
1. 参数校验
2. 调用`InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation`，在属性填充前修改Bean状态，甚至终止后续操作
3. 处理自动装配（autowire模式）
   1. `AUTOWIRE_BY_NAME`：根据属性名匹配容器中的Bean进行注入
   2. `AUTOWIRE_BY_TYPE`：根据属性类型匹配容器中的Bean进行注入
4. 处理注解驱动的依赖注入
   1. 通过 `AutowiredAnnotationBeanPostProcessor`等后置处理器，将`@Autowired、@Value`等注解标注的属性注入
5. 应用属性值（`applyPropertyValues`）
   1. 将收集到的`PropertyValues`应用到`BeanWrapper`中。

## 3.1、PopulationBean详解

### 3.1.1、属性填充判断
```java
// 当前bean不是合成的 && 存在 InstantiationAwareBeanPostProcessor 处理器
// !mbd.isSynthetic() 没明白什么场景
if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
    for (BeanPostProcessor bp : getBeanPostProcessors()) {
        if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                return;
            }
        }
    }
}
```
如下，这里调用了`InstantiationAwareBeanPostProcessor #postProcessAfterInstantiation` 方法来决定是否继续注入属性。该方法正常返回true。如果返回false 则将取消对此bean调用任何后续的`InstantiationAwareBeanPostProcessor` 方法。

### 3.1.2、自动装配（`XML配置中声明式`）
在下面这段代码中，对 `AUTOWIRE_BY_NAME` 类型和 `AUTOWIRE_BY_TYPE` 的 种类进行自动装配。
- 此自动装配是`XML配置中声明式`自动装配的两种模式
```java
if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
    MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
    // Add property values based on autowire by name if applicable.
    if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
        // 根据 beanName 进行装配
        autowireByName(beanName, mbd, bw, newPvs);
    }
    // Add property values based on autowire by type if applicable.
    if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
        // 根据 bean 类型进行装配
        autowireByType(beanName, mbd, bw, newPvs);
    }
    pvs = newPvs;
}
```

这一段代码的目的是，如果bean在声明的时候指定了自动注入类型是 `byName`或者`byType`，则会根据这个规则，对 bean内部的排除某些特定的属性(排除规则后面详解)， 进行`byName` 或者 `byType`的自动装配。


> byType 示例
> ```
> <bean id="service" class="com.example.Service" autowire="byType"/>
```
>
> byName示例
> ```
<bean id="service" class="com.example.Service" autowire="byName"/>
<bean id="userDao" class="com.example.UserDao"/>
```
此时，service类中名为userDao的字段会自动注入id="userDao"的Bean。



#### 3.1.2.1、自动装配-autowireByName
```java
protected void autowireByName(
        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {
    // 寻找bw中需要依赖注入的属性name
    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
    for (String propertyName : propertyNames) {
        // 检查缓存bean 中是否有当前bean
        if (containsBean(propertyName)) {
            // 递归初始化bean，会调用doGetBean 来 获取bean
            Object bean = getBean(propertyName);
            pvs.add(propertyName, bean);
            // 注册依赖，将依赖关系保存到 Map<String, Set<String>> dependentBeanMapdependentBeanMap 中，key是 bean，value是 转化后的 propertyName
            registerDependentBean(propertyName, beanName);
            if (logger.isTraceEnabled()) {
                logger.trace("Added autowiring by name from bean name '" + beanName +
                        "' via property '" + propertyName + "' to bean named '" + propertyName + "'");
            }
        }
        else {
            // 找不到则不处理
            if (logger.isTraceEnabled()) {
                logger.trace("Not autowiring property '" + propertyName + "' of bean '" + beanName +
                        "' by name: no matching bean found");
            }
        }
    }
}
```
可以看到，`byName` 的处理逻辑很简单，一句话概括，获取需要注入的bean然后递归调用<code class="red">getBean</code>获取bean进行注入。 关于 `unsatisfiedNonSimpleProperties` 方法在后面有讲解。

#### 3.1.2.2、自动装配-autowireByType
执行逻辑会复杂的多。
- **步骤1、获取非简单属性**：调用 `unsatisfiedNonSimpleProperties()`方法，收集需要自动注入的属性名称。
- **步骤2、遍历属性并匹配类型**：对于每个属性名（propertyName）
  - 1、获取属性描述符：通过`PropertyDescriptor`获取属性的类型（propertyType）
  - 2、构造`DependencyDescriptor`：将属性类型封装为 `AutowireByTypeDependencyDescriptor`，用于后续依赖解析。
  - 3、调用 `resolveDependency()`：根据`DependencyDescriptor`在容器中查找匹配的Bean。
  - 4、处理结果：
    - 若找到唯一匹配的Bean，则将其注入到属性中。
    - 若未找到或存在多个匹配Bean，抛出异常。
- **步骤3：注册依赖关系**
  - 将注入的Bean与当前Bean的名称关联，以便管理依赖关系（如销毁时的顺序）。

```java
protected void autowireByType(
    String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {
    // 获取自定义的类型转换器
    TypeConverter converter = getCustomTypeConverter();
    if (converter == null) {
        converter = bw;
    }
    
    Set<String> autowiredBeanNames = new LinkedHashSet<>(4);
    // 寻找 bw中需要依赖注入的属性name
    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
    for (String propertyName : propertyNames) {
        try {
            // 获取属性描述符
            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
            // Don't try autowiring by type for type Object: never makes sense,
            // even if it technically is a unsatisfied, non-simple property.
            // 这里不解析Object的官方注释 ：不要尝试按类型为Object类型自动装配：即使从技术上讲是不满意的，非简单的属性，也从没有意义。
            if (Object.class != pd.getPropertyType()) {
                // 获取指定属性的 set 方法
                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
                // Do not allow eager init for type matching in case of a prioritized post-processor.
                boolean eager = !(bw.getWrappedInstance() instanceof PriorityOrdered);
                DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
                // 解析指定beanName 的属性所匹配的值，并把解析到的属性名存储在 autowiredBeanNames  中
                // 当属性存在多个封装bean时，如 @Autowired List<Bean> beans,会找到所有的匹配Bean 类型的bean并将其注入。
                // 这里的返回值是真正的需要注入的属性， autowiredBeanNames 是需要注入的属性(可能是集合)的names
                Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
                if (autowiredArgument != null) {
                    // 添加到待注入的bean列表中
                    pvs.add(propertyName, autowiredArgument);
                }
                // 注册依赖
                for (String autowiredBeanName : autowiredBeanNames) {
                    // 注册依赖关系。操作 dependentBeanMap 和  dependenciesForBeanMap 集合
                    registerDependentBean(autowiredBeanName, beanName);
                    if (logger.isTraceEnabled()) {
                        logger.trace("Autowiring by type from bean name '" + beanName + "' via property '" +
                                propertyName + "' to bean named '" + autowiredBeanName + "'");
                    }
                }
                autowiredBeanNames.clear();
            }
        }
        catch (BeansException ex) {
            throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
        }
    }
}
```
这里面的主要的逻辑被封装到了 `resolveDependency` 方法中，我们下面来看看`DefaultListableBeanFactory#resolveDependency` 方法的具体实现。
```java
public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
        @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
    
    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
    // 针对不同类型的不同处理
    if (Optional.class == descriptor.getDependencyType()) {
        return createOptionalDependency(descriptor, requestingBeanName);
    }
    else if (ObjectFactory.class == descriptor.getDependencyType() ||
            ObjectProvider.class == descriptor.getDependencyType()) {
        return new DependencyObjectProvider(descriptor, requestingBeanName);
    }
    else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
        return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
    }
    else {
        // 处理bean是否懒加载，如果懒加载，创建一个代理对象注入bean
        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
                descriptor, requestingBeanName);
        if (result == null) {
            // 针对一般类型的通用
            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
        }
        return result;
    }
}
```
上面的逻辑比较清晰，对一些特殊的类型进行特殊处理，一般的通用处理都会调用 `doResolveDependency` 方法。这里我们不去关注特殊类型的处理，下面再来看看
`DefaultListableBeanFactory#doResolveDependency` 方法，代码如下。

`doResolveDependency` 封装了依赖查找的各种情况：
- **快速查找**： @Autowired 注解处理场景。AutowiredAnnotationBeanPostProcessor 处理 @Autowired 注解时，如果注入的对象只有一个，会将该 bean 对应的名称缓存起来，下次直接通过名称查找会快很多。
- **注入指定值**：@Value 注解处理场景。QualifierAnnotationAutowireCandidateResolver 处理 @Value 注解时，会读取 @Value 对应的值进行注入。如果是 String 要经过三个过程：①占位符处理 -> ②EL 表达式解析 -> ③类型转换，这也是一般的处理过程，BeanDefinitionValueResolver 处理 String 对象也是这个过程。
- **集合依赖查询**：直接全部委托给 resolveMultipleBeans 方法。
- **单个依赖查询**：先调用 findAutowireCandidates 查找所有可用的依赖，如果有多个依赖，则根据规则匹配： @Primary -> @Priority -> ③方法名称或字段名称。
```java
@Nullable
public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
        @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {
    // 只有ShortcutDependencyDescriptor实现了resolveShortcut方法，返回了非空值。目前版本代码只在AutowiredFieldElement、AutowiredMethodElement类中使用到，也即是说，只有解析@Autowired、@Value注解的元素才会用到，目的是为了将解析结果缓存起来，避免重复解析
    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
    try {
        // 尝试获取缓存
        Object shortcut = descriptor.resolveShortcut(this);
        if (shortcut != null) {
            // 存在缓存直接返回
            return shortcut;
        }
        // 获取 依赖的类型
        Class<?> type = descriptor.getDependencyType();
        // 取值@Value注解中的value属性中的值，这里取出的值是未经修改的值，即带有 ${} 标签的值。如果descriptor未被@Value标注，则返回null
        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
        if (value != null) {
            // 到这里说明属性被 @Value 注解修饰了，这里是解析 @Value 注解的逻辑
            // 如果value不为null，
            if (value instanceof String) {
                // 处理占位符如${}，做占位符的替换(不解析SP EL表达式)
                String strVal = resolveEmbeddedValue((String) value);
                BeanDefinition bd = (beanName != null && containsBean(beanName) ?
                        getMergedBeanDefinition(beanName) : null);
                //		解析SP EL(如#{})
                value = evaluateBeanDefinitionString(strVal, bd);
            }
            TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
            try {
                // 类型转换，把解析出来的结果转成type类型
                return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
            }
            catch (UnsupportedOperationException ex) {
                // A custom TypeConverter which does not support TypeDescriptor resolution...
                return (descriptor.getField() != null ?
                        converter.convertIfNecessary(value, type, descriptor.getField()) :
                        converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
            }
        }
        // 对集合类型进行处理，包括，Array、Collection、Map。后面详解
        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
        if (multipleBeans != null) {
            // 如果解析出来集合类型，则直接返回
            return multipleBeans;
        }
        
        // 调用查找所有类型为type的实例，存放在matchingBeans <beanName, bean> (在 resolveMultipleBeans 方法中也是核心也是调用该方法)。下面详解
        Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
        if (matchingBeans.isEmpty()) {
            if (isRequired(descriptor)) {
            // 如果没有找到，并且bean 并标注为 required = true, 则抛出NoSuchBeanDefinitionException异常
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            return null;
        }

        String autowiredBeanName;
        Object instanceCandidate;
        // 如果找到了不止一个匹配的bean，Spring 按照一定规则进行挑选
        if (matchingBeans.size() > 1) {
        // 按以下顺序，找到符合条件的就直接返回
        // 1. 挑选出被标识为primary的bean
        // 2. 挑选标识了@Priority，且先级级最高的bean。可以不标识，一旦标识，不允许同一优先级的存在
        // 3. fallback，依赖的名称与matchingBeans中任意一Key匹配
            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
            if (autowiredBeanName == null) {
                if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
                    // 非集合类，找到了多个符合条件的Bean，抛出异常
                    return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
                }
                else {
                    // In case of an optional Collection/Map, silently ignore a non-unique case:
                    // possibly it was meant to be an empty collection of multiple regular beans
                    // (before 4.3 in particular when we didn't even look for collection beans).
                    return null;
                }
            }
            instanceCandidate = matchingBeans.get(autowiredBeanName);
        }
        else {
            // We have exactly one match.
            // 如果只找到了唯一匹配的元素，则直接使用
            Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
            autowiredBeanName = entry.getKey();
            instanceCandidate = entry.getValue();
        }

        if (autowiredBeanNames != null) {
            // 将待装配的Bean名称放入autowiredBeanNames集合里
            autowiredBeanNames.add(autowiredBeanName);
        }
        if (instanceCandidate instanceof Class) {
            // 这里又去调用 getBean 方法去获取bean
            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
        }
        Object result = instanceCandidate;
        if (result instanceof NullBean) {
            if (isRequired(descriptor)) {
            // 如果 result 是 NullBean类型，且 required = true，则抛出异常
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            result = null;
        }
        // 类型校验，确保类型与解析出来的Bean实例能够匹配
        if (!ClassUtils.isAssignableValue(type, result)) {
            throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
        }
        return result;
    }
    finally {
        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
    }
}

...
 
protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {
    // 获取类型
    Class<?> requiredType = descriptor.getDependencyType();
    // 获取 primary 的 候选beanName
    String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);
    if (primaryCandidate != null) {
        return primaryCandidate;
    }
    // 获取 Priority 最高（优先级最高的） beanName
    String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);
    if (priorityCandidate != null) {
        return priorityCandidate;
    }
    // Fallback
    // 通过回调返回。
    for (Map.Entry<String, Object> entry : candidates.entrySet()) {
        String candidateName = entry.getKey();
        Object beanInstance = entry.getValue();
        if ((beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) ||
                matchesBeanName(candidateName, descriptor.getDependencyName())) {
            return candidateName;
        }
    }
    return null;
}

```

#### 3.1.2.3、自动装配总结
最终，将自动匹配的Bean或其他属性值（如显示配置的<property>）收集到`PropertyValues`对象中，最终调用`applyPropertyValues`注入属性。

### 3.1.3、成员变量的注入（针对注解方式）
代码分析：通过后置处理器，主要是对 `@Autowired  @Resource` 标记的属性进行依赖注入
```java
for (BeanPostProcessor bp : getBeanPostProcessors()) {
    if (bp instanceof InstantiationAwareBeanPostProcessor) {
        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
        PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }
            pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
        pvs = pvsToUse;
    }
}
```
这里通过 InstantiationAwareBeanPostProcessor 的 后处理器的postProcessPropertyValues 方法完成了属性的注入。
- `@Autowired`和`@Inject`都是按照类型注入，使用后置处理器进行实例化注入（`AutowiredAnnotationBeanPostProcessor`）
  - 获取被 @Autowired 修饰的 属性或者方法，**如果是属性**，则通过getBean 获取bean并注入；**如果是方法**，则获取方法参数后，invoke 方法(调用该方法，因为我们一般写的都是set方法，给属性注入赋值)。
- `@Resource`按名称注入（`CommonAnnotationBeanPostProcessor`后置处理器）

#### 3.1.3.1、AutowiredAnnotationBeanPostProcessor

```java
// AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues 方法
@Override
public PropertyValues postProcessPropertyValues(
    PropertyValues pvs, 
    PropertyDescriptor[] pds, 
    Object bean, 
    String beanName
) throws BeansException {
    // 处理 @Autowired 和 @Value 注解的字段和方法
    injectFields(bean, beanName);
    injectMethods(bean, beanName);
    return pvs;
}

// 注入字段的示例逻辑
private void injectFields(Object bean, String beanName) {
    for (AutowiredFieldElement field : this.autowiredFields) {
        Object value = resolveFieldValue(beanName, field);
        ReflectionUtils.setField(field.getField(), bean, value);
    }
}
```
`injectFields`方法的作用是通过反射机制，将spring容器中匹配的Bean实例注入到当前Bean的字段中。
- 目标：处理通过 `@Autowired, @Inject, @Value` 等注解标记的字段。
- 流程：根据预处理阶段收集的元数据（`InjectionMetadata`），逐个注入每个字段的依赖。


### 3.1.4、applyPropertyValues
作用是将`PropertyValues`中的属性注入到Bean中，通常用于处理通过XML配置的属性注入（即XML的自动装配，只是将属性保存了起来，并未真正设置到bean中）。
```java
protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
    if (pvs.isEmpty()) {
        return;
    }
    if (System.getSecurityManager() != null && bw instanceof BeanWrapperImpl) {
        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
    }

    MutablePropertyValues mpvs = null;
    List<PropertyValue> original;
    // 如果pvs 是 MutablePropertyValues 类型的封装
    if (pvs instanceof MutablePropertyValues) {
        mpvs = (MutablePropertyValues) pvs;
        // 如果 mpv 中的值类型已经转换完毕，则可以直接设置到BeanWrapper 中
        if (mpvs.isConverted()) {
            // Shortcut: use the pre-converted values as-is.
            try {
                bw.setPropertyValues(mpvs);
                return;
            }
        }
        // 保存原始值，等待类型转换
        original = mpvs.getPropertyValueList();
    }
    else {
        // 保存原始值，等待类型转换
        original = Arrays.asList(pvs.getPropertyValues());
    }
    // 获取类型转换器
    TypeConverter converter = getCustomTypeConverter();
    if (converter == null) {
        converter = bw;
    }
    BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

    // Create a deep copy, resolving any references for values.
    // 准备进行深拷贝
    List<PropertyValue> deepCopy = new ArrayList<>(original.size());
    boolean resolveNecessary = false;
    // 遍历属性，将属性转换为对应类的对应属性类型
    for (PropertyValue pv : original) {
        // 如果已经转换之后直接保存
        if (pv.isConverted()) {
            deepCopy.add(pv);
        }
        else {
            // 进行类型转换
            String propertyName = pv.getName();
            Object originalValue = pv.getValue();
            if (originalValue == AutowiredPropertyMarker.INSTANCE) {
                Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();
                if (writeMethod == null) {
                    throw new IllegalArgumentException("Autowire marker for property without write method: " + pv);
                }
                originalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true);
            }
            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
            Object convertedValue = resolvedValue;
            
            boolean convertible = bw.isWritableProperty(propertyName) &&
                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
            if (convertible) {
                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
            }
            // Possibly store converted value in merged bean definition,
            // in order to avoid re-conversion for every created bean instance.
            if (resolvedValue == originalValue) {
                if (convertible) {
                    pv.setConvertedValue(convertedValue);
                }
                deepCopy.add(pv);
            }
            else if (convertible && originalValue instanceof TypedStringValue &&
                    !((TypedStringValue) originalValue).isDynamic() &&
                    !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
                pv.setConvertedValue(convertedValue);
                deepCopy.add(pv);
            }
            else {
                resolveNecessary = true;
                deepCopy.add(new PropertyValue(pv, convertedValue));
            }
        }
    }
    if (mpvs != null && !resolveNecessary) {
        mpvs.setConverted();
    }
    // Set our (possibly massaged) deep copy.
    try {
        bw.setPropertyValues(new MutablePropertyValues(deepCopy));
    }
}
```
对实例属性进行赋值操作【最终会调用setter方法进行属性的赋值操作】

# 四、populateBean小结
从上文中，我们了解到自动装配可以分成两种模式
- 注解驱动的自动装配
- XML声明式自动装配


| 场景         | 使用方式                                              | 实现类/机制                               |
|------------|---------------------------------------------------|--------------------------------------|
| 注解驱动的自动装配  | 通过 @Autowired @Value等注解标注字段/方法                    | AutowiredAnnotationBeanPostProcessor |
| XML声明式自动装配 | 通过XML的autowire="byType" 或 autowire="byName"属性配置Bean | DefaultListableBeanFactory的底层逻辑      |

现代Spring开发中，推荐使用注解驱动的方式（如Autowired），而XML的autowire已经基本弃用。

| 注解组合	                   | 注入方式	| 依赖查找                          | 说明                                           |
|-------------------------|----------|-------------------------------|----------------------------------------------|
| @Autowired	             | byType	 | beanFactory#resolveDependency | 默认按类型注入，要求容器中存在唯一匹配类型的 Bean。                 |
| @Autowired + @Qualifier | 	byName  |                               | 	通过 @Qualifier 的 value 属性指定 Bean 名称，强制按名称注入。 |
| @Resource	              | byName   | getBean(beanName)             | 	默认按名称注入，若名称未指定则使用属性/字段名，若未找到再按类型匹配（兼容性更强）。  |



参考文章：
[如何利用"三级缓存"巧妙解决Bean的循环依赖问题的](https://cloud.tencent.com/developer/article/1497692)
https://github.com/xuchengsheng/spring-reading/blob/master/spring-core/spring-core-resolveDependency/README.md