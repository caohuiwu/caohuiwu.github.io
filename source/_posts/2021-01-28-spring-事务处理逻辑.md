---
title: 《spring》事务处理逻辑
date: 2021-01-28
categories:
  - [spring, 事务]
---

    这是spring系列的第12篇文章，主要介绍的是事务的处理逻辑。

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>

# 一、Spring
`spring框架`是Java生态中最主流的轻量级开源应用框架，其核心目标是简化企业级应用开发，通过`IOC（控制反转）`和`AOP（面向切面编程）`两大核心机制实现解耦、模块化和可维护性。

<!-- more -->

# 二、TransactionInterceptor解析
`TransactionInterceptor`属于spring事务模块，用于在方法调用前后关管理事务。`invoke`方法是拦截器的核心，负责启动、提交或回滚事务。

## 2.1、TransactionInterceptor的BeanDefinition
BeanDefinition的创建时间，会在解析`<tx>`标签时创建。
```java
class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser {
    private static class AopAutoProxyConfigurer {
        public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {
            AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

            String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;
            if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {
                Object eleSource = parserContext.extractSource(element);
                // 创建 TransactionInterceptor definition.
                RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
                interceptorDef.setSource(eleSource);
                interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
                registerTransactionManager(element, interceptorDef);
                interceptorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
                String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);

                // 注册Advisor并绑定Interceptor
                RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
                advisorDef.setSource(eleSource);
                advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
                advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
                advisorDef.getPropertyValues().add("adviceBeanName", interceptorName);
                if (element.hasAttribute("order")) {
                    advisorDef.getPropertyValues().add("order", element.getAttribute("order"));
                }
            }
        }
    }
}
```

## 2.2、TransactionInterceptor执行
```java
public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable {
    @Override
    public Object invoke(final MethodInvocation invocation) throws Throwable {
        // Work out the target class: may be {@code null}.
        // The TransactionAttributeSource should be passed the target class
        // as well as the method, which may be from an interface.
        Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

        // Adapt to TransactionAspectSupport's invokeWithinTransaction...
        return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {
            @Override
            public Object proceedWithInvocation() throws Throwable {
                //继续执行拦截器链或目标方法
                return invocation.proceed();
            }
        });
    }
}
```

# 三、回顾JDBC事务
先回顾一下JDBC事务，要在 JDBC 中开启一个事务，需要执行以下步骤：
- 创建一个数据库连接（`Connection`）对象。
- 将连接的自动提交模式设置为 false，这意味着事务不会自动提交。
- 在事务中执行一系列的 SQL 操作。
- 最后，根据操作的成功或失败，选择提交事务（commit）或回滚事务（rollback）。
```java
public class TransactionExample {
    public static void main(String[] args) {
        String jdbcUrl = "jdbc:mysql://localhost:3306/mydatabase";
        String username = "root";
        String password = "password";
        try (Connection connection = DriverManager.getConnection(jdbcUrl, username, password)) {
            // 设置事务隔离级别为 TRANSACTION_SERIALIZABLE
            connection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
            // 关闭自动提交，开启事务
            connection.setAutoCommit(false);
            // 执行一系列数据库操作
            // 提交事务
            connection.commit();
        } catch (SQLException e) {
            e.printStackTrace();
            // 发生异常，回滚事务
            connection.rollback();
        } finally {
            if (connection != null) {
                connection.close();//关闭连接
            }
        }
    }
}
```

## 3.1、Connection
**概念**：Connection 是 Java 中**表示与数据库建立的连接的接口**，位于 java.sql 包中。通过 `Connection` 对象可以执行 SQL 语句、管理事务等。

### 3.1.1、Connection必备知识点
**连接方式**：在Java中，用`Connection`代表了应用程序与数据库之间的一条物理连接通道，通信的方式目前基本上采用的是TCP/IP 连接方式。是一个<code class="red">长连接</code>。

**连接超时时间**：如果在长连接内，客户端没有指令发出，要超过服务端的数据。那么MySQL客户端也会做出对应的措施来断掉来自客户端连接

> 客户端如果长时间不发送command到Server端，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。
> 查看wait_timeout对应的SQL：
> ```
mysql> show global variables like "wait_timeout";
mysql>set global wait_timeout=28800; 设置全局服务器关闭非交互连接之前等待活动的秒数
> ```

### 3.1.2、Connection连接数量
```
-- 查看当前数据库最多支持多少数据库连接
show variables like '%max_connections%';
-- 设置当前运行时mysql的最大连接数，服务重启连接数将还原
set GLOBAL max_connections = 200;
-- 修改 my.ini 或者my.cnf 配置文件
max_connections = 200;
```

### 3.1.3、线程安全
JDBC的`Connection`对象在多线程环境下使用时存在线程不安全的问题，主要原因如下：

#### 1. 资源竞争与共享状态
- 共享状态的修改
  - `Connection`对象内部维护了一些共享状态，例如
    - 事务状态（如是否自动提交、当前事务的隔离级别）
    - 当前执行的SQL语句和结果集
    - 参数设置：如`preparedStatement`的参数值

如果多个线程共享同一个`Connection`实例，他们可能同时修改这些共享状态，导致以下问题：
- **事务冲突**：一个线程开启事务后，另外一个线程可能意外调用`commit()`或 `rollback()`，破坏事务的完整性。
- **SQL执行混乱**：多个线程同时执行不同的SQL语句，导致语句顺序交错执行，结果不可预测。

#### 2. 事务管理的不安全性
事务状态的干扰
如果多个线程共享同一个Connection，它们的事务操作会相互干扰。例如
- 线程A执行 `connection.setAutoCommit(false)`开启事务，但线程B可能在未完成时调用`connection.commit()`，导致事务提前提交。
- 线程C可能在事务未提交时直接调用`connection.close()`，强制回滚所有未提交的更改。


#### 3. 方法调用的非原子性

#### 4. 内部同步机制的局限性
部分同步当无法保证全局一致性
虽然JDBC驱动对部分方法（如`executeUpdate()`）进行了同步（synchronized），但无法保证所有操作的原子性


#### 5. 连接池的解决方案
为了解决Connection的线程不安全问题，必须通过连接池为每个线程分配独立的Connection实例。以下是关键点：
- **连接池的作用**：连接池管理多个Connection实例，并确保每个线程从池中获取独立的Connection，避免共享问题。
- 典型的使用模式
```java 
  try(Connection conn = dataSource.getConnection()) {
      //每个线程使用独立的connection
      try(PreparedStatement stmt = conn.prepareStatement("...")){
          //执行SQL操作
      }
  }
```

自动资源管理（ARM）：使用`try-with-resource`确保Connection在使用后立即归还池并关闭，避免资源泄露。


# 四、spring事务处理核心流程：invokeWithinTransaction
实际<code class="red">**事务处理逻辑**</code>在该方法中完成。

```java
protected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)
			throws Throwable {
    // 获取@Tranactional注解上的属性（在上文中有解析是如何封装的）
    final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
    //获取事务管理器：若@Transactional制定了transactionManager，则按名称从容器获取。否则使用默认事务管理器（默认名称为transactionManager）
    final PlatformTransactionManager tm = determineTransactionManager(txAttr);
    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
        //进行标准事务流程，先获取事务，再执行原始方法，最后commit/rollback
        //创建事务：把事务相关的类用TransactionInfo类存放
        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
        Object retVal = null;
        try {
            //执行后续拦截器或目标方法
            retVal = invocation.proceedWithInvocation();
        }
        catch (Throwable ex) {
            // 异常处理
            completeTransactionAfterThrowing(txInfo, ex);
            throw ex;
        }
        finally {
            cleanupTransactionInfo(txInfo);
        }
        //提交事务
        commitTransactionAfterReturning(txInfo);
        return retVal;
    }
    //编程式事务
}
```

## 4.1、创建事务：`createTransactionIfNecessary`
createTransactionIfNecessary是TransactionAspectSupport类中的一个受保护方法，其核心功能是：
- 根据事务传播属性（如`PROPAGATION_REQUIRED`）决定是否创建新的事务
- 获取事务状态（`TransactionStatus`），并封装到`TransactionInfo`对象中，供后续提交或回滚操作使用。
- 处理事务的嵌套、挂起等场景，确保事务的传播行为符合预期
```java
protected TransactionInfo createTransactionIfNecessary(
			PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) {
    //获取事务状态
    TransactionStatus status = null;
    if (txAttr != null) {
        if (tm != null) {
            // 根据传播属性决定：是否创建新事务、是否参与现有事务、是否挂起现有事务
            status = tm.getTransaction(txAttr);
        }
    }
    return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
}
```

### 4.1.1、获取事务状态：`tm.getTransaction(txAttr)`
`tm.getTransaction(txAttr)`是核心逻辑，根据`txAttr`的传播属性决定：
  - 是否创建新事务
  - 是否参与现有事务
  - 是否挂起现有事务（如PROPAGATION_REQUIRES_NEW）
```java
public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable {
    //执行原始方法之前的操作，即获取connection，设置threadlocal，开启事务
    public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {
        //模板方法1
        Object transaction = doGetTransaction();
        // Cache debug flag to avoid repeated checks.
        boolean debugEnabled = logger.isDebugEnabled();
        if (definition == null) {
            // Use defaults if no transaction definition given.
            definition = new DefaultTransactionDefinition();
        }
        //模板方法2，判断是否已存在事务，有事务注解的方法调其他有事务注解方法时会走这
        if (isExistingTransaction(transaction)) {
            //有存在的事务时，根据事务传播行为区别处理
            //1.传播行为是PROPAGATION_NEVER，表示不使用当前事务，抛出异常
            //2.如果是PROPAGATION_NOT_SUPPORTED，表示不支持当前事务，而是始终以非事务方式执行，和最下面else逻辑一样
            //3.如果是PROPAGATION_REQUIRES_NEW，表示新建事务，和下面创建新事务逻辑一样
            //4.如果是PROPAGATION_NESTED，表示如果当前事务存在，则在嵌套事务中执行，否则和PROPAGATION_REQUIRED逻辑一样（和下面创建新事务逻辑一样）
            //5.如果注入validateExistingTransaction为true，比较definition的隔离等级，ReadOnly和TransactionSynchronizationManager中的对应配置比较，抛出异常
            //6.和最下面else逻辑一样
            return handleExistingTransaction(definition, transaction, debugEnabled);
        }
        //对事务注解属性值做一些判断
        //超时设置为<0会报错
        if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
            throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout());
        }

        //没有存在的事务时，根据事务传播行为区别处理
        //1.PROPAGATION_MANDATORY会使用当前事务，所以报错
        if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
            throw new IllegalTransactionStateException(
                    "No existing transaction found for transaction marked with propagation 'mandatory'");
        }
        //下面三种都会创建新事务,事务注解默认是PROPAGATION_REQUIRED
        else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
                definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
                definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
            SuspendedResourcesHolder suspendedResources = suspend(null);
            if (debugEnabled) {
                logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);
            }
            try {
                //拿注入的transactionSynchronization属性比较，默认不等于SYNCHRONIZATION_NEVER
                boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
                //创建新的
                DefaultTransactionStatus status = newTransactionStatus(
                        definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
                //模板方法，重点！！！        
                doBegin(transaction, definition);
                //设置threadlocal相关
                prepareSynchronization(status, definition);
                return status;
            }
            catch (RuntimeException | Error ex) {
                resume(null, suspendedResources);
                throw ex;
            }
        }
        else {
            // 实际没有开启事务，但是同步了一些配置到线程
            if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {
                logger.warn("Custom isolation level specified but no actual transaction initiated; " +
                        "isolation level will effectively be ignored: " + definition);
            }
            //默认是
            boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
            //先newTransactionStatus，再prepareSynchronization，没有doBegin方法
            return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);
        }
    }
}
```
所以父类在这一步封装的逻辑是：
- 先调子类`doGetTransaction`方法获取事务
- 子类`isExistingTransaction`方法判断当前是否有事务，有就对事务配置的隔离级别进行判断并返回事务（当事务注解方法里调用其他service事务注解方法时会进入该逻辑）
- 当前没有事务则默认会去调子类的`doBegin`方法


#### 4.1.1.1、获取当前事务对象`doGetTransaction`
根据具体事务管理器（如`DataSourceTransactionManager`）返回当前事务上下文对象（如数据库连接的事务状态）
```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager
        implements ResourceTransactionManager, InitializingBean {
    @Nullable
    private DataSource dataSource;
    private boolean enforceReadOnly = false;
    @Override
    protected Object doGetTransaction() {
        DataSourceTransactionObject txObject = new DataSourceTransactionObject();
        //是否允许嵌套事务
        txObject.setSavepointAllowed(isNestedTransactionAllowed());
        //先从resources.get()获取资源Map，再map.get(actualKey)
        //因为可能有多个数据源，而connection是和数据源对应的，所以threadlocal里存的是个map，k->数据源名称 v->connection
        ConnectionHolder conHolder =
                (ConnectionHolder) TransactionSynchronizationManager.getResource(this.dataSource);
        //第2个参数为newConnectionHolder，这里是直接从缓存拿的，没有创建，所以为false
        txObject.setConnectionHolder(conHolder, false);
        return txObject;
    }

    @Override
    //判断当前线程是否已有事务
    protected boolean isExistingTransaction(Object transaction) {
        DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
        //有事务，且生效中
        return (txObject.hasConnectionHolder() && txObject.getConnectionHolder().isTransactionActive());
    }
}
```

##### <code class="red">TransactionSynchronizationManager</code>
第六章节详细说明

#### 4.1.1.2、无现有事务，创建新事务`doBegin`
> spring事务的本质，是通过事务管理器（TransactionManager）操作数据库 connection的属性（如autoCommit、隔离级别等）来实现的。

```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager
        implements ResourceTransactionManager, InitializingBean {
    @Nullable
    private DataSource dataSource;
    private boolean enforceReadOnly = false;
    //终于要开启事务了
    @Override
    protected void doBegin(Object transaction, TransactionDefinition definition) {
        DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
        Connection con = null;
        try {
            //isSynchronizedWithTransaction表示连接是否加锁，类似synchronized关键字
            if (!txObject.hasConnectionHolder() ||
                    txObject.getConnectionHolder().isSynchronizedWithTransaction()) {
                //！！！获取数据库连接
                Connection newCon = obtainDataSource().getConnection();
                if (logger.isDebugEnabled()) {
                    logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction");
                }
                //设置的是新创建的连接，为true
                txObject.setConnectionHolder(new ConnectionHolder(newCon), true);
            }
            //给连接设置为加锁
            txObject.getConnectionHolder().setSynchronizedWithTransaction(true);
            con = txObject.getConnectionHolder().getConnection();

            //给Connection设置setReadOnly，setTransactionIsolation
            Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);
            txObject.setPreviousIsolationLevel(previousIsolationLevel);

            // 如果是自动提交要设置为手动提交
            if (con.getAutoCommit()) {
                txObject.setMustRestoreAutoCommit(true);
                if (logger.isDebugEnabled()) {
                    logger.debug("Switching JDBC Connection [" + con + "] to manual commit");
                }
                con.setAutoCommit(false);
            }
            //所以这里必是手动提交事务，也就是开启了事务
            //如果设置readonly，执行sql，SET TRANSACTION READ ONLY
            prepareTransactionalConnection(con, definition);
            //设置事务生效标记
            txObject.getConnectionHolder().setTransactionActive(true);

            int timeout = determineTimeout(definition);
            if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
                txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
            }

            //把connection设置到threadlocal中，上面的doGetTransaction方法就是从这取的
            if (txObject.isNewConnectionHolder()) {
                TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());
            }
        }
    }
}
```
主要执行逻辑：从`DataSource`获取`connection`并设置到事务对象中，设置为手动提交从而开启数据库事务，把事务对象设置到1中的`threadlocal`中
> 查看第六章节<code class="red">TransactionSynchronizationManager</code>

### 4.1.2、构建事务信息prepareTransactionInfo()
```java
return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
```
`TransactionInfo`对象：封装事务管理器（`tm`）、事务属性（`txAttr`）、方法标识（`joinpointIdentification`）和事务状态（`status`），用于后续事务提交或回滚操作

## 4.2、提交事务：commitTransactionAfterReturning(txInfo)
在spring事务管理中，**事务的提交时机是在目标方法成功执行后（即正常返回时）**。

通过事务管理器执行commit提交事务操作
```java
protected void commitTransactionAfterReturning(TransactionInfo txInfo) {
    if (txInfo != null && txInfo.hasTransaction()) {
        if (logger.isTraceEnabled()) {
            logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "]");
        }
        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
    }
}
```
核心就是事务管理器的`commit`方法！
```java
public final void commit(TransactionStatus status) throws TransactionException {
    //事务已完成
    if (status.isCompleted()) {
        throw new IllegalTransactionStateException(
                "Transaction is already completed - do not call commit or rollback more than once per transaction");
    }
    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
    //如果当前事务明确被设置为仅回滚（一般是在当前方法中抛出异常并手动处理），那么调用processRollback执行回滚。
    if (defStatus.isLocalRollbackOnly()) {
        if (defStatus.isDebug()) {
            logger.debug("Transactional code has requested rollback");
        }
        processRollback(defStatus);
        return;
    }
    //如果当前事务本设置为全局回滚
    if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {
        if (defStatus.isDebug()) {
            logger.debug("Global transaction is marked as rollback-only but transactional code requested commit");
        }
        processRollback(defStatus);
        if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {
            throw new UnexpectedRollbackException(
                    "Transaction rolled back because it has been marked as rollback-only");
        }
        return;
    }

    processCommit(defStatus);
}
```
最后才会调用`processCommit`执行真正的事务提交，这是核心方法。
```java
private void processCommit(DefaultTransactionStatus status) throws TransactionException {
  //判断是否具有保存点，内层PROPAGATION_NESTED事务会开启保存点。如果具有保存点，因为保存点内部的代码正常执行完毕，那么就释放保存点，但是并不会提交事务，而是需要等待外层事务方法去提交。
  if (status.hasSavepoint()) {
    status.releaseHeldSavepoint();
  }
  else if (status.isNewTransaction()) {
    doCommit(status);
  }
}
```
`doCommit`提交事务，如果是新开启的事务或者最外层事务，那么由于事物内部的代码全部成功执行，那么这里就提交该事物，该方法由具体的事务管理器子类来实现。
`DataSourceTransactionManager`的实现很简单，就是调用内部的连接的`Connection#commit`方法执行提交操作。
```java
@Override
protected void doCommit(DefaultTransactionStatus status) {
    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
    Connection con = txObject.getConnectionHolder().getConnection();
    try {
        con.commit();
    }
}
```


## 4.3、回滚事务：completeTransactionAfterThrowing(txInfo, ex)
通过事务管理器执行`rollback`提交事务操作
```java
protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) {
    if (txInfo != null && txInfo.hasTransaction()) {
        if (txInfo.transactionAttribute.rollbackOn(ex)) {
            try {
                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
            }
        }
    }
}
```
`rollback()`源码如下
```java
public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable {
  @Override
  public final void rollback(TransactionStatus status) throws TransactionException {
      if (status.isCompleted()) {
          throw new IllegalTransactionStateException(
                  "Transaction is already completed - do not call commit or rollback more than once per transaction");
      }
      DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
      processRollback(defStatus, false);
  }
  private void processRollback(DefaultTransactionStatus status, boolean unexpected) {
      try {
          boolean unexpectedRollback = unexpected;
          try {
              triggerBeforeCompletion(status);
              //有定义point就回退到指定point
              if (status.hasSavepoint()) {
                  //conHolder.getConnection().rollback((Savepoint) savepoint) status.rollbackToHeldSavepoint();
              } else if (status.isNewTransaction()) {
                  doRollback(status);
              }
          }
      }
  }
}
```
`DataSourceTransactionManager`的实现很简单，就是调用内部的连接的`Connection#rollback`方法执行回滚操作。
```java
@Override
protected void doRollback(DefaultTransactionStatus status) {
    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
    Connection con = txObject.getConnectionHolder().getConnection();
    try {
        con.rollback();
    }
}
```


# 五、关键对象与参数

## 5.1、TransactionAttribute
由`@Transactional`注解解析而来，保护事务属性
- **传播行为**（`propagation`）
- **隔离级别**（`isolation`）
- **超时时间**（`timeout`）
- **回滚规则**（`rollbackFor`, `noRollbackFor`）

## 5.2、TransactionStatus
封装事务状态：
- `isNewTransaction()`：是否是新创建的事务
- `setRollbackOnly()`：标记事务需要回滚
- `isCompleted()`：事务是否已经提交或回滚

## 5.3、TransactionInfo
存储事务相关信息，供后续提交会回滚使用
- **事务管理器**（tm）
- **事务属性**（txAttr）
- **事务状态**（status）
- **方法标识**（joinpointIdentification）

# 六、Connection的线程安全
第三章，我们回顾了JDBC的事务，了解了JDBC的Connection对象在多线程环境下使用时存在线程不安全的问题。现在来了解spring是如何解决的。

## 6.1、TransactionSynchronizationManager
`TransactionSynchronizationManager`是一个核心工具类，负责管理事务上下文的线程本地（ThreadLocal）资源，确保同一事务内的资源（如数据库连接）绑定到当前线程，并协调事务同步回调（如aftreCommit）
- 资源绑定：将事务资源（如`Connection`）绑定到当前线程
- 同步回调管理：注册事务同步器（`TransactionSynchronization`），在事务提交、回滚或挂起时触发回调。
- 事务传播支持：在嵌套事务或事务传播行为（如`PROPAGATION_REQUIRES_NEW`）中管理资源的挂起与恢复。
```java
public abstract class TransactionSynchronizationManager {
    //存储资源（如Connection）
    private static final ThreadLocal<Map<Object, Object>> resources =
            new NamedThreadLocal<Map<Object, Object>>("Transactional resources");
    //存储事务同步器（回调接口）
    private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =
            new NamedThreadLocal<Set<TransactionSynchronization>>("Transaction synchronizations");
    //当前事务的名称、隔离级别、只读状态
    private static final ThreadLocal<String> currentTransactionName =
            new NamedThreadLocal<String>("Current transaction name");
    private static final ThreadLocal<Boolean> currentTransactionReadOnly =
            new NamedThreadLocal<Boolean>("Current transaction read-only status");
    private static final ThreadLocal<Integer> currentTransactionIsolationLevel =
            new NamedThreadLocal<Integer>("Current transaction isolation level");
    private static final ThreadLocal<Boolean> actualTransactionActive =
            new NamedThreadLocal<Boolean>("Actual transaction active");
}
```

### 6.1.1、事务资源绑定
当spring开启事务时，`DataSourceTransactionManager`会通过`TransactionSynchronizationManager`将`Connection`绑定到当前线程。
```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager
        implements ResourceTransactionManager, InitializingBean {
  @Override
  protected void doBegin(Object transaction, TransactionDefinition definition) {
    Connection newCon = this.dataSource.getConnection();
    // 绑定Connection到当前线程
    if (txObject.isNewConnectionHolder()) {
      TransactionSynchronizationManager.bindResource(this.dataSource, txObject.getConnectionHolder());
    }
  }
}
```
绑定逻辑如下：
```java
public static void bindResource(Object key, Object value) throws IllegalStateException {
    Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
    Assert.notNull(value, "Value must not be null");
    //1. 获取当前线程的 resource map
    Map<Object, Object> map = resources.get();
    // set ThreadLocal Map if none found
    if (map == null) {
        map = new HashMap<Object, Object>();
        resources.set(map);
    }
    //2. 将资源存入map(key=dataSource)
    Object oldValue = map.put(actualKey, value);
    //3. 检查是否重复绑定
    if (oldValue != null) {
        throw new IllegalStateException("Already value [" + oldValue + "] for key [" +
                actualKey + "] bound to thread [" + Thread.currentThread().getName() + "]");
    }
    if (logger.isTraceEnabled()) {
        logger.trace("Bound value [" + value + "] for key [" + actualKey + "] to thread [" +
                Thread.currentThread().getName() + "]");
    }
}
```
- **resource**是一个`ThreadLocal<Map<Object, Object>>`，每个线程独立维护一个键值对集合。
- **Key**：唯一标识资源对象（如`DataSource`实例）
- **value**：资源对象（如`ConnectionHolder`，封装了数据库连接Connection）

### 6.1.2、获取资源
```java
public static Object getResource(Object key) {
    Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
    Object value = doGetResource(actualKey);
    if (value != null && logger.isTraceEnabled()) {
        logger.trace("Retrieved value [" + value + "] for key [" + actualKey + "] bound to thread [" +
                Thread.currentThread().getName() + "]");
    }
    return value;
}
private static Object doGetResource(Object actualKey) {
  Map<Object, Object> map = resources.get();
  if (map == null) {
    return null;
  }
  Object value = map.get(actualKey);
  // Transparently remove ResourceHolder that was marked as void...
  if (value instanceof ResourceHolder && ((ResourceHolder) value).isVoid()) {
    map.remove(actualKey);
    // Remove entire ThreadLocal if empty...
    if (map.isEmpty()) {
      resources.remove();
    }
    value = null;
  }
  return value;
}
```



参考文章：
[Spring Transactional源码阅读笔记（二）](https://zhuanlan.zhihu.com/p/41785457)
[spring源码深度解析](https://zhuanlan.zhihu.com/p/358657396)
