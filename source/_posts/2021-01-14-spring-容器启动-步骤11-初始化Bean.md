---
title: 《spring》容器启动 -step11- 初始化Bean
date: 2021-01-14
categories:
  - [spring, 容器]
tags:
  - [容器]
---

    这是spring系列的第八篇文章，主要介绍的是容器启动中的第11个步骤，创建bean的三大流程的初始化Bean。

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #6260ff;
}
</style>

# 一、Spring
`spring框架`是Java生态中最主流的轻量级开源应用框架，其核心目标是简化企业级应用开发，通过`IOC（控制反转）`和`AOP（面向切面编程）`两大核心机制实现解耦、模块化和可维护性。

<!-- more -->


# 二、doCreateBean
继续回顾一下Bean的创建流程：

首先需要了解是Spring它创建Bean的流程，大致调用栈绘图如下：
![Bean创建流程](2021-01-12-spring-容器启动-步骤11-实例化Bean/Bean创建流程.png)

```java
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {

    // BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器
    BeanWrapper instanceWrapper = null;
    // 单例模型，则从未完成的 FactoryBean 缓存中删除
    if (mbd.isSingleton()) {
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
  // 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化
    if (instanceWrapper == null) {
        //实例化
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    // 包装的实例对象
    final Object bean = instanceWrapper.getWrappedInstance();
    // 包装的实例对象的类型
    Class<?> beanType = instanceWrapper.getWrappedClass();
    if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
    }

  // 检测是否有后置处理
  // 如果有后置处理，则允许后置处理修改 BeanDefinition
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
              // applyMergedBeanDefinitionPostProcessors
              // 后置处理修改 BeanDefinition
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }
            mbd.postProcessed = true;
        }
    }

  // 解决单例模式的循环依赖
  // 单例模式 & 允许循环依赖&当前单例 bean 是否正在被创建
    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
            isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
      // 提前将创建的 bean 实例加入到ObjectFactory 中
      // 这里是为了后期避免循环依赖
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
    }

    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        //属性注入
        populateBean(beanName, mbd, instanceWrapper);
        //初始化
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
   //.循环依赖处理
    if (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, false);
        if (earlySingletonReference != null) {
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            }
            else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                for (String dependentBean : dependentBeans) {
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
            }
        }
    }
  // 注册 bean
    registerDisposableBeanIfNecessary(beanName, bean, mbd);

    return exposedObject;
}
```
大概流程如下：
- createBeanInstance() 实例化 bean
- populateBean() 属性填充
- 循环依赖的处理
- initializeBean() 初始化 bean



# 三、流程4：initializeBean() 初始化 bean  
Spring中的`initializeBean()`方法是`doCreateBean方法三部曲`的最后一步，完成`initializeBean()`则整个bean的创建过程才算完成.

```java
public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory
        implements AutowireCapableBeanFactory {
    protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
        // Aware接口处理器，调用BeanNameAware、BeanClassLoaderAware、beanFactoryAware
        invokeAwareMethods(beanName, bean);
        // 调用BeanPostProcessor的postProcessBeforeInitialization方法。
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
        // 调用初始化方法，先调用bean的InitializingBean接口方法，后调用bean的自定义初始化方法
        invokeInitMethods(beanName, wrappedBean, mbd);
        // 调用BeanPostProcessor的applyBeanPostProcessorsAfterInitialization方法。
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
        //返回包装后的Bean
        return wrappedBean;
    }
}
```

## 3.1、执行aware接口invokeAwareMethods
这个方法就是判断一下当前bean是否实现了`BeanNameAware，BeanClassLoaderAware，BeanFactoryAware`接口，如果实现了，就回调相应的方法。
```java
private void invokeAwareMethods(String beanName, Object bean) {
    //如果 bean 是 Aware 实例
    if (bean instanceof Aware) {
        //如果bean是BeanNameAware实例
        if (bean instanceof BeanNameAware) {
            //调用 bean 的setBeanName方法
            ((BeanNameAware) bean).setBeanName(beanName);
        }
        //如果bean是 BeanClassLoaderAware 实例
        if (bean instanceof BeanClassLoaderAware) {
            //获取此工厂的类加载器以加载Bean类(即使无法使用系统ClassLoader,也只能为null)
            ClassLoader bcl = getBeanClassLoader();
            if (bcl != null) {
                //调用 bean 的 setBeanClassLoader 方法
                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
            }
        }
        //如果bean是 BeanFactoryAware 实例
        if (bean instanceof BeanFactoryAware) {
            // //调用 bean 的 setBeanFactory 方法
            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
        }
    }
}
```



## 3.2、执行BeanPostProcessor的postProcessBeforeInitialization()方法
`postProcessBeforeInitialization()`方法会在执行`init方法`之前调用，遍历`beanPostProcessors`集合调用`postProcessBeforeInitialization()`方法。
```java
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
        throws BeansException {

    //初始化返回结果为existingBean
    Object result = existingBean;
    //遍历 该工厂创建的bean的BeanPostProcessors列表
    for (BeanPostProcessor processor : getBeanPostProcessors()) {
        // postProcessBeforeInitialization：在任何Bean初始化回调之前(如初始化Bean的afterPropertiesSet或自定义的init方法)
        // 将此BeanPostProcessor 应用到给定的新Bean实例。Bean已经填充了属性值。返回的Bean实例可能时原始Bean的包装器。
        // 默认实现按原样返回给定的 Bean
        Object current = processor.postProcessBeforeInitialization(result, beanName);
        // 如果 current为null
        if (current == null) {
            //直接返回result，中断其后续的BeanPostProcessor处理
            return result;
        }
        //让result引用processor的返回结果,使其经过所有BeanPostProcess对象的后置处理的层层包装
        result = current;
    }
    //返回经过所有BeanPostProcess对象的后置处理的层层包装后的result
    return result;
}
```

### 3.2.1、【实现】ApplicationContextAwareProcessor调用Aware接口方法
主要完成，判断当前bean是否实现`EnvironmentAware，EmbeddedValueResolverAware，ResourceLoaderAware，ApplicationEventPublisherAware，MessageSourceAware，ApplicationContextAware`接口，如果实现则对其方法进行调用。
```java
class ApplicationContextAwareProcessor implements BeanPostProcessor {
     public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
				bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
				bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)){
			return bean;
		}

		AccessControlContext acc = null;

		if (System.getSecurityManager() != null) {
			acc = this.applicationContext.getBeanFactory().getAccessControlContext();
		}

		if (acc != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				// 检测bean上是否实现了某个aware接口，有的话进行相关的调用
				invokeAwareInterfaces(bean);
				return null;
			}, acc);
		}
		else {
			invokeAwareInterfaces(bean);
		}

		return bean;
	}   
}
```

### 3.2.2、【实现】ConfigurationClassPostProcessor调用ImportAware接口方法
如果bean实现了`ImportAware`接口，就会设置bean的注解信息：
```java
public Object postProcessBeforeInitialization(Object bean, String beanName) {
    if (bean instanceof ImportAware) {
        ImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);
        AnnotationMetadata importingClass = ir.getImportingClassFor(ClassUtils.getUserClass(bean).getName());
        if (importingClass != null) {
            ((ImportAware) bean).setImportMetadata(importingClass);
        }
    }
    return bean;
}
```

## 3.3、执行初始化方法invokeInitMethods
如果bean实现了`InitializingBean`接口，则先执行`InitializingBean`接口的`afterPropertiesSet`方法。

然后执行`xml`或`注解`设置的`init-method`方法。
```java
protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)
			throws Throwable {
    // 省略部分代码...
	// 调用bean的afterPropertiesSet方法
	((InitializingBean) bean).afterPropertiesSet();
	// 在bean上调用指定的自定义init方法
	invokeCustomInitMethod(beanName, bean, mbd);
}

```

## 3.4、执行BeanPostProcessor的postProcessAfterInitialization()方法
遍历`beanPostProcessors`集合，执行`BeanPostProcessor`的后置处理器：
```java
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
        throws BeansException {

    //初始化结果对象为result，默认引用existingBean
    Object result = existingBean;
    //遍历该工厂创建的bean的BeanPostProcessors列表
    for (BeanPostProcessor processor : getBeanPostProcessors()) {
        //回调BeanPostProcessor#postProcessAfterInitialization来对现有的bean实例进行包装
        Object current = processor.postProcessAfterInitialization(result, beanName);
        //一般processor对不感兴趣的bean会回调直接返回result，使其能继续回调后续的BeanPostProcessor；
        // 但有些processor会返回null来中断其后续的BeanPostProcessor
        // 如果current为null
        if (current == null) {
            //直接返回result，中断其后续的BeanPostProcessor处理
            return result;
        }
        //让result引用processor的返回结果,使其经过所有BeanPostProcess对象的后置处理的层层包装
        result = current;
    }
    //返回经过所有BeanPostProcess对象的后置处理的层层包装后的result
    return result;
}
```

### 3.4.1、【实现】AbstractAutoProxyCreator生成aop代理对象
如果使用了aop代理，那么此处会生成代理对象，替换原生bean对象。
```java
public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
    if (bean != null) {
        // 根据给定bean的name和class构建出一个key
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (this.earlyProxyReferences.remove(cacheKey) != bean) {
            // 如果它需要被代理，则需要封装指定的bean
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
```
事务的实现，就是采用了这种方式。

### 3.4.2、【实现】ApplicationListenerDetector检测bean是否实现了ApplicationListener接口
如果bean是单例的并且实现了`ApplicationListener`接口，则加入到多播器中`applicationEventMulticaster`。
```java
public Object postProcessAfterInitialization(Object bean, String beanName) {
    if (bean instanceof ApplicationListener) {
        // 判断当前bean是否是单例，如果是的话，直接添加到容器的监听器集合中
        Boolean flag = this.singletonNames.get(beanName);
        if (Boolean.TRUE.equals(flag)) {
            // 添加到容器的监听器集合中
            this.applicationContext.addApplicationListener((ApplicationListener<?>) bean);
        }
        // 如果不是单例的，并且又是一个嵌套的bean，那么打印日志，提示内嵌的bean只有在单例的情况下才能作为事件监听器
    }
    return bean;
}
```

# 四、流程5：处理循环依赖
在初始化对象后，会执行如下代码，
```java
// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查
// 此段代码非常重要~~~~~但大多数人都忽略了它
if (earlySingletonExposure) {
    // 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据
    //注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~

    // 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句
    //  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);
    // 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了"偷天换日" 特别适合中间件的设计
    // 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**
    Object earlySingletonReference = getSingleton(beanName, false);
    if (earlySingletonReference != null) {
    
        // 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了
        // initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧
        if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
        } 

        // allowRawInjectionDespiteWrapping这个值默认是false
        // hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)
        else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
            // 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~
            String[] dependentBeans = getDependentBeans(beanName);
            Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
            
            // 一个个检查它所以Bean
            // removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面
            // 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true
            // 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖
            //（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）
            for (String dependentBean : dependentBeans) {
                if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                    actualDependentBeans.add(dependentBean);
                }
            }

            // 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） 
            // 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~
            if (!actualDependentBeans.isEmpty()) {
                throw new BeanCurrentlyInCreationException(beanName,
                        "Bean with name '" + beanName + "' has been injected into other beans [" +
                        StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                        "] in its raw version as part of a circular reference, but has eventually been " +
                        "wrapped. This means that said other beans do not use the final version of the " +
                        "bean. This is often the result of over-eager type matching - consider using " +
                        "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
            }
        }
    }
}

return exposedObject;
```

# 五、FactoryBean的处理
在对象创建完成后（初始化完成后），会判断对象是否是`FactoryBean`。
```
1. 创建 orderService
-> AbstractAutowireCapableBeanFactory.doCreateBean()
2. orderService属性注入
 -> AbstractAutowireCapableBeanFactory.populateBean()
  -> CommonAnnotationBeanPostProcessor.postProcessPropertyValues()
   -> InjectionMetadata.inject()
    -> CommonAnnotationBeanPostProcessor.getResourceToInject()
     -> CommonAnnotationBeanPostProcessor.getResource()
      -> CommonAnnotationBeanPostProcessor.autowireResource()
3. orderService属性注入，触发 orderMapper 的创建
       -> AbstractBeanFactory.getBean()
        |-> AbstractBeanFactory.doGetBean()
4. 第一步：调用getSingleton()去创建MapperFactoryBean对象
        |1 |-> DefaultSingletonBeanRegistry.getSingleton()
        |  | -> AbstractBeanFactory.getObject()
        |  |  -> AbstractAutowireCapableBeanFactory.createBean()
        |  |   -> AbstractAutowireCapableBeanFactory.doCreateBean()
        |  |    -> AbstractAutowireCapableBeanFactory.createBeanInstance()
        |  |     -> AbstractAutowireCapableBeanFactory.autowireConstructor()
        |  |      -> ConstructorResolver.autowireConstructor()
        |  |       -> SimpleInstantiationStrategy.instantiate()
        |  |        -> BeanUtils.instantiateClass()
					 //调用MapperFactoryBean的构造函数，创建MapperFactoryBean对象
        |  |         -> Constructor.newInstance()
5. 第二步：调用getObjectForBeanInstance去创建MapperProxy代理
        |2 |-> AbstractBeanFactory.getObjectForBeanInstance()
        |  | -> FactoryBeanRegistrySupport.getObjectFromFactoryBean()
        |  |  -> FactoryBeanRegistrySupport.doGetObjectFromFactoryBean()
        |  |   -> MapperFactoryBean.getObject()：重点！！！调用了工厂bean的getObject()方法
        |  |    -> SqlSessionTemplate.getMapper()
        |  |     -> Configuration.getMapper()
        |  |      -> MapperRegistry.getMapper()
        |  |       -> MapperProxyFactory.newInstance()
        |  |        -> Proxy.newProxyInstance()
```
更全内容可以查看mybatis启动过程文章。

参考文章：
[如何利用"三级缓存"巧妙解决Bean的循环依赖问题的](https://cloud.tencent.com/developer/article/1497692)
https://github.com/xuchengsheng/spring-reading/blob/master/spring-core/spring-core-resolveDependency/README.md