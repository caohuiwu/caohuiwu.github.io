---
title: 《性能优化系列》多线程优化
date: 2024-03-05 10:00:00
categories:
  - [多线程, 并发]
  - [性能优化]
  - [美团]
tags:
- 美团
---

    这是性能优化系列的第三篇文章，主要介绍的是多线程相关优化。

### 一、背景
在美团，主要是负责对资产管理系统的重构工作，现在对系统的作用及功能做介绍。
- 系统定位：对美团的充电宝、优选物资、优选低值物资等资产的完整生命周期进行管理。
- 主要功能：资产新增、资产重建、资产调整、资产折旧、资产处置等。

对资产的操作，例如资产新增，一般是通过excel导入系统，导入的数据量最多30W行，如此大的数据量，处理时长达1小时，系统可以说是一种不可用的状态。当时从产品设计、系统架构、数据模型，对系统进行了重大的调整。本文主要对多线程方面进行讲解。

<!-- more -->

### 二、当前业务说明
系统处理的时序图如下：

{% plantuml %}
actor 财务人员
participant 资产管理系统
database mysql

财务人员->资产管理系统 : 资产新增，导入excel
activate 资产管理系统
资产管理系统->资产管理系统: 开启大事务
activate 资产管理系统
资产管理系统->资产管理系统: 一条一条进行串行数据校验（格式校验）
资产管理系统->mysql: 存在性校验，查询asset资产表
资产管理系统->mysql: 保存数据
mysql-->资产管理系统: 返回
deactivate 资产管理系统
资产管理系统-->财务人员: 1小时后返回结果

{% endplantuml %}

伪代码如下：
```java
List<Object> assetList = new ArrayList<>();
//开启事务：@Transaction
for (Object asset : assetList) {
    //对资产进行校验
    check(asset);
    service.addAsset(asset);
}
```

### 三、优化
优化思路：
- 大事务：解决大事务问题。
- 并发：使用多线程提升性能。

#### ⭐️ 使用CompletableFeature
从业务的执行流程上看，可以把资产的操作分成2部分：
- 第一部分：资产数据的校验。
- 第二部分：资产数据的保存。

2个操作是先后顺序，非常适合使用CompletableFeature。
- 1、将资产进行分段，例如分成3段，每一段用多线程去并发处理（同时分割成3个小事务）。
- 2、使用CompletableFuture.supplyAsync()，处理第一部分，生成对应的实体类。
- 3、然后使用CompletableFuture.thenApplyAsync()处理第一部分返回的数据，进行数据的插入。

伪代码如下：
```java
//1. 首先将assetList分组
List<Integer> originalList = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<List<Integer>> copyPartition = Lists.partition(originalList, 3);
List<CompletableFuture<Object>> futureList = copyPartition.stream().map(subList ->
        //任务传递给supplyAsync()方法，该任务将在ForkJoinPool.commonPool()中异步完成运行
        //最后，supplyAsync()将返回新的CompletableFuture，其值是通过调用给定的Supplier所获得的值。
        CompletableFuture.supplyAsync(() -> {
                    log.info("处理第{}段数据开始", n);
                    return checkImportAndBuildEvent(baseMessageMap, subList, totalCheckedMap, mis);
            }, importForkJoinPool)
            //thenApplyAsync()方法，从supplyAsync()获得的参数传递来执行给定的函数
            .thenApplyAsync(eventSaveReqs -> {
                    try {
                        EventStrategyFactory.getStrategy(EventLargeCategoryEnum.IMPAIRMENT_ADD.getCode()).triggerEvent(eventSaveReqs);
                        totalCheckedMap.get(BaseConstants.SUC_LIST).addAll(subList);
                    } catch (Exception e) {
                        log.error("资产新建失败", e);
                        subList.forEach(importDto -> {
                            importDto.setFailReason("资产新建入库失败");
                        });
                        totalCheckedMap.get(BaseConstants.FAIL_LIST).addAll(subList);
                    }
                    log.info("处理第{}段数据开始", n);
                    return null;
                },
                queryForkJoinPool
            )
).collect(toList());
futureList.stream().map(CompletableFuture::join).collect(Collectors.toList());
```

数据校验和保存，使用了2个线程池，达到业务隔离的作用：
- importForkJoinPool：处理数据校验。
- queryForkJoinPool：处理数据的存储。

### 四、优化结果
30W数据excel导入，由1小时优化到了2分钟，优化效果大大的提高了系统可用性。
