---
title: 《稳定性》订单拉单
date: 2024-06-09 10:00:00
categories:
  - [线程池]
  - [稳定性, 高可用]
  - [阿里]
tags:
- 阿里
---

    这是稳定性系列的第三篇文章，主要介绍的是交易系统高可用建设和线程池隔离的稳定性建设。

### 一、背景
订单拉单通常是指从外部系统（如电商平台、支付系统等）获取订单数据并导入到自己的系统中进行处理的过程。  
订单拉单的常见方案：
- 定时任务：设置定时任务，按照一定的时间间隔（如每分钟、每小时等）主动从外部系统查询并拉取新的订单数据。这种方式适用于外部系统不提供主动推送功能或者对实时性要求不高的情况。
- 数据库同步：如果外部系统和你的系统可以直接访问同一个数据库，可以通过数据库的同步机制（如触发器、存储过程等）将订单数据同步到你的系统中。这种方式实时性高，但需要确保数据库的安全性和稳定性。

<!-- more -->
> 交易系统的拉单，采用定时任务方案，作为交易系统高可用建设中的一部分，当消息队列遇到各种故障和异常情况时，能够通过拉单任务创建本地订单，保障持续提供服务的能力。  

执行时序图：
{% plantuml %}
participant 集团交易
database metaq
participant schedulerx
participant 本地交易
database mysql

集团交易->metaq: 订单创建消息
metaq->本地交易: 订阅
本地交易->本地交易: 创建订单、创建拉单任务
本地交易->mysql:存储数据
schedulerx->本地交易: 执行定时任务
本地交易->本地交易:执行拉单任务
{% endplantuml %}

为什么要进行拉单优化呢？
- 业务逻辑收口，逻辑统一。
- 线程池隔离：未隔离，和其他业务耦合。
- 定时任务会有2小时的停顿问题。


### 二、重构前准备
- 明确目标：
  - 业务 & 线程池的隔离，并且解决定时任务停顿问题。
- 评估现状：
  - 分析拉单任务的创建场景，内部创建及对外暴露的接口。
  - 线程池的使用情况。


### 三、线程池隔离的稳定性建设
#### 1 评估现状：
任务创建量、任务执行量、线程池数量：
- 任务创建量：2000W+/天。
- 任务执行量：1000/s.
- 任务执行耗时：40ms
- 共享线程池数量：50。
- 任务执行流程如下：分成3级任务。
```java
@Component
public class PullOrderJobProcessor extends MapJobProcessor {

    @Autowired
    private XXXService xxxService;

    private final int PAGE_SIZE = 500;

    @Override
    public ProcessResult process(JobContext context) throws Exception {
        String taskName = context.getTaskName();
        Object task = context.getTask();
        if (isRootTask(context)) {
            //一级任务：分库分表
            List<String> tableList = getTableList(dbName);
            return map(dbList, "DbTask");
        } else if (taskName.equals("TableTask")) {
            //二级任务：分页查询数据
            String tableName = (String)task;
            //分页查询
            List<PageTask> tasks = pageQuery(tableName, PAGE_SIZE);
            //任务分发
            return map(tasks, "task");
        } else if (taskName.equals("task")) {
            //三级任务：具体的任务执行
            PageTask pageTask = (PageTask)task;
            //根据任务ID查询任务
            Task task = queryRecord(tableName, pageTask.getTaskId());
            //TODO handle records
            return new ProcessResult(true);
        }

        return new ProcessResult(false);
    }

}
```
schedulerx任务平台，会将任务分发到应用的worker服务器（不区分中心、单元），中心和单元的 机器数量：
- 中心：400台
  - CPU：16核
- 单元：400台

#### 3 线程池监控
[先做线程池监控](http://caohuiwu.github.io/2024/06/09/2024-06-09-%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/)

#### 4 线程池容量规划
任务需要1s内执行完成，计算线程数量，公式如下：
> - 单机理论线程数量=(qps/(总时间/平均耗时))
> - 1000/(1000/40)=40个线程

因为线程池是使用共享的线程池，不太容易得出线程池的状态数据。先从理论上分析，1000的QPS，会被平均分摊到800台机器上，那每台实际执行的量理论上是1.25个(1000/800) 。

##### 实际解决方案
通过灰度，将任务流量放入独立线程池，然后通过线程池监控查看线程池的状态，再做相应调整。

##### 更优方案
可以动态的调整线程池的数据。

参考文章：   
[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)


