---
title: 《netty》启动过程
date: 2019-06-20
categories: netty
---

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>



# 一、服务端启动过程

<!--more-->

```java
public static void main(String[] args){
    try {
        //主线程池，用于接收客户端连接
        NioEventLoopGroup mainGroup = new NioEventLoopGroup(1);
        //工作线程池，用于分发读写操作
        NioEventLoopGroup workGroup = new NioEventLoopGroup(5);

        ServerBootstrap serverBootstrap = new ServerBootstrap();
        //此处只是设置了一系列的启动器参数
        serverBootstrap
            //将两个线程池设置到启动器内
            .group(mainGroup, workGroup)
            //设置channel类型
            .channel(NioServerSocketChannel.class)
            //设置channel，只监听TCPNODELAY事件
            .option(ChannelOption.TCP_NODELAY, false)
            //设置处理器（若处理器写多个，实际只有一个有效，以最后一个为准）
            .handler(new LoggingHandler())
            //设置子处理器（若处理器写多个，实际只有一个有效，以最后一个为准）
            .childHandler(new ChannelInitializer<NioSocketChannel>() {
                @Override
                protected void initChannel(NioSocketChannel socketChannel) throws Exception {
                    logger.info("新客户端连接进来了-----{}", socketChannel.remoteAddress().toString());
                    ChannelPipeline pipeline = socketChannel.pipeline();
                    pipeline.addLast(new MyHandler());
                    pipeline.addLast(new LoggingHandler());
                }
            });
        //bind操作，此处才实际绑定端口并创建channel
        ChannelFuture future = serverBootstrap.bind(1234);
        future.channel().closeFuture().sync();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
服务端的启动，主要在`serverBootstrap.bind`方法，实现在父类`AbstractBootStrap`的`doBind()`方法内，主要有2个步骤：
- `initAndRegister()`：创建和初始化channel
- `doBind0()`：绑定端口
```java
public abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> implements Cloneable {
    private ChannelFuture doBind(final SocketAddress localAddress) {
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
            return regFuture;
        }
        if (regFuture.isDone()) {
            // At this point we know that the registration was complete and successful.
            ChannelPromise promise = channel.newPromise();
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            ....
        }
    }
}
```

## 1.1、分析`initAddRegister`
主要有3个步骤：
- 创建`channel`：通过`channelFactory.newChannel()`工厂创建（反射的方式）。
- 初始化`channel`：通过`init(channel)`方法
- channel的注册：`config().group().register(channel)`
```java
final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        channel = channelFactory.newChannel();
        init(channel);
    } catch (Throwable t) {
    }

    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    return regFuture;
}
```

步骤二：服务端channel初始化如下：
- 主要逻辑是设置Channel参数、属性，并将我们在引导代码中所配置的Handler添加进去
```java
public class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerChannel> {
    @Override
    void init(Channel channel) {
        setChannelOptions(channel, newOptionsArray(), logger);
        setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));

        ChannelPipeline p = channel.pipeline();

        final EventLoopGroup currentChildGroup = childGroup;
        final ChannelHandler currentChildHandler = childHandler;
        final Entry<ChannelOption<?>, Object>[] currentChildOptions;
        synchronized (childOptions) {
            currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);
        }
        final Entry<AttributeKey<?>, Object>[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);

        p.addLast(new ChannelInitializer<Channel>() {
            @Override
            public void initChannel(final Channel ch) {
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();
                if (handler != null) {
                    pipeline.addLast(handler);
                }

                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
    }
}
```

步骤3：channel的注册`config().group().register(channel)`
- `config.group()`的返回是我们在引导代码中所设置的`bossGroup`
- `register(channel)`：向`Selector`注册`Channel`


## 1.2、doBind0()绑定端口号
执行逻辑如下
```java
private static void doBind0(
        final ChannelFuture regFuture, final Channel channel,
        final SocketAddress localAddress, final ChannelPromise promise) {
    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up
    // the pipeline in its channelRegistered() implementation.
    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (regFuture.isSuccess()) {
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            } else {
                promise.setFailure(regFuture.cause());
            }
        }
    });
}
```



# 二、客户端启动过程
```java
public static void main(String[] args) {
    try {
        NioEventLoopGroup eventLoopGroup = new NioEventLoopGroup(10);
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .option(ChannelOption.TCP_NODELAY, false)
            .handler(new ChannelInitializer<NioSocketChannel>() {
                @Override
                protected void initChannel(NioSocketChannel socketChannel) throws Exception {
                    ChannelPipeline pipeline = socketChannel.pipeline();
                    System.out.println("aaaa");
                    pipeline.addLast(new LoggingHandler());
                }
            });
        ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 1234).sync();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
客户端的启动，主要在`bootstrap.connect`方法内，最终执行`doResolveAndConnect`
```java
public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {
    private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();

        if (regFuture.isDone()) {
            if (!regFuture.isSuccess()) {
                return regFuture;
            }
            return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
        } else {
            .....
        }
    }
}
```

## 1.1、分析`initAddRegister`
跟服务端是一样的逻辑。

主要有3个步骤：
- 创建`channel`：通过`channelFactory.newChannel()`工厂创建（反射的方式）。
- 初始化`channel`：通过`init(channel)`方法
- channel的注册：`config().group().register(channel)`

## 1.2、分析`doResolveAndConnect0`
```java
private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
                                               final SocketAddress localAddress, final ChannelPromise promise) {
    try {
        final EventLoop eventLoop = channel.eventLoop();
        AddressResolver<SocketAddress> resolver;
        try {
            resolver = this.resolver.getResolver(eventLoop);
        } catch (Throwable cause) {
            channel.close();
            return promise.setFailure(cause);
        }

        if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {
            // Resolver has no idea about what to do with the specified remote address or it's resolved already.
            doConnect(remoteAddress, localAddress, promise);
            return promise;
        }

        final Future<SocketAddress> resolveFuture = resolver.resolve(remoteAddress);

        if (resolveFuture.isDone()) {
            final Throwable resolveFailureCause = resolveFuture.cause();

            if (resolveFailureCause != null) {
                // Failed to resolve immediately
                channel.close();
                promise.setFailure(resolveFailureCause);
            } else {
                // Succeeded to resolve immediately; cached? (or did a blocking lookup)
                doConnect(resolveFuture.getNow(), localAddress, promise);
            }
            return promise;
        }

        // Wait until the name resolution is finished.
        resolveFuture.addListener(new FutureListener<SocketAddress>() {
            @Override
            public void operationComplete(Future<SocketAddress> future) throws Exception {
                if (future.cause() != null) {
                    channel.close();
                    promise.setFailure(future.cause());
                } else {
                    doConnect(future.getNow(), localAddress, promise);
                }
            }
        });
    } catch (Throwable cause) {
        promise.tryFailure(cause);
    }
    return promise;
}
```
1. 获取EventLoop和地址解析器
   - 获取通道管理的EventLoop
   - 创建或获取一个AddressResolver，用于解析远程地址
2. 地址解析
   - 判断地址解析器是否支持该远程地址，如果支持，则调用`resolver.resolve`进行异步解析
3. 连接操作
   - 调用`doConnect`方法执行实际的连接操作。
   - `doConnect`方法会向`NioEventLoop`提交一个任务，该任务最终会调用`javaChannel().connect(remoteAddress)`发起系统级的连接请求。
4. 处理结果

