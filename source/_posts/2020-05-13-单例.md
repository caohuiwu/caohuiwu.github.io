---
title: 单例
date: 2020-05-13 19:50:03
tags:
---
#一、什么是单例
单例，就是保证一个类的实例对象只存在一个
#二、创建对象方法
new，反射，克隆，反序列化

#三、破坏单例
什么是破坏单例？就是让一个类存在多个实例对象   
**如何破坏：**
1. 单例的首要条件是构造函数私有化。那么new方式行不通。
2. 克隆，需要实现cloneable接口。要达到单例效果，就不能实现这个类。
3. 序列化：需要实现Serializable接口
```
public class Test {  
    public static void main(String[] args) throws Exception {  
        //序列化  
        Singleton instance1 = Singleton.getInstance();  
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("tempFile"));  
        objectOutputStream.writeObject(instance1);  
        //反序列化  
        File file = new File("tempFile");  
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));  
        Singleton instance2 = (Singleton) objectInputStream.readObject();  
        System.out.println(instance1 == instance2); //false，代表不是同一个对象
    }  
}
```
<!--more-->  

* 总结：通过反射，可以破坏单例。【底层实现原理还是使用反射】
* 防止序列化破坏单例：在单例类中实现readResolve方法
```
//在单例类中实现readResolve方法
public class Singleton implements Serializable {  
    private Singleton() {  
    }  
    private static class SingletonInstance {  
        private static final Singleton INSTANCE = new Singleton();  
   }   
    public static Singleton getInstance() {  
        return SingletonInstance.INSTANCE;  
   }  
    private Object readResolve() {  
        return SingletonInstance.INSTANCE;  
   }  
}
```
4. 反射
```
public class Test {  
    public static void main(String[] args) throws Exception {  
      Singleton instance1 = Singleton.getInstance();  
      //通过反射创建对象  
      Class<Singleton> singletonClass = Singleton.class;  
      Constructor<Singleton> constructor = singletonClass.getDeclaredConstructor(); 
      //暴力破解私有构造器------开启后才能反射创建对象
      constructor.setAccessible(true);  
      Singleton instance2 = constructor.newInstance();   
     System.out.println(instance1 == instance2);  //返回false
  }  
}
```
* 总结：反射可以破坏单例
* 防止反射破坏序列化：修改构造器，通过构造器判断（饥汉模式无法实现）
```
public class Singleton {
    private static volatile Singleton instance ;
    private Singleton(){
        //构造器判断
        if(instance != null){
            throw new RuntimeException("不允许反射调用构造器");
        }
    }
    public static Singleton getInstance(){
    }
}
```

总结：要想实现不被破坏的单例，需要通过构造函数判断+实现readResolve方法。
#四、最佳方式
枚举
```
public enum EnumSingleton {
    INSTANCE; 
    public EnumSingleton getInstance(){ 
         return INSTANCE;
    }
}
```
避免反射破坏单例：
使用反射会抛出异常
```
java.lang.NoSuchMethodException: com.jvm.SingleEnum.<init>()
	at java.lang.Class.getConstructor0(Class.java:3082)
	at java.lang.Class.getDeclaredConstructor(Class.java:2178)
	at com.jvm.SingleEnumTest.main(SingleEnumTest.java:16)
```
原因
```
protected Enum(String name, int ordinal) {
    this.name = name;
    this.ordinal = ordinal;
}
```
枚举类的构造函数有参，无法通过子类的构造函数进行


并且Constructor.newInstance进行了枚举判断，如果是枚举则抛出异常。

* 避免反序列化破坏单例：
    * 每个枚举对象都有一个唯一的name属性。序列化只是将name属性序列化，在反序列化的时候，通过创建一个Map(key,value)，搭建起name和与之对应的对象之间的联系，然后通过索引key来获得枚举对象。

# 五、懒汉饥汉

```java
public class safeLazyInitialization {
    private static Instance instance;
    public synchronized static Instance getInstance(){
        if(instance ==null)
            instance = new Instance();       
        return instance;
    }
}
```
方法上添加synchronized方法，会导致性能较差，可以实现单例。

优化一
```java
public class DoubleCheckedLocking {                     //1
    private static Instance instance;                   //2
    public  static Instance getInstance(){              //3
        if(instance ==null) {                           //4:第一次检查
            synchronized (DoubleCheckedLocking.class) { //5：加锁
                if (instance == null)                   //6：第二次检查
                    instance = new Instance();          //7：问题的根源处在这里
            }                                           //8
        }                                               //9
        return instance;                                //10
    }                                                   //11
}
```
不对方法进行加锁，对Class对象进行加锁。但是也会出现问题。
* 指令代码
```
memory=allocate();        //1:分配对象的内存空间
ctorInstance(memory);     //2:初始化对象
instance = memory;          //3:设置instance指向刚分配的内存地址
```
* 指令重排序后
```
memory=allocate();        //1:分配对象的内存空间
instance = memory;          //3:设置instance指向刚分配的内存地址
ctorInstance(memory);     //2:初始化对象
```
* 问题根源
    * 线程1执行到第7行时，因为指令重排序，instance!=null，但是对象未进行初始化，对象信息都是初始值。
    * 线程2此时执行第4行，instance!=null，此时返回instance，因为未初始化，属性值将是初始值有问题。
    
优化二
```java
public class DoubleCheckedLocking {                     //1
  private static volatile Instance instance;                   //2
  public  static Instance getInstance(){              //3
      if(instance ==null) {                           //4:第一次检查
          synchronized (DoubleCheckedLocking.class) { //5：加锁
              if (instance == null)                   //6：第二次检查
                  instance = new Instance();          //7：问题的根源处在这里
          }                                           //8
      }                                               //9
      return instance;                                //10
  }                                                   //11
}
```  
volatile防止指令重排序。