---
title: 强弱软虚
date: 2020-04-13 16:46:31
tags: jvm
categories:
  - [java, jvm]
---

# 一、弱引用
```java
public class WeakReference<T> extends Reference<T> {
    public WeakReference(T referent) {
        super(referent);
    }
    public WeakReference(T referent, ReferenceQueue<? super T> q) {
        super(referent, q);
    }
}
```
* WeakReference(T referent)：referent对象，被弱引用对象指向，会在下一次GC时将referent对象回收，此时WeakReference.get()会返回null。
* WeakReference(T referent, ReferenceQueue<? super T> q)：当referent对象回收后，会将指向referent的弱引用对象放入队列中。

<!--more-->

使用：
定义普通类
```java
public class Apple {
    private String name;
}

```

定义弱引用类
```java
public class SaladReference extends WeakReference<Apple> {
    public Salad(Apple apple) {
        super(apple);
    }
}

```
* SaladReference弱引用对象，将指向Apple对象。

使用
```java
public class Client {
    public static void main(String[] args) {
        Salad salad = new Salad(new Apple("红富士"));
        //通过WeakReference的get()方法获取Apple
        System.out.println("Apple:" + salad.get());
        System.gc();
        try {
            //休眠一下，在运行的时候加上虚拟机参数-XX:+PrintGCDetails，输出gc信息，确定gc发生了。
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //如果为空，代表被回收了
        if (salad.get() == null) {
            System.out.println("clear Apple。");
        }
    }
}
```
* 输出结果：
```
Apple:Apple{name='红富士'}, hashCode:1846274136
[GC (System.gc()) [PSYoungGen: 3328K->496K(38400K)] 3328K->504K(125952K), 0.0035102 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
[Full GC (System.gc()) [PSYoungGen: 496K->0K(38400K)] [ParOldGen: 8K->359K(87552K)] 504K->359K(125952K), [Metaspace: 2877K->2877K(1056768K)], 0.0067965 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Apple： 红富士 finalize。
clear Apple。
```



# 二、强引用
如果一个对象有强引用，那垃圾回收一定不会回收。
```
Object o=new Object();   //  强引用
```
当内存空间不足，jvm宁愿抛出OOM错误，也不会回收

# 三、软引用
被软引用对象引用的实例对象，将在JVM内存不足时进行回收，可用于实现内存敏感的高速缓冲。
```
String str=new String("abc");                                     // 强引用
SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用

```
软引用和弱引用直接的区别，软引用只有当内存不足时才会去回收；而弱引用会在GC时回收

# 四、虚引用
顾名思义，形同虚设。如果一个对象仅仅被虚引用对象引用，那该对象随时可以被回收。
虚引用主要用来跟踪对象被垃圾回收的整个过程活动，虚引用必须和引用队列（ReferenceQueue）联合使用，
但是它被回收之前，会被放入ReferenceQueue中。注意哦，其它引用是被JVM回收后才被传入ReferenceQueue中的

















