---
title: 《nginx》启动流程
date: 2021-05-20
categories:
  - [nginx]
---

    这是nginx系列的第2篇文章，主要介绍的是nginx的启动流程。

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>

# 一、Nginx是什么？
`Nginx`是一个高性能的http和反向代理服务器，其特点是占用内存小，并发能力强

<!--more-->

# 二、Nginx启动流程
`nginx`的启动流程主要是从`nginx.c`文件的`main()`方法开始的，在这个过程中，`nginx`会完成诸如解析命令行参数、初始化模块索引、解析配置文件、初始化模块、启动`master`，`worke`r和`cache`相关进程等操作。

## 2.1、启动命令
用户通过命令行启动Nginx，例如：
```bash
nginx -c /path/to/nginx.conf
```

## 2.2、`nginx.c`文件的`main()`方法
```c++
int ngx_cdecl
main(int argc, char *const *argv)
{
    ngx_int_t         i;
    ngx_log_t        *log;
    ngx_cycle_t      *cycle, init_cycle;
    ngx_core_conf_t  *ccf;

    // 1. 初始化程序错误状态码
    ngx_debug_init();

    // 2. 初始化内存池、日志、时间等基础组件
    if (ngx_strerror_init() != NGX_OK) {
        return 1;
    }

    // 3. 解析命令行参数
    if (ngx_get_options(argc, argv) != NGX_OK) {
        return 1;
    }

    // 4. 初始化操作系统相关功能（如信号屏蔽、线程局部存储）
    ngx_os_init(log);

    // 5. 初始化 SSL（如果启用）
    ngx_ssl_init(log);

    // 6. 初始化核心模块的配置结构体
    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
    init_cycle.log = log;
    ngx_cycle = &init_cycle;

    // 7. 创建初始配置周期（ngx_cycle_t 是全局核心数据结构）
    cycle = ngx_init_cycle(&init_cycle);
    if (cycle == NULL) {
        if (ngx_test_config) {
            ngx_log_stderr(0, "configuration file test failed");
        }
        return 1;
    }

    // 8. 启动主进程（Master）或单进程模式
    if (ngx_process == NGX_PROCESS_SINGLE) {
        ngx_single_process_cycle(cycle);
    } else {
        ngx_master_process_cycle(cycle);
    }

    return 0;
}
```
简化后流程图如下：
```text
main()
├─ ngx_os_init()          // 操作系统初始化
├─ ngx_ssl_init()         // SSL 初始化
├─ ngx_init_cycle()       // 配置解析与周期初始化
│  ├─ ngx_conf_parse()    // 解析 nginx.conf
│  ├─ init_module()       // 调用模块的 init_module 回调
│  └─ nginx_open_listening_sockets() //监听端口绑定
└─ ngx_master_process_cycle()    //多进程模式
   ├─ ngx_start_worker_processes()   // 创建 & 启动 Worker 进程
   │  ├─ ngx_spawn_process()     // 循环执行该方法
   │  │  ├─ fork()               // 调用fork()创建 Worker 进程
   │  │  └─ proc()               // 子进程执行 ngx_worker_process_cycle()方法，Worker进程的主循环函数
   │  └─ ngx_pass_open_channel() // 主子进程通信
   ├─ while(1)            // 主进程信号循环（处理reload, stop等信号）
   └─ Worker 事件循环 (epoll/kqueue)
```

### 2.2.1、ngx_init_cycle()
是`Nginx`配置初始化和资源管理的核心函数，负责创建新的配置周期（cycle），解析配置文件，合并模块配置，并初始化关键资源（如监听套接字、共享内存）。以下是其核心逻辑：
```c++
ngx_cycle_t *
ngx_init_cycle(ngx_cycle_t *old_cycle)
{
    ngx_pool_t     *pool;
    ngx_cycle_t    *cycle;
    ngx_conf_t      conf;
    // 1. 创建新 Cycle 和内存池
    pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, old_cycle->log);
    cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));
    cycle->pool = pool;
    cycle->log = old_cycle->log;

    // 2. 继承旧 Cycle 的配置文件路径
    cycle->conf_file = old_cycle->conf_file;

    // 3. 初始化模块配置数组
    if (ngx_cycle_modules(cycle) != NGX_OK) {
        goto failed;
    }

    // 4. 解析配置文件
    ngx_memzero(&conf, sizeof(ngx_conf_t));
    conf.ctx = cycle->conf_ctx;  // 配置上下文数组（各模块的配置指针）
    conf.cycle = cycle;
    conf.pool = pool;

    if (ngx_conf_parse(&conf, &cycle->conf_file) != NGX_OK) {
        goto failed;
    }

    // 5. 调用模块的 init_module 回调
    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->init_module) {
            if (cycle->modules[i]->init_module(cycle) != NGX_OK) {
                goto failed;
            }
        }
    }

    // 6. 打开监听套接字
    if (ngx_open_listening_sockets(cycle) != NGX_OK) {
        goto failed;
    }

    // 7. 热重载时关闭旧端口
    if (old_cycle->listening.nelts) {
        ngx_close_listening_sockets(old_cycle);
    }

    return cycle;

failed:
    ngx_destroy_pool(pool);
    return NULL;
}
```

#### 2.2.1.1、绑定端口
绑定端口的核心代码位于`ngx_open_listening_sockets()`函数，位于`src/core/ngx_connection.c`:
```c
// 简化后的逻辑
ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle) {
    for (port in all_listen_ports) {
        // 创建套接字
        fd = socket(addr->sockaddr->sa_family, SOCK_STREAM, 0);

        // 设置 SO_REUSEADDR
        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int));

        // 绑定 IP:PORT
        bind(fd, addr->sockaddr, addr->socklen);

        // 开始监听
        listen(fd, backlog);

        // 将套接字存入 cycle->listening 数组
        cycle->listening.push(fd);
    }
    return NGX_OK;
}
```

### 2.2.2、master进程流程伪代码如下
```c++
void ngx_master_process_cycle(ngx_cycle_t *cycle){
	// 1.初始化信号位
    ngx_init_singal_flag();
    // 2.加载配置参数
    ngx_load_conf();
    // 3.fork创建worker进程
    ngx_start_worker_processes();
    // 4.启动缓存管理工作进程
    ngx_start_cache_manager_processes();
    //进入信号处理循环
    while(1){
        switch(singal){
            case delay:
                  ngx_delay_singal_handler();
                  break;
            case quit:
                  ngx_quit_singal_handler();
                  break;
            case terminate:
                  ngx_terminate_singal_handler();
                  break;
            case reconfigure:
                  ngx_reconfigure_singal_handler();
                  break;
            .....    
        }
    }
}
```

### 2.2.3、worker进程流程伪代码如下
```c++
static void ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)
{
    // 1.初始化worker进程
    ngx_worker_process_init(cycle, worker);
    while(1){	
		 // 1.处理退出信息
        if (ngx_exiting) {
            if (ngx_event_no_timers_left() == NGX_OK) {
                 ngx_worker_process_exit(cycle);
            }
        }
        // 2.事件处理 将在下一章节介绍
        ngx_process_events_and_timers(cycle);
		 // 3.
        if (ngx_terminate) {
            ngx_worker_process_exit(cycle);
        }
        if (ngx_quit) {
            if (!ngx_exiting) {
                ngx_exiting = 1;
                ngx_set_shutdown_timer(cycle);
                ngx_close_listening_sockets(cycle);
                ngx_close_idle_connections(cycle);
            }
        }
        if (ngx_reopen) {
           ngx_reopen_files(cycle, -1);
        }
    }
}
```


## 2.3、角色分工
- 主进程（master process）
  - 负责管理Worker进程（启动、监控、重启）
  - 不处理任何客户端请求，仅处理管理任务（如配置重载、热升级）
- Worker进程
  - 实际处理`客户端连接`和`请求`的核心组件
  - 每个Worker进程独立运行，通过事件驱动模型（如epoll）实现高并发。

# 三、小结
```text
main()
├─ ngx_os_init()          // 操作系统初始化
├─ ngx_ssl_init()         // SSL 初始化
├─ ngx_init_cycle()       // 配置解析与周期初始化
│  ├─ ngx_conf_parse()    // 解析 nginx.conf
│  ├─ init_module()       // 调用模块的 init_module 回调
│  └─ nginx_open_listening_sockets() //监听端口绑定
└─ ngx_master_process_cycle()    //多进程模式
   ├─ ngx_start_worker_processes()   // 创建 & 启动 Worker 进程
   │  ├─ ngx_spawn_process()     // 循环执行该方法
   │  │  ├─ fork()               // 调用fork()创建 Worker 进程
   │  │  └─ proc()               // 子进程执行 ngx_worker_process_cycle()方法，Worker进程的主循环函数
   │  └─ ngx_pass_open_channel() // 主子进程通信
   ├─ while(1)            // 主进程信号循环（处理reload, stop等信号）
   └─ Worker 事件循环 (epoll/kqueue)
```


