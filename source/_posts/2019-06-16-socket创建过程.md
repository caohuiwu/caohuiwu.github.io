---
title: socket创建过程
date: 2019-06-16 21:38:37
tags: tcp socket
---

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>



# 一、socket创建过程
## 1.1、建立socket
```java
Socket socket = new Socket();
```
<!--more-->

## 1.2、Linux内核中创建socket的系统调用流程

### 1.2.1. 系统调用入口：`sys_socket()`
**源码位置**：`net/socket.c`  
**作用**：处理用户空间的 `socket()` 系统调用，解析参数并触发内核套接字创建流程。  
**核心步骤**：
1. **参数校验**：  
   校验用户传入的 `domain`（协议族，如 `AF_INET`）、`type`（类型，如 `SOCK_STREAM`）、`protocol`（协议，如 `IPPROTO_TCP`）是否合法。
2. 调用 `sock_create()`：  
   将参数传递给内核内部的套接字创建函数。

```c
SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol) {
    int retval;
    struct socket *sock;
    retval = sock_create(family, type, protocol, &sock); // 核心调用
    // ... 后续绑定文件描述符等操作
}
```


### 1.2.2. 通用套接字创建：`sock_create()` → `__sock_create()`
**源码位置**：`net/socket.c`  
**作用**：分配套接字结构体，根据协议族调用对应的初始化函数。  
**核心流程**：
1. 分配 `struct socket`：  
   内核通过 `sock_alloc()` 分配一个未初始化的套接字结构体。
2. **协议族匹配**：  
   根据 `family`（如 `AF_INET`）查找对应的协议族操作表 `struct net_proto_family`。
3. 调用协议族的 `create()` 方法：  
   例如，对于 IPv4，`family->create` 指向 `inet_create()`。

```c
int __sock_create(struct net *net, int family, int type, int protocol,
                 struct socket **res, int kern) {
    struct socket *sock;
    const struct net_proto_family *pf;

    sock = sock_alloc(); // 分配 socket 结构体
    pf = rcu_dereference(net_families[family]); // 获取协议族操作表
    err = pf->create(net, sock, protocol, kern); // 调用协议族特定创建函数（如 inet_create）
    // ...
}
```


### 1.2.3. 协议族初始化：`inet_create()`
**源码位置**：`net/ipv4/af_inet.c`  
**作用**：针对 IPv4 协议族初始化套接字，设置协议相关的操作函数表。  
**核心流程**：
1. **协议类型检查**：  
   根据 `type`（如 `SOCK_STREAM`）和 `protocol`（如 `IPPROTO_TCP`）确定具体协议（TCP、UDP、RAW 等）。
2. **绑定协议操作表**：  
   设置 `struct socket` 的 `ops` 字段为协议特定的函数表（如 TCP 对应 `inet_stream_ops`，UDP 对应 `inet_dgram_ops`）。
3. 分配 `struct sock`：  
   通过 `sk_alloc()` 分配协议特定的套接字内核结构（如 `struct inet_sock`），并初始化协议相关参数。

```c
static int inet_create(struct net *net, struct socket *sock, int protocol, int kern) {
    struct sock *sk;
    struct inet_protosw *answer;

    // 根据 type 和 protocol 匹配协议（如 TCP、UDP）
    answer = inet_protosw[protocol];
    sock->ops = answer->ops; // 设置协议操作函数表（如 inet_stream_ops）

    sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer->prot, kern); // 分配 struct sock
    sock_init_data(sock, sk); // 初始化通用数据
    // ... 协议特定初始化（如 TCP 的 tcp_v4_init_sock）
}
```

### 1.2.4. 套接字数据初始化：`sock_init_data()`
**源码位置**：`net/core/sock.c`  
**作用**：初始化套接字的通用数据结构（`struct sock`），包括队列、回调函数、状态等。  
**核心步骤**：
1. **关联 `struct socket` 和 `struct sock`**：  
   将 `struct sock *sk` 绑定到 `struct socket *sock` 的 `sk` 字段。
2. **初始化收发队列**：  
   设置接收队列（`sk_receive_queue`）、发送队列（`sk_write_queue`）等。
3. **设置默认回调函数**：  
   例如，数据到达时的回调 `sk_data_ready`（默认为 `sock_def_readable`）。
4. **初始化状态和参数**：  
   设置套接字状态（`sk_state`）、超时时间（`sk_rcvtimeo`、`sk_sndtimeo`）等。

```c
void sock_init_data(struct socket *sock, struct sock *sk) {
    sk->sk_socket = sock; // 关联 socket 和 sock
    sock->sk = sk;

    sk->sk_receive_queue = RB_ROOT; // 初始化接收队列
    sk->sk_write_queue = RB_ROOT;   // 初始化发送队列

    sk->sk_data_ready = sock_def_readable; // 数据到达回调
    sk->sk_write_space = sock_def_write_space; // 发送缓冲区可写回调

    sk->sk_state = TCP_CLOSE; // 初始状态为关闭
    // ... 其他参数初始化
}
```

### 1.2.5. 流程总结
创建完sock变量之后，便是初始化sock结构体，并建立sock与socket之间的引用关系；调用链如下：
```text
net/Socket.c:sys_socket() //系统调用入口
    ->sock_create()       //通用套接字创建
        ->__sock_create() //
        ->net /ipv4/Af_inet.c:inet_create()
        ->net/core/Sock.c:sock_init_data()：
```
        


## 1.3、socket与文件系统关联：
创建好与socket相关的结构后，需要与文件系统关联，详见sock_map_fd()函数：
1) 申请文件描述符，并分配file结构和目录项结构；
2) 关联socket相关的文件操作函数表和目录项操作函数表；
3) 将file->private_date指向socket；
> fd代表这文件系统

socket与文件系统关联后，以后便可以通过文件系统read/write对socket进行操作了；
```
socket都需要fd去接收
socket：是一个四元组（客户端IP   客户端port     服务端IP     服务端port），内核级，
四元组唯一确定一个连接
```

# 三、SocketChannel创建过程
## 3.1、SocketChannel和Socket的区别
SocketChannel是对传统Java Socket API的改进，主要是支持了非阻塞的读写。同时改进了传统的单向流API, Channel同时支持读写(其实就是加了个中间层Buffer)。

### 3.1.1、socketChannel原理
```
// sun.nio.ch.SelectorProvider
public SocketChannel openSocketChannel() throws IOException {
    // 调用SocketChannelImpl的构造器
    return new SocketChannelImpl(this);
}
// sun.nio.ch.SocketChannelImpl
SocketChannelImpl(SelectorProvider sp) throws IOException {
    super(sp);
    // 创建socket fd
    this.fd = Net.socket(true);
    // 获取socket fd的值
    this.fdVal = IOUtil.fdVal(fd);
    // 初始化SocketChannel状态, 状态不多，总共就6个
    // 未初始化，未连接，正在连接，已连接，断开连接中，已断开
    this.state = ST_UNCONNECTED;
}
// sun.nio.ch.Net
static FileDescriptor socket(ProtocolFamily family, boolean stream)
    throws IOException {
    boolean preferIPv6 = isIPv6Available() &&
        (family != StandardProtocolFamily.INET);
    // 最后调用的是socket0
    return IOUtil.newFD(socket0(preferIPv6, stream, false));
}
// Due to oddities SO_REUSEADDR on windows reuse is ignored
private static native int socket0(boolean preferIPv6, boolean stream, boolean reuse);
```

底层还是socket函数

### 3.1.2、如何支持非阻塞
正常在c里我们实现非阻塞是靠fcntl这个函数，这个函数全称就是file control   
通过它可以管理fd的各种属性，比如设置fd的阻塞与否。

**fcntl的函数签名为:**
```
#include <fcntl.h>
int fcntl(int fildes, int cmd, ...);

```
- 第一个参数是传入的fd
- 第二个参数是操作类型，后面是flag
要设置非阻塞，操作类型是`F_SETFL`和`F_GETFL`,`flag`是`O_NONBLOCK`

那么JVM是怎么做的呢，在`SocketChannel`上有一个`configureBlocking`函数，这个函数是设置当前`SocketChannel`是否是阻塞的，和`selector`一起用的时候一定要设置成非阻塞才有意义, 阻塞的话就不需要IO多路复用的事件通知了。



