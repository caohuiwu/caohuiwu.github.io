---
title: socket创建过程
date: 2019-06-16 21:38:37
tags: tcp socket
---

## 一、socket创建过程
#### 1.1、建立socket, sock的关系
创建完sock变量之后，便是初始化sock结构体，并建立sock与socket之间的引用关系；调
用链如下：
    
    net/Socket.c:sys_socket()
        ->sock_create()
        ->__sock_create()
        ->net /ipv4/Af_inet.c:inet_create()
        ->net/core/Sock.c:sock_init_data()：
该函数主要工作是：

    a. 初始化sock结构的缓冲区、队列等；
    b. 初始化sock结构的状态为TCP_CLOSE；
    c. 建立socket与sock结构的相互引用关系；
    
<!--more-->        

#### 1.2、使用tcp协议初始化sock：
inet_create()函数最后，通过相应的协议来初始化sock结构：这里调用的是tcp_prot的init钩子函数net/ipv4/Tcp_ipv4.c:tcp_v4_init_sock()，它主要是对tcp_sock和inet_connection_sock进行一些初始化；

#### 1.3、socket与文件系统关联：
创建好与socket相关的结构后，需要与文件系统关联，详见sock_map_fd()函数：
    
    1) 申请文件描述符，并分配file结构和目录项结构；
    2) 关联socket相关的文件操作函数表和目录项操作函数表；
    3) 将file->private_date指向socket；
> fd代表这文件系统

socket与文件系统关联后，以后便可以通过文件系统read/write对socket进行操作了；

## 二、启动服务端socket过程：90端口

    a. 内核创建socket（socket有接收队列+发送队列）
    b. 然后会申请创建一个对应的TCP类型的fd，此fd处于监听状态
    c. 最后建立socket与文件系统的关联
    -------------------------------------------------
    1、netstat -natp
        此时会创建90端口TCP进程，处于listen状态，内核分配资源：fd+接收队列+发送队列。
    2、lsof -p pid
        该进程对应的fd，也处于listen状态
    3、其他
        该listen进程会一直存在，用于接受其他连接


## 三、客户端连接

    客户端创建socket，与服务端创建过程一致。
    此时服务端未accept()
    a. 三次握手后，服务端会创建一个新的socket（socket有缓存队列用于接收消息）
    b. 未accept()，此时不会创建fd与该socket建立关联。
    c.若要读取缓存队列中的消息，需要创建新进程(fd)，与该socket建立映射
    
    1、netstat -natp
    经过三次握手后，服务端会新创建一个socket，但是未分配给进程使用；
    2、客户端发送消息
    此时服务端的socket对应的rec-q接收队列会受到客户端发送的内容。
    ----此时服务端创建的socket未指定到具体的fd.
    3、服务端accept
    创建fd，此时socket会指定到这个fd
    
    每个进程的进程控制块task_struct中都有一个files_struct结构体，它保存了进程所有打开的文件，以文件描述符fd为索引即可找到对应的file对象，file对象中也包含了文件当前位置的信息


## 四、其他

    socket都需要fd去接收
    socket：是一个四元组（客户端IP   客户端port     服务端IP     服务端port），内核级，
    四元组唯一确定一个连接


