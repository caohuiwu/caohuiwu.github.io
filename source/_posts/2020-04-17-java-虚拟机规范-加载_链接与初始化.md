---
title: 《Java》加载、链接与初始化
date: 2020-04-17 12:19:31
categories: 
   - [java, jvm, 虚拟机规范, 虚拟机启动]
tags: 虚拟机启动 
---

### 一、定义
- **加载**是根据特定名称查找类或接口类型的二进制表示（Binary Representation），并由此二进制表示创建类或接口的过程。
- **链接**是为了让类或接口可以被 Java 虚拟机执行，而将类或接口并入虚拟机运行时状态的过程。
- **类或接口的初始化**是指执行类或接口的初始化方法<clinit>。

<!-- more -->



### 二、运行时常量池
- 定义：Java 虚拟机为每个类型都维护一个常量池。它是 Java 虚拟机中的运行时数据结构，像传统编程语言实现中的符号表一样有很多用途。
- 创建时机：当类或接口创建时，它的二进制表示中的 **constant_pool 表** 被用来构造**运行时常量池**。
- 内容：运行时常量池中的所有引用最初都是符号引用。

这些符号引用来自于类或接口的二进制表示的如下结构中：
1. 某个类或接口的符号引用来自于类或接口二进制表示中的 CONSTANT_Class_info 结构
2. 类或接口的某个字段的符号引用来自于类或接口二进制表示中的CONSTANT_Fieldref_info 结构。这种引用包含了字段的名称和描述符，及指向字段所属类或接口的符号引用
3. 类中某个方法的符号引用来自于类或接口二进制表示中的 CONSTANT_Methodref_info 结构。这种引用提供方法的名称和描述符，及指向方法所属类的符号引用。
4. 接口的某个方法的符号引用来自于类或接口二进制表示中的CONSTANT_InterfaceMethodref_info 结构。这种引用提供接口方法的名称 和描述符，及指向方法所属接口的符号引用。
5. 方法句柄（Method Handle）的符号引用来自于类或接口二进制表示中的 CONSTANT_MethodHandle_info 结构。
6. 方法类型（Method Type）的符号引用来自于类或接口二进制表示中的 CONSTANT_MethodType_info 结构。
7. 字符常量表示 String 类实例的一个引用，它来自于类或接口二进制表示的 CONSTANT_String_info 结构。
8. 其它运行时常量值来自于类或接口二进制表示的 CONSTANT_Interger_info、CONSTANT_Float_info、CONSTANT_Long_info 或是 CONSTANT_Double_info 结构。


### 三、虚拟机启动
Java 虚拟机的启动是通过引导类加载器（Bootstrap Class Loader）创建一个初始类（Initial Class）来完成，这个类是由虚拟机的具体实现指定。紧接着，Java 虚拟机链接这个初始类，初始化并调用它的 public void main(String[])方法。之后的整个执行过程都是由对此方法的调用开始。执行 main 方法中的 Java 虚拟机指令可能会导致 Java 虚拟机链接另外的一些类或接口，也可能会调用另外的方法。

#### 3.1、启动入口
虚拟机的**启动入口**位于share/tools/launcher/java.c的main方法，整个流程分为如下几个步骤：

<style>
.highlight.plain {
    height:400px;
}
</style>
```
int main(int argc, char **argv) {
    JavaVMInitArgs vm_args;
    JavaVMOption* options = NULL;
    jint res;
    JavaVM *vm = NULL;
    JNIEnv *env = NULL;
    // 1. 初始化JavaVMInitArgs结构体，设置相关参数（这里简化了很多配置过程）
    memset(&vm_args, 0, sizeof(vm_args));
    vm_args.version = JNI_VERSION_1_8;  // 假设使用Java 8版本对应的JNI版本
    vm_args.nOptions = 0;
    vm_args.options = options;
    vm_args.ignoreUnrecognized = JNI_TRUE;

    // 2. 可以在这里根据命令行参数等情况进一步配置vm_args，添加更多选项等（省略复杂细节）

    // 3. 尝试创建Java虚拟机
    res = JNI_CreateJavaVM(&vm, &env, &vm_args);
    JNI_ERR_RETURN(res);

    // 4. 加载主类（这里简单示意，实际要处理类路径等诸多细节）
    jclass cls = (*env)->FindClass(env, "MainClass");  // 假设主类名为MainClass
    CHECK_NULL_RETURN(cls);

    // 5. 获取主类的main方法（同样简化示意，真实要严格验证方法签名等）
    jmethodID mid = (*env)->GetStaticMethodID(env, cls, "main", "([Ljava/lang/String;)V");
    CHECK_NULL_RETURN(mid);

    // 6. 构造参数传递给main方法（比如处理真实的命令行参数传入等，这里简化）
    jobjectArray argsArray = (*env)->NewObjectArray(env, argc, (*env)->FindClass(env, "Ljava/lang/String;"), NULL);
    for (int i = 0; i < argc; i++) {
        jstring str = (*env)->NewStringUTF(env, argv[i]);
        (*env)->SetObjectArrayElement(env, argsArray, i, str);
    }

    // 7. 调用主类的main方法
    (*env)->CallStaticVoidMethod(env, cls, mid, argsArray);

    // 8. 销毁Java虚拟机（释放相关资源等复杂操作）
    (*vm)->DestroyJavaVM(vm);

    return 0;
}
```

#### 3.2、启动步骤

##### 3.2.1、初始化参数部分
```java
JavaVMInitArgs vm_args;
JavaVMOption* options = NULL;
// 初始化JavaVMInitArgs结构体，设置相关参数（这里简化了很多配置过程）
memset(&vm_args, 0, sizeof(vm_args));
vm_args.version = JNI_VERSION_1_8;  // 假设使用Java 8版本对应的JNI版本
vm_args.nOptions = 0;
vm_args.options = options;
vm_args.ignoreUnrecognized = JNI_TRUE;
```
首先定义了JavaVMInitArgs结构体对象vm_args，这个结构体用于存放创建 Java 虚拟机时的各种参数配置信息，比如 Java 虚拟机所遵循的 JNI 版本（这里设置为对应 Java 8 的JNI_VERSION_1_8），还定义了JavaVMOption类型的指针options（虽然初始化为NULL，但后续可以根据实际情况动态分配内存并添加更多具体的配置选项，例如设置内存大小、类加载路径等，这里省略了这些复杂的添加选项操作）。ignoreUnrecognized设置为JNI_TRUE表示忽略那些不被识别的选项。

##### 3.2.2、创建 Java 虚拟机
```java
res = JNI_CreateJavaVM(&vm, &env, &vm_args);
JNI_ERR_RETURN(res);
```
> 使用JNI_CreateJavaVM函数尝试创建 Java 虚拟机，传入的参数分别是用于返回创建好的 Java 虚拟机实例指针的&vm、返回 JNI 环境指针的&env以及前面配置好的创建参数结构体&vm_args的地址。然后通过JNI_ERR_RETURN宏来判断返回结果，如果返回值不是JNI_OK，则直接返回，意味着 Java 虚拟机创建失败。

##### 3.2.3、加载主类与获取方法
```java
jclass cls = (*env)->FindClass(env, "MainClass");  // 假设主类名为MainClass
CHECK_NULL_RETURN(cls);

jmethodID mid = (*env)->GetStaticMethodID(env, cls, "main", "([Ljava/lang/String;)V");
CHECK_NULL_RETURN(mid);
```
- 通过(*env)->FindClass函数在当前的 JNI 环境（env）下尝试查找指定名称（这里假设主类名为MainClass，实际会根据具体传入的类名或者配置来查找）的类，若返回的类指针cls为NULL，则通过CHECK_NULL_RETURN宏直接返回，表示类加载失败。
- 接着使用(*env)->GetStaticMethodID函数在已经加载的类（cls）中查找名为main，签名为([Ljava/lang/String;)V（表示参数是String数组且返回值为void的静态方法）的方法，同样若返回的方法标识符mid为NULL，则返回，表示方法查找失败。

##### 3.2.4、构造参数与调用方法
```java
jobjectArray argsArray = (*env)->NewObjectArray(env, argc, (*env)->FindClass(env, "Ljava/lang/String;"), NULL);
for (int i = 0; i < argc; i++) {
    jstring str = (*env)->NewStringUTF(env, argv[i]);
    (*env)->SetObjectArrayElement(env, argsArray, i, str);
}

(*env)->CallStaticVoidMethod(env, cls, mid, argsArray);
```
- 首先通过(*env)->NewObjectArray函数创建一个String类型的对象数组（argsArray），数组大小根据命令行参数个数argc来确定，元素类型为String（通过查找"Ljava/lang/String;"类来指定），初始化为NULL。
- 然后遍历命令行参数数组（argv），通过(*env)->NewStringUTF函数将每个C风格的字符串转换为JNI中的jstring类型，并使用(*env)->SetObjectArrayElement函数将其逐个放入前面创建的argsArray中，这样就构造好了要传递给main方法的参数数组。
- 最后通过(*env)->CallStaticVoidMethod函数调用主类（cls）中获取到的main方法（mid），并传入构造好的参数数组argsArray来启动 Java 程序的执行


###### 3.2.5、销毁 Java 虚拟机
```java
(*vm)->DestroyJavaVM(vm);
```
在完成了main方法的调用等操作后，使用(*vm)->DestroyJavaVM函数来销毁 Java 虚拟机实例（vm），释放相关的资源。这一步涉及到很多底层的内存清理、资源回收以及与操作系统相关的交互等复杂操作，这里只是简单调用了这个函数来示意整个流程的完整性。

**参考文章：**  [JVM源码分析之JVM启动流程](https://www.cnblogs.com/yuandengta/p/12931818.html)


### 四、加载
**定义：** 加载是根据特定名称查找类或接口类型的二进制表示（Binary Representation），并由此二进制表示创建类或接口的过程

#### 4.1、类加载器
虚拟机支持两种类加载器：
- Java 虚拟机提供的引导类加载器（Bootstrap ClassLoader）
- 用户自定义类加载器
  - 每个用户自定义的类加载器应该是抽象类 ClassLoader 的某个子类的实例

### 五、链接
**定义：** 链接是为了让类或接口可以被 Java 虚拟机执行，而将类或接口并入虚拟机运行时状态的过程。

#### 5.1、验证
**作用：** 验证（Verification）阶段用于**确保类或接口的二进制表示结构上是正确的**。

如果类或接口的二进制表示不能满足 4.9 节（Java 虚拟机代码限制）中描述的静态或结构上的约束，那就必须在导致验证发生的程序调用处被抛出 VerityError 异常。

#### 5.2、准备
**作用**：准备（Preparation）阶段的任务是为类或接口的<font style="color:red">**静态字段分配空间**</font>，并用默认值初始化这些字段。这个阶段不会执行任何的虚拟机字节码指令。

#### 5.3、解析
> Java 虚拟机指令 anewarray、checkcast、getfield、getstatic、instanceof、 nvokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、 ldc、ldc_w、multianewarray、new、putfield 和 putstatic 将符号引用指向运行时常量池。执行上述任何一条指令都需要对它的符号引用的进行解析。
> 
> **字面量：** 文本字符串、声明为final的常量值
> **符号引用：** 是一种用来定位类、接口、字段和方法等的引用方式。它是一种在编译时期（字节码生成阶段）使用的、无歧义的标识符，用于在字节码文件中表示对其他类、方法、字段等的引用关系。符号引用主要是为了保证在编译阶段能够正确地记录下这些引用信息，而具体的引用对象的实际内存地址等信息则在运行时（类加载的解析阶段）才确定。
> - 类和接口的全限定名
> - 字段的名称和描述符
> - 方法的名称和描述符

**作用：** 解析（Resolution）是根据运行时常量池的符号引用来动态决定具体的值的过程（**符号引用转化成直接引用**）。


### 六、初始化
初始化（Initialization）对于类或接口来说，就是执行它的初始化方法。
> - <font color=#e98787>**类初始化方法<clinit\>：** </font>一个类或者接口最多可以包含不超过一个类或接口的初始化方法，类或者接口就是通过这个方法完成初始化的。这个方法是一个不包含参数的静态方法，名为<clinit>。这个名字也是由编译器命名的，因为它并非一个合法的 Java 方法名字，不可能通过程序编码的方式实现。
    - 类或接口的初始化方法由 Java 虚拟机自身隐式调用，没有任何虚拟机字节码指令可以调用这个方法，只有在类的初始化阶段中会被虚拟机自身调用。

在发生下列行为时，类或接口将会被初始化：
- **在执行下列需要引用类或接口的 Java 虚拟机指令时：new，getstatic，putstatic
或 invokestatic。** 这些指令通过字段或方法引用来直接或间接地引用其它类。执行上
面所述的 new 指令，在类或接口没有被初始化过时就初始化它。执行上面的 getstatic，
putstatic 或 invokestatic 指令时，那些解析好的字段或方法中的类或接口如果还
没有被初始化那就初始化它。
- **在初次调用 java.lang.invoke.MethodHandle 实例时**，它的执行结果为通过 Java 虚拟机解析出类型是 2（REF_getStatic）、4（REF_putStatic）或者 6（REF_invokeStatic）的方法句柄。
- **在调用 JDK 核心类库中的反射方法时，** 例如，Class 类或 java.lang.reflect 包。
- **在对于类的某个子类的初始化时。**
- **在它被选定为 Java 虚拟机启动时的初始类（§5.2）时。**
在类或接口被初始化之前，它必须被链接过，也就是经过验证、准备阶段，且有可能已经被解析完成了。

因为 Java 虚拟机是支持多线程的，所以在初始化类或接口的时候要特别注意线程同步问题，可能其它一些线程也想要初始化相同名称的类或接口。

每个类或接口 C，都有一个唯一的初始化锁 LC。如何实现从 C 到 LC 的映射可由 Java 虚拟机实现自行决定。例如，LC 可以是 C 的 Class 对象，或者是与 Class 对象相关的管程（Monitor）。


