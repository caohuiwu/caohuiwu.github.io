---
title: 《Mybatis》启动过程
date: 2021-02-14
categories:
  - [mybatis]
---

    这是Mybatis系列的第1篇文章，主要介绍的是Mybatis的启动过程。

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>

# 一、Mybatis
`Mybatis`是持久层框架，通过XML或注解配置SQL映射，将Java对象与数据库操作解耦。与传统的JDBC相比，Mybatis简化了数据库交互，并提供了灵活的SQL控制能力。

<!-- more -->

# 二、配置方式
## 2.1、xml配置方式
- 第一步：全局配置`mybatis-config.xml`，定义数据源、事务管理器、类型处理器
```
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/test"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="mapper/UserMapper.xml"/>
    </mappers>
    <settings>
        //二级缓存：作用域为Mapper级别，跨sqlSession共享，不建议打开
        <setting name="cacheEnabled" value="false"/>
        <setting name="logPrefix" value="mybatis." />
        <setting name="logImpl" value="LOG4J2" />
    </settings>
</configuration>
```
- 第二步：配置相应内容
```
###### 配置sqlSessionFactoryBean
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="configLocation" value="classpath:mybatis/mybatis-config.xml"/>
    <property name="dataSource" ref="dynamicDataSource"/>
    <property name="mapperLocations" value="classpath:mybatis/corder.center.server/**.xml"/>
</bean>
###### 配置MapperScannerConfigurer
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="dao.mapper"/>
    <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
</bean>
```

## 2.2、注解方式
```java
@Configuration
@MapperScan(basePackages = "com.mapper")
public class MyBatisConfig {
    @Bean
    public DataSource dataSource() {
        PooledDataSource dataSource = new PooledDataSource();
        return dataSource;
    }
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        try {
            factoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mybatis/*/*.xml"));
            return factoryBean.getObject();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();
        mapperScannerConfigurer.setBasePackage("com.example.mapper");
        return mapperScannerConfigurer;
    }
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
```

# 三、`MapperScannerConfigurer`启动入口
`MapperScannerConfigurer`是Mybatis-Spring整合模块中的核心类，用于自动扫描并注册Mapper接口到Spring容器，避免手动配置每个Mapper的繁琐操作。
- **主要功能**：扫描basePackage下面的java文件，生成`BeanDefinationHolder`
```java
public class MapperScannerConfigurer
        implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
        if (this.processPropertyPlaceHolders) {
            processPropertyPlaceHolders();
        }

        ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
        scanner.setAddToConfig(this.addToConfig);
        scanner.setAnnotationClass(this.annotationClass);
        scanner.setMarkerInterface(this.markerInterface);
        scanner.setSqlSessionFactory(this.sqlSessionFactory);
        scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
        scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
        scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
        scanner.setResourceLoader(this.applicationContext);
        scanner.setBeanNameGenerator(this.nameGenerator);
        scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);
        if (StringUtils.hasText(lazyInitialization)) {
            scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
        }
        scanner.registerFilters();
        scanner.scan(
                StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
    }

}
```

在容器启动过程中，触发`MapperScannerConfigurer`的`postProcessBeanDefinitionRegistry`方法，执行堆栈如下：
```
AbstractApplicationContext.refresh()
-> AbstractApplicationContext.invokeBeanFactoryPostProcessors()
    -> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()
        -> PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors()
            -> MapperScannerConfigurer.postProcessBeanDefinitionRegistry()
```

## 3.1、Bean扫描

执行scanner.scan()方法，实际会执行父类ClassPathBeanDefinitionScanner的scan()方法
```java
public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {
    public int scan(String... basePackages) {
        int beanCountAtScanStart = this.registry.getBeanDefinitionCount();

        doScan(basePackages);
        // Register annotation config processors, if necessary.
        if (this.includeAnnotationConfig) {
            AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
        }
        return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
    }
}
```
继续跟踪，进入`doScan()`方法，进入`ClassPathMapperScanner.doScan()`
```java
public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner {
    @Override
    public Set<BeanDefinitionHolder> doScan(String... basePackages) {
        // 1. 调用父类扫描方法，获取候选 BeanDefinition
        Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);

        // 2. 对每个 BeanDefinition 进行处理
        for (BeanDefinitionHolder holder : beanDefinitions) {
            GenericBeanDefinition definition = (GenericBeanDefinition) holder.getBeanDefinition();

            // 3. 设置 MapperFactoryBean 为 Bean 的构造参数
            definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());
            definition.setBeanClass(MapperFactoryBean.class);

            // 4. 设置 SqlSessionFactory/SqlSessionTemplate 依赖
            definition.getPropertyValues().add("sqlSessionFactory", sqlSessionFactory);
        }
        return beanDefinitions;
    }
}
```
遍历`BeanDefinationHolder`，生成`BeanDefinition`，设置Bean的真实类型<code class="red">MapperFactoryBean</code>

## 3.2、<code class="red">MapperFactoryBean</code>结构
```java
public class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {
    @Override
    public T getObject() throws Exception {
        return getSqlSession().getMapper(this.mapperInterface);
    }
}
//SqlSessionDaoSupport内部属性SqlSessionTemplate
public abstract class SqlSessionDaoSupport extends DaoSupport {

    private SqlSessionTemplate sqlSessionTemplate;

    public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
        if (this.sqlSessionTemplate == null || sqlSessionFactory != this.sqlSessionTemplate.getSqlSessionFactory()) {
            this.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);
        }
    }
}
//SqlSessionTemplate内部属性有sqlSessionFactory
public class SqlSessionTemplate implements SqlSession, DisposableBean {
    private final SqlSessionFactory sqlSessionFactory;
    private final ExecutorType executorType;
    private final SqlSession sqlSessionProxy;
    private final PersistenceExceptionTranslator exceptionTranslator;
}
```

## 3.3、<code class="red">MapperFactoryBean</code>创建
如下示例
```java
@Service
public class OrderService {
    @Reource
    private OrderMapper orderMapper;
    @Transactional
    public synchronized void selectById() {
        orderMapper.selectByPrimaryKey(0L);
    }

    public void find() {
        this.selectById();
    }
}
```
`OrderService`注入`OrderMapper`，在创建OrderService的Bean时，会注入属性，此时会去创建OrderMapper。执行堆栈如下：
```
1. 创建 orderService
-> AbstractAutowireCapableBeanFactory.doCreateBean()
2. orderService属性注入
 -> AbstractAutowireCapableBeanFactory.populateBean()
  -> CommonAnnotationBeanPostProcessor.postProcessPropertyValues()
   -> InjectionMetadata.inject()
    -> CommonAnnotationBeanPostProcessor.getResourceToInject()
     -> CommonAnnotationBeanPostProcessor.getResource()
      -> CommonAnnotationBeanPostProcessor.autowireResource()
3. orderService属性注入，触发 orderMapper 的创建
       -> AbstractBeanFactory.getBean()
        |-> AbstractBeanFactory.doGetBean()
4. 第一步：调用getSingleton()去创建MapperFactoryBean对象
        |1 |-> DefaultSingletonBeanRegistry.getSingleton()
        |  | -> AbstractBeanFactory.getObject()
        |  |  -> AbstractAutowireCapableBeanFactory.createBean()
        |  |   -> AbstractAutowireCapableBeanFactory.doCreateBean()
                //实例化MapperFactoryBean对象
        |  |    -> AbstractAutowireCapableBeanFactory.createBeanInstance()
        |  |     -> AbstractAutowireCapableBeanFactory.autowireConstructor()
        |  |      -> ConstructorResolver.autowireConstructor()
        |  |       -> SimpleInstantiationStrategy.instantiate()
        |  |        -> BeanUtils.instantiateClass()
					//调用MapperFactoryBean的构造函数，创建MapperFactoryBean对象
        |  |         -> Constructor.newInstance()
                //属性填充MapperFactoryBean对象
        |  |    -> AbstractAutowireCapableBeanFactory.populateBean()
        |  |     -> AbstractNestablePropertyAccessor.setPropertyValue()
                  //创建 SqlSessionTemplate
        |  |      -> SqlSessionDaoSupport.setSqlSessionFactory()
5. 第二步：调用getObjectForBeanInstance去创建MapperProxy代理
        |2 |-> AbstractBeanFactory.getObjectForBeanInstance()
        |  | -> FactoryBeanRegistrySupport.getObjectFromFactoryBean()
        |  |  -> FactoryBeanRegistrySupport.doGetObjectFromFactoryBean()
        |  |   -> MapperFactoryBean.getObject()：重点！！！调用了工厂bean的getObject()方法
        |  |    -> SqlSessionTemplate.getMapper()
        |  |     -> Configuration.getMapper()
        |  |      -> MapperRegistry.getMapper()
        |  |       -> MapperProxyFactory.newInstance()
        |  |        -> Proxy.newProxyInstance()
```
主要2个步骤：
1. `getSingleton()`创建`MapperFactoryBean`对象
2. 然后处理`MapperFactoryBean`工厂对象，调用其`getObject()`方法获取`MapperProxy`代理对象

> getObjectForBeanInstance()方法
> 
> 其核心目的是确保最终返回的Bean实例是用户期望的目标对象。处理FactoryBean对象。

最终，`OrderMapper`的实例创建成功（是一个<code class="red">MapperProxy对象</code>），并注入到了`OrderService`.
> 其实创建OrderMapper实例后，还有OrderMapper的属性注入等操作（涉及到<code class="red">sqlSessionFactory</code>创建和注入）

# 四、SqlSessionFactoryBean
`SqlSessionFactoryBean`用于创建Mybatis的`SqlSessionFactory`实例。它封装了配置解析、数据源绑定、映射文件加载等逻辑，是Mybatis与Spring无缝集成的桥梁。

`SqlSessionFactoryBean`实现了InitializingBean接口，在Bean属性都注入完成后，初始化时会调用`afterPropertiesSet`方法。
```java
public class SqlSessionFactoryBean
    implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {
    @Override
    public void afterPropertiesSet() throws Exception {
        notNull(dataSource, "Property 'dataSource' is required");
        notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required");
        state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),
                "Property 'configuration' and 'configLocation' can not specified with together");

        this.sqlSessionFactory = buildSqlSessionFactory();
    }
}
```
主要执行逻辑`buildSqlSessionFactory()`，创建`SqlSessionFactory`
```java
protected SqlSessionFactory buildSqlSessionFactory() throws Exception {

    final Configuration targetConfiguration;

    XMLConfigBuilder xmlConfigBuilder = null;
    //1. configLocation：配置Mybatis全局配置文件路径【mybatis-config.xml】
    if (this.configLocation != null) {
        //根据configLocation创建xmlConfigBuilder，XMLConfigBuilder构造器中会创建Configuration对象
        xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);
        //将XMLConfigBuilder构造器中创建的Configuration对象直接赋值给configuration属性
        configuration = xmlConfigBuilder.getConfiguration();
    }
    //略....
    if (xmlConfigBuilder != null) {
        try {
        //解析mybatis-Config.xml文件，并将相关配置信息保存到configuration
        xmlConfigBuilder.parse();
        LOGGER.debug(() -> "Parsed configuration file: '" + this.configLocation + "'");
      }
    }
    //事务默认采用SpringManagedTransaction，这一块非常重要，我将在后买你单独写一篇文章讲解Mybatis和Spring事务的关系
    targetConfiguration.setEnvironment(new Environment(this.environment,
            this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,
            this.dataSource));
    //2. mapperLocations：mapper.xml文件路径，解析这些文件
    if (this.mapperLocations != null) {
        for (Resource mapperLocation : this.mapperLocations) {
            if (mapperLocation == null) {
                continue;
            }
            try {
                // 解析mapper.xml文件，并注册到configuration对象的mapperRegistry
                XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),
                        targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());
                xmlMapperBuilder.parse();
            }
        }
    }
    // 将Configuration对象实例作为参数，
    // 调用sqlSessionFactoryBuilder创建sqlSessionFactory对象实例
    return this.sqlSessionFactoryBuilder.build(targetConfiguration);
}
```
`buildSqlSessionFactory`的核心逻辑：解析`mybatis配置文件mybatisConfig.xml`和`mapper配置文件mapper.xml`并封装到Configuration对象中，最后调用mybatis的`sqlSessionFactoryBuilder`来创建`SqlSessionFactory`对象。这一点相当于前面介绍的原生的mybatis的初始化过程。

另外，当配置中未指定事务时，mybatis-spring默认采用`SpringManagedTransaction`，这一点**非常重要**，请大家先在心里做好准备。此时`SqlSessionFactory`已经创建好了，并且赋值到了`SqlSessionFactoryBean`的`sqlSessionFactory`属性中。


## 4.1、xmlConfigBuilder.parse()
方法作用：mybatis.xml配置文件的解析，得到Configuration对象 （org.apache.ibatis.session.Configuration）
- 解析 `<properties>` 标签
- 解析 `<settings>` 标签
- 解析 `<plugins>` 标签
- 解析 `<typeHandlers>` 标签
- 解析 `<mappers>` 标签

> 文件的具体解析工作
```
public Configuration parse() {
    if (parsed) {
      throw new BuilderException("Each XMLConfigBuilder can only be used once.");
    }
    parsed = true;
    parseConfiguration(parser.evalNode("/configuration"));
    return configuration;
  }

  private void parseConfiguration(XNode root) {
    try {
      //issue #117 read properties first
      propertiesElement(root.evalNode("properties"));
      Properties settings = settingsAsProperties(root.evalNode("settings"));
      loadCustomVfs(settings);
      typeAliasesElement(root.evalNode("typeAliases"));
      pluginElement(root.evalNode("plugins"));
      objectFactoryElement(root.evalNode("objectFactory"));
      objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
      reflectorFactoryElement(root.evalNode("reflectorFactory"));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      environmentsElement(root.evalNode("environments"));
      databaseIdProviderElement(root.evalNode("databaseIdProvider"));
      typeHandlerElement(root.evalNode("typeHandlers"));
      //解析mapper文件
      mapperElement(root.evalNode("mappers"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
    }
  }
```

## 4.2、xmlMapperBuilder.parse()
方法的主要作用是将`Mapper`映射器的xml配置文件解析为Spring容器能够识别的对象，并进行一些必要的处理和注册。这样，在后续的操作中，就可以通过Mapper接口来访问和执行相应的数据库操作。

### 4.2.1、mapper文件的解析
获取 `<mapper>` 标签中的 namespace 属性，同时会进行多种边界检查
- 解析 `<cache>` 标签
获取 `<cache>` 标签中的各项属性（`type、flushInterval、size` 等属性）
读取 `<cache>` 标签下的子标签信息，这些信息将用于初始化二级缓存
`MapperBuilderAssistant` 会根据上述配置信息，创建一个全新的Cache 对象并添加到 `Configuration.caches` 集合中保存
	这个 caches 字段是一个StrictMap 类型的集合，其中的 Key是Cache 对象的唯一标识，默认值是Mapper.xml 映射文件的namespace，Value 才是真正的`二级缓存对应的 Cache 对象`
- 解析 `<cache-ref>` 标签
可以通过 `<cache>` 标签为每个 namespace 开启二级缓存
在有的场景中，我们会需要在多个 namespace 共享同一个二级缓存，也就是共享同一个 Cache 对象。
- 解析 `<resultMap>` 标签
定义结果集与 Java 对象之间的映射规则
	`<column>、<id>` 等，都被解析一个 ResultMapping 对象
- 解析 `<sql>` 标签
- 解析 `<select>、<insert>、<update>、<delete>` 等 SQL 标签
通过`XMLStatementBuilder` 进行解析
`LanguageDriver.createSqlSource()`方法创建SqlSource对象
	使用 SqlSource 接口来表示解析之后的 SQL 语句，其中的 SQL 语句只是一个中间态，可能包含动态 SQL 标签或占位符等信息，无法直接使用
	解析SQL语句，如果含有未解析的"${}"占位符，则为动态SQL
	如果解析到一个子标签，那么一定是动态SQL
		这里会根据不同的标签，获取不同的NodeHandler，然后由NodeHandler进行后续解析
			以 IfHandler 为例，它解析的就是 <if> 标签
		9 种动态 sql 标签：`trim | where | set | foreach | if | choose | when | otherwise | bind`。
最后，利用工具类 `MapperBuilderAssistant` 来将上面解析的内容组装成 `MappedStatement` 对象，然后注册到 `Configuration` 的 `mappedStatements` 属性中。`mappedStatements` 为 Map 结构，其中 `Key 为 Mapper Id，Value 为 MappedStatement 对象`
- `MappedStatement`
每个`MappedStatement`对应了我们自定义Mapper接口中的一个方法，它保存了开发人员编写的SQL语句、参数结构、返回值结构、Mybatis对它的处理方式的配置等细节要素，是对一个SQL命令是什么、执行方式的完整定义。可以说，有了它Mybatis就知道如何去调度四大组件顺利的完成用户请求
- mapper id 不可重复

> 占位符的替换工作
```
//解析文件中的占位符
//<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
//<property name="url" value="${jdbc.url1}" />
//<property name="username" value="${jdbc.username1}" />
//<property name="password" value="${jdbc.password1}" />
public class PropertyParser {
    public static String parse(String string, Properties variables) {
        VariableTokenHandler handler = new VariableTokenHandler(variables);
        GenericTokenParser parser = new GenericTokenParser("${", "}", handler);
        return parser.parse(string);
    }
}
```


### 4.2.2、bindMapperForNamespace()
作用：动态绑定 `Mapper` 接口：
- 允许在运行时将特定的 `Mapper` 接口与`SqlSession`关联起来，而不是仅仅依赖于在配置文件中静态地定义 `Mapper` 接口与 SQL 映射关系。

`Mapper` 接口的绑定过程
- 获取命名空间，并根据命名空间解析 mapper 类型；
- 将 type 和 `MapperProxyFactory` 实例存入 `knownMappers` 中；
- 创建注解解析器进行解析（这个就不看了，注解无非也是拿到我们的注解的 sql 最后都是字符串 然后进行解析的。


# 五、SqlSessionFactory

## 5.1、创建时机
`SqlSessionFactoryBean`的实例化过程中执行`buildSqlSessionFactory()`方法，会创建`SqlSessionFactory`。

## 5.2、核心作用
- 创建SqlSession：通过openSession()方法生成SqlSession实例，用于执行SQL操作。
- 管理全局配置：解析并缓存Mybatis的全局配置（如数据源、类型处理器、插件等）。
- 加载映射文件：加载所有Mapper XML文件，维护SQL映射关系（MappedStatement）


## 5.3、生命周期与线程安全
**初始化**：随应用启动一次性创建，通常为单例。
**运行期**：持续提供SqlSession实例。
是线程安全的。
