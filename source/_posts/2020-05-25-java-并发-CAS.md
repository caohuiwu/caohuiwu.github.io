---
title: 《Java》CAS
date: 2020-05-25 12:19:31
categories:
  - [ java, 并发, CAS]
---

	这是“并发”系列的第五篇文章，主要介绍的是CAS相关内容。

# 一、什么是CAS？
compare and swap，比较并替换，是一种并发编程中常用的**原子操作机制**。它的主要功能是在多线程环境下，比较内存中的某个值与预期值是否相等，如果相等，则将该值更新为新的值；这个操作是原子性的，也就是在执行过程中不会被其他线程中断。
<!-- more -->


# 二、在 Java 中的应用
在 Java 中，实现<code>CAS</code> 操作的一个关键类是Unsafe。

sun.misc包下的Unsafe类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作：
```java
public final class Unsafe {
    /**
     * 以原子方式更新对象字段的值。
     *
     * @param o        要操作的对象
     * @param offset   对象字段的内存偏移量
     * @param expected 期望的旧值
     * @param x        要设置的新值
     * @return 如果值被成功更新，则返回 true；否则返回 false
     */
    public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x);

    /**
     * 以原子方式更新 int 类型的对象字段的值。
     */
    public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);

    /**
     * 以原子方式更新 long 类型的对象字段的值。
     */
    public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x);
}
```
Unsafe类中的 CAS 方法是native方法。native关键字表明这些方法是用本地代码（通常是 C 或 C++）实现的，而不是用 Java 实现的。这些方法直接调用底层的硬件指令来实现原子操作。也就是说，Java 语言并没有直接用 Java 实现 CAS。

## 2.1、以AtomicInteger为例
它的compareAndSet方法就是一个典型的 CAS 操作方法。
代码示例：
```java
import java.util.concurrent.atomic.AtomicInteger;
public class CASExample {
    public static void main(String[] args) {
        AtomicInteger atomicInt = new AtomicInteger(0);
        boolean result = atomicInt.compareAndSet(0, 1);
        if (result) {
            System.out.println("成功将值从0更新为1");
        } else {
            System.out.println("更新失败，可能有其他线程修改了值");
        }
    }
}
```
在上述代码中，首先创建了一个AtomicInteger对象atomicInt，初始值为 0。然后调用compareAndSet方法，传入预期值 0 和新值 1。如果此时atomicInt的值为 0（即没有其他线程修改它），那么就会将其值更新为 1，并返回true；否则返回false，表示更新失败。


### AtomicInteger核心源码如下：
```java
// 获取 Unsafe 实例
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
    try {
        // 获取“value”字段在AtomicInteger类中的内存偏移量
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField("value"));
    } catch (Exception ex) { throw new Error(ex); }
}
// 确保“value”字段的可见性
private volatile int value;

// 如果当前值等于预期值，则原子地将值设置为newValue
// 使用 Unsafe#compareAndSwapInt 方法进行CAS操作
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}

// 原子地将当前值加 delta 并返回旧值
public final int getAndAdd(int delta) {
    return unsafe.getAndAddInt(this, valueOffset, delta);
}

// 原子地将当前值加 1 并返回加之前的值（旧值）
// 使用 Unsafe#getAndAddInt 方法进行CAS操作。
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

// 原子地将当前值减 1 并返回减之前的值（旧值）
public final int getAndDecrement() {
    return unsafe.getAndAddInt(this, valueOffset, -1);
}
```
Unsafe#getAndAddInt源码：
```java
// 原子地获取并增加整数值
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        // 以 volatile 方式获取对象 o 在内存偏移量 offset 处的整数值
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    // 返回旧值
    return v;
}
```
可以看到，getAndAddInt 使用了 do-while 循环：在compareAndSwapInt操作失败时，会不断重试直到成功。也就是说，getAndAddInt方法会通过 compareAndSwapInt 方法来尝试更新 value 的值，如果更新失败（当前值在此期间被其他线程修改），它会重新获取当前值并再次尝试更新，直到操作成功。

由于 CAS 操作可能会因为并发冲突而失败，因此通常会与while循环搭配使用，在失败后不断重试，直到操作成功。这就是 **自旋锁机制** 。

## 2.2、Unsafe源码分析
通过源码分析，Unsafe类中的 CAS 方法是native方法。native关键字表明这些方法是用本地代码（通常是 C 或 C++）实现的。

### 2.2.1、Hotspot虚拟机源码
HotSpot 虚拟机的源码<code>unsafe.cpp</code>这个文件的 <code>Unsafe_CompareAndSwapInt</code>方法里
```cpp
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {
  oop p = JNIHandles::resolve(obj);
  if (p == NULL) {
    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);
    return RawAccess<>::atomic_cmpxchg(x, addr, e) == e;
  } else {
    assert_field_offset_sane(p, offset);
    return HeapAccess<>::atomic_cmpxchg_at(x, p, (ptrdiff_t)offset, e) == e;
  }
} UNSAFE_END
```
发现最终调用的是 <code>Atomic:: cmpxchg</code> 方法，这个根据不同操作系统和不同CPU会有不同的实现。


#### 2.2.1.1、Atomic:: cmpxchg
以x86架构为例，我们再找到 atomic_linux_x86.inline.hpp 这个文件
```cpp
#atomic_linux_x86.inline.hpp
inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
    //判断当前执行环境是否为多处理器环境
    int mp = os::is_MP();

    //LOCK_IF_MP(%4) 在多处理器环境下，为 cmpxchgl 指令添加 lock 前缀，以达到内存屏障的效果
    //cmpxchgl 指令是包含在 x86 架构及 IA-64 架构中的一个原子条件指令，
    //它会首先比较 dest 指针指向的内存值是否和 compare_value 的值相等，
    //如果相等，则双向交换 dest 与 exchange_value，否则就单方面地将 dest 指向的内存值交给exchange_value。
    //这条指令完成了整个 CAS 操作，因此它也被称为 CAS 指令。
    __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                    : "cc", "memory");
    return exchange_value;
}
```
- LOCK_IF_MP 是一个宏
  - 通常用于根据是否处于多处理器（Multi-Processor，MP）环境来决定是否加锁（比如使用 LOCK 前缀指令来锁定系统总线保证原子性等操作）
- 最终调用了一条汇编指令：cmpxchg 指令，来实现底层 cas 的。


##### cmpxchg
在 x86 架构中，cmpxchg指令是通过锁总线（Lock the Bus）或者使用缓存一致性协议（Cache - Coherence Protocol）来实现原子操作的。
- 锁总线机制
  - LOCK信号来锁定系统总线
- 缓存一致性协议
  - 例如，Intel 的 MESI（Modified、Exclusive、Shared、Invalid）协议

###### 缓存一致性协议的局限性
虽然cmpxchg指令在现代处理器中主要依靠缓存一致性协议（如 Intel 的 MESI 协议）来保证原子性，但在某些复杂的系统场景下，缓存一致性协议可能无法提供足够的保障。
例如，在一些较旧的 x86 处理器或者特殊的系统配置（如某些非标准的多处理器架构或带有特定硬件加速器的系统）中，缓存一致性协议的实现可能存在漏洞或者不完整。此时，仅仅依靠cmpxchg指令本身可能会出现数据竞争的情况，即多个处理器可能同时对同一内存位置进行操作，导致数据不一致。

###### 系统总线访问的竞争问题
当多个处理器同时试图访问系统总线来执行cmpxchg操作时，即使有缓存一致性协议，也可能会出现性能瓶颈或者竞争状况。


# 三、CAS存在的问题

## 3.1、ABA问题及其解决方案

### 3.1.1、什么是ABA问题？
当有多个线程对一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，此时其他线程不感知，还是会修改成功！

### 3.1.2、问题的影响
- 数据不一致：
- 逻辑错误：
- 性能下降：
- 调试困难：

具体示例：
> OPEN_OR_CLOSE 表示 保存高考卷的保险柜 开关，false表示close， true 表示 open，考虑下面的业务场景，
> 高考卷的保险柜，有且仅有两人有打开的权限。根据保密要求，人越少越好。当然，有且仅有一个人有权限，保密性更高，但是如果这人发生意外，就没人能打开保险柜
> 所以选两个人 既能照顾到保密性要求，又能减少突发事件的影响。
> 要求 2022-06-07 06:00:00 后，两个线程竞争去开保险柜，有且只有一人能打开，打开保险柜的人负责护送试题。（不考虑 synchronized 的实现方式）
> 假设这样的一种场景，张三、李四 竞争开柜的过程中，张三使手段让李四在开柜前，卡一下，确保自己能先开柜，然后拍照，获取试题，最后关上柜门
> 这个时候李四来开柜门，发现门的状态和教育部说的状态一样，都是close，然后李四拿走试题，张三过来说“李四啊，这次送试卷的任务就只能麻烦你了。”
> 然后 张三转手卖出试题，就算出了事情，教育厅也只能查李四。

<font color=green>**如果业务只关心Atomic系列类的值，不关心值的变化次数（ABA会增加两次操作），那么CAS导致的ABA问题就无需考虑**</font>，**例如卖票问题，你只关心总票数，不关心总票数波动的次数——别人退票后的票数增加或者其他人买票后票数减少。 反之，如果业务关心CAS的操作次数，例如本文的保险柜开关次数，就需要引入版本号解决ABA问题。**

<font color=red>某个对象，在某个状态只能被操作一次，即针对数值变化次数有要求，不是针对数值。</font>




### 3.1.3、解决方案
ABA 问题的解决思路是在变量前面追加上**版本号或者时间戳**。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决 ABA 问题的，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
```java
public class AtomicStampedReference<V> {
    public boolean compareAndSet(V expectedReference,
                                 V newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair<V> current = pair;
        return
                expectedReference == current.reference &&
                        expectedStamp == current.stamp &&
                        ((newReference == current.reference &&
                                newStamp == current.stamp) ||
                                casPair(current, Pair.of(newReference, newStamp)));
    }
}
```


## 3.2、循环时间长开销大
CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。

## 3.3、只能保证一个共享变量的原子操作
CAS 操作仅能对单个共享变量有效。当需要操作多个共享变量时，CAS 就显得无能为力。不过，从 JDK 1.5 开始，Java 提供了AtomicReference类，这使得我们能够保证引用对象之间的原子性。通过将多个变量封装在一个对象中，我们可以使用AtomicReference来执行 CAS 操作。除了 AtomicReference 这种方式之外，还可以利用加锁来保证。



参考文章：
[CAS 详解](https://javaguide.cn/java/concurrent/cas.html)