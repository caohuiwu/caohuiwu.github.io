---
title: tomcat请求过程
date: 2019-12-22 20:36:02
tags: Tomcat
---
# 一、一个请求的过程
1. socket 接收到连接请求，Accepter 将socket注册进Poller内。（生成PollerEvent，线程池，处理socket）
2. poller处理PollerEvent，创建SocketProcessor处理线程，将该处理线程放入Executor线程池内。
3. 线程执行，创建Processor去处理socket，processor会将socket处理成coyoteRequest.
4. adapter将coyoteRequest适配成HttpServletRequest
5. 然后调用管道进行传输，直到StandardWrapperValve
6. 然后获取到StandardWrapper【StandardWrapper的定义在读取web.xml时已经创建】
7. StandardWrapper通过servlet名称去反射创建servlet对象。
8. 然后调用servlet.init方法，进行servlet的初始化工作。

<!--more-->

# 二、如何找到请求的servlet？
```
public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)
        throws Exception {
    //将coyoteRequest转换成HttpServletRequest
    Request request = (Request) req.getNote(ADAPTER_NOTES);
    Response response = (Response) res.getNote(ADAPTER_NOTES);
    try {
        // Parse and set Catalina and configuration specific
        // request parameters
        //也就是在此处根据请求信息将制定的Host,Context,Wrapper实例对象封装到request实例中
        postParseSuccess = postParseRequest(req, request, res, response);
        // Calling the container
        //将request和response交给容器处理，最后到wrapper
        connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
```

## 2.1、StandardWrapperValve
```
public final void invoke(Request request, Response response)
    throws IOException, ServletException {
    // Initialize local variables we may need
    boolean unavailable = false;
    Throwable throwable = null;
    // This should be a Request attribute...
    long t1=System.currentTimeMillis();
    requestCount.incrementAndGet();
    StandardWrapper wrapper = (StandardWrapper) getContainer();
    Servlet servlet = null;
    Context context = (Context) wrapper.getParent();
    // Allocate a servlet instance to process this request
    try {
        if (!unavailable) {
            //调用wrapper.allocate去创建servlet，除load-on-starup类型的servlet，都是第一次请求来时去创建
            servlet = wrapper.allocate();
        }
    }
    
    // 创建过滤链
    ApplicationFilterChain filterChain =
        ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
    filterChain.doFilter(request.getRequest(),
        response.getResponse());

```
## 2.2、StandardWrapper
具体的servlet包装对象
```
public Servlet allocate() throws ServletException {
    // If not SingleThreadedModel, return the same instance every time
    if (!singleThreadModel) {
        // Load and initialize our instance if necessary
        if (instance == null || !instanceInitialized) {
            synchronized (this) {
                if (instance == null) {
                    try {
                        // Note: We don't know if the Servlet implements
                        // SingleThreadModel until we have loaded it.
                        instance = loadServlet();
                        newInstance = true;
                }
            }
        }
        
        
public synchronized Servlet loadServlet() throws ServletException {
    Servlet servlet;
    try {
        InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();
        try {
            //传入servlet名称，然后反射创建对象
            servlet = (Servlet) instanceManager.newInstance(servletClass);
        } catch (ClassCastException e) {
            unavailable(null);
            // Restore the context ClassLoader
            throw new ServletException
                (sm.getString("standardWrapper.notServlet", servletClass), e);
        } catch (Throwable e) {
        }
        //初始化对象
        initServlet(servlet);
    } finally {    }
    return servlet;
}        
        
private synchronized void initServlet(Servlet servlet)
        throws ServletException {
    // Call the initialization method of this servlet
    try {
        //调用具体Servlet的init方法进行实例化
        servlet.init(facade);
        }        
        
```


[参考](https://blog.csdn.net/qq_38975553/article/details/103434423)



