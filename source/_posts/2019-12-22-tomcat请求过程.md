---
title: 《tomcat》请求处理过程
date: 2019-12-22 20:36:02
categories:
  - [tomcat]
---

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>


# 一、请求的处理过程
1. socket 接收到连接请求，Accepter 将socket注册进Poller内。（生成PollerEvent，线程池，处理socket）
2. poller处理PollerEvent，创建SocketProcessor处理线程，将该处理线程放入Executor线程池内。
3. 线程执行，创建Processor去处理socket，processor会将socket处理成coyoteRequest.
4. adapter将coyoteRequest适配成HttpServletRequest
5. 然后调用管道进行传输，直到StandardWrapperValve
6. 然后获取到StandardWrapper【StandardWrapper的定义在读取web.xml时已经创建】
7. StandardWrapper通过servlet名称去反射创建servlet对象。
8. 然后调用servlet.init方法，进行servlet的初始化工作。

<!--more-->


# 二、请求处理过程
NioEndpoint作为终端，负责监听连接请求并做处理。其内部`SocketProcessor`是具体的处理逻辑，简化代码如下：
```java
protected class SocketProcessor extends SocketProcessorBase<NioChannel> {

    @Override
    protected void doRun() {
        NioChannel socket = socketWrapper.getSocket();
        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
        state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);
    }
}
```
- `getHandler()`：返回`ConnectionHandler`实例
- `process()`：调用`ConnectionHandler`的`process()`处理请求，具体流程如下：
  - **读取数据**：从`SocketChannel`读取HTTP请求。
  - **解析协议**：通过`Http11Processor`解析请求，生成`CoyoteRequest`和`CoyoteResponse`
  - **调用容器**：通过`CoyoteAdapter`将请求适配为标准`ServletRequest`，提交给Tomcat容器（如Catalina）处理

## 2.1、process()逻辑
代码简化后逻辑如下：
```java
protected static class ConnectionHandler<S> implements AbstractEndpoint.Handler<S> {
    @Override
    public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {
        state = processor.process(wrapper, status);
    }
}
```
追踪`processor.process(wrapper, status);`，进入下面的逻辑（代码简化后）：
```java
public abstract class AbstractProcessorLight implements Processor {
    @Override
    public SocketState process(SocketWrapperBase<?> socketWrapper, SocketEvent status)
            throws IOException {
        SocketState state = SocketState.CLOSED;
        Iterator<DispatchType> dispatches = null;
        do {
            state = service(socketWrapper);
        } while (state == SocketState.ASYNC_END ||
                dispatches != null && state != SocketState.CLOSED);

        return state;
    }
}
```
进入`Http11Processor.service()`
```java
public class Http11Processor extends AbstractProcessor {
    @Override
    public SocketState service(SocketWrapperBase<?> socketWrapper) throws IOException {
        RequestInfo rp = request.getRequestProcessor();
        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
        //重点：开始通过适配器处理请求了
        getAdapter().service(request, response);
    }
}
```
- getAdapter()：返回的`CoyoteAdapter`

```java
public class CoyoteAdapter implements Adapter {
    @Override
    public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)
            throws Exception {
        // 获取 servlet 需要的标准请求和响应
        Request request = (Request) req.getNote(ADAPTER_NOTES);
        Response response = (Response) res.getNote(ADAPTER_NOTES);

        //也就是在此处根据请求信息将制定的Host,Context,Wrapper实例对象封装到request实例中
        postParseSuccess = postParseRequest(req, request, res, response);
        // Calling the container
        //将request和response交给容器处理，最后到wrapper
        connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
    }
}
```

`postParseRequest()`方法，在 `Mapper` 中查询 `URL` 的映射关系
```java
connector.getService().getMapper().map(serverName, decodedURI, version, request.getMappingData());
```
把封装成的Request对象和响应的Response对象传递给Engine容器，然后获取他的管道，执行里面绑定的阀门value
```java
// 开始通过管道中的 Valve 处理请求
connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
```
按顺序执行多个阀门，实现对应的功能
```text
invoke: StandardWrapperValve
invoke: StandardContextValve
invoke: AuthenticatorBase
invoke: StandardHostValve
invoke: ErrorReportValve
invoke: AbstractAccessLogValve
invoke: StandardEngineValve
```
最后执行到`StandardWrapperValve.invoke`
```java
final class StandardWrapperValve extends ValveBase {
    @Override
    public final void invoke(Request request, Response response)
            throws IOException, ServletException {
        
        StandardWrapper wrapper = (StandardWrapper) getContainer();
        // Allocate a servlet instance to process this request
        try {
            if (!unavailable) {
                //调用wrapper.allocate去创建servlet，除load-on-starup类型的servlet，都是第一次请求来时去创建
                servlet = wrapper.allocate();
            }
        }
        // 创建FilterChain过滤器链，将Servlet封装到其中
        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
        filterChain.doFilter(request.getRequest(), response.getResponse());
    }
}
```

## 2.2、如何找到请求的servlet？
通过`StandardWrapper.allocate()`方法，获取`servlet`实例。不存在，去创建新的servlet.
```java
public Servlet allocate() throws ServletException {
    // If not SingleThreadedModel, return the same instance every time
    if (!singleThreadModel) {
        // Load and initialize our instance if necessary
        if (instance == null || !instanceInitialized) {
            synchronized (this) {
                if (instance == null) {
                    try {
                        instance = loadServlet();
                        newInstance = true;
                    }
                }
            }
        }
    }
}
```
追踪代码，进入`loadServlet()`方法
```java     
public synchronized Servlet loadServlet() throws ServletException {
    Servlet servlet;
    try {
        InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();
        try {
            //传入servlet名称，然后反射创建对象
            servlet = (Servlet) instanceManager.newInstance(servletClass);
        }
        //执行init()方法
        initServlet(servlet);
    } finally {    }
    return servlet;
}        
```
最后调用`servlet.init()`方法
```java
private synchronized void initServlet(Servlet servlet)
        throws ServletException {
    // Call the initialization method of this servlet
    try {
        //调用具体Servlet的init方法进行实例化
        servlet.init(facade);
    }
}
```

## 2.3、过滤器链的执行
- 调用过滤器链的`doFilter()`方法，执行过滤器链。
- 过滤器链会依次调用每个过滤器的`doFilter()`方法，最后调用`servlet.service()`方法处理请求。

定位到`ApplicationFilterChain.doFilter`，里面先是执行了Tomcat内置的过滤器，最后执行了`servlet.service`
```java
public final class ApplicationFilterChain implements FilterChain {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response)
            throws IOException, ServletException {
        internalDoFilter(request,response);
    }

    private void internalDoFilter(ServletRequest request,
                                  ServletResponse response)
            throws IOException, ServletException {

        Filter filter = filterConfig.getFilter();
        filter.doFilter(request, response, this);
        servlet.service(request, response);
    }
}
```

## 2.4、小结
```text
请求 -> NioEndpoint -> SocketProcessor.doRun() -> ConnectionHandler.process() -> AbstractProcessorLight.process()
-> Http11Processor.service() -> CoyoteAdapter.service() 
-> connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
-> valve.invoke()
-> servlet.service()
```

# 三、pipeline【管道】
```java
public abstract class ContainerBase extends LifecycleMBeanBase implements Container {
    //管道
    protected final Pipeline pipeline = new StandardPipeline(this);
    //添加阈门
    public synchronized void addValve(Valve valve) {
        //往管道中添加阈门
        pipeline.addValve(valve);
    }
}
```
四大容器类`StandardEngine，StandardHost，StandardContext, StandardWrapper`，都继承了`ContainerBase`，每个容器都有一个`pipeline`。
```java
public class StandardPipeline extends LifecycleBase implements Pipeline, Contained {
  @Override
  public void addValve(Valve valve) {
    // Add this Valve to the set associated with this Pipeline
    if (first == null) {
      first = valve;
      //形成链表
      valve.setNext(basic);
    } else {
      Valve current = first;
      while (current != null) {
        if (current.getNext() == basic) {
          current.setNext(valve);
          valve.setNext(basic);
          break;
        }
        current = current.getNext();
      }
    }
  }
}
```
`StandardPipeline`重写了`addValve()`方法，各pipeline内部valve形成链表。

# 四、valve【阀门】
`valve`（**阀门**）是请求处理流程中的核心组件之一，负责在请求到达目标资源（如`servlet`）之前或之后执行特定逻辑。`valve`以责任链模式串联，形成处理管道（`pipeline`），每个`valve`可以拦截、修改请求或响应，或记录日志等。

四大容器类`StandardEngine，StandardHost，StandardContext, StandardWrapper`都有各自缺省的标准`valve`实现。它们分别是
- **Engine**：`org.apache.catalina.core.StandardEngineValve`
- **Host**： `org.apache.catalina.core.StandardHostValve`
- **Context**：`org.apache.catalina.core.StandardContextValve`
- **Wrapper**：`org.apache.catalina.core.StandardWrapperValve`

`StandardEngine`的默认valve是在构造函数中添加的，其他容器一样的逻辑。
```java
public StandardEngine() {
    super();
    pipeline.setBasic(new StandardEngineValve());
    /* Set the jmvRoute using the system property jvmRoute */
    try {
        setJvmRoute(System.getProperty("jvmRoute"));
    } catch(Exception ex) {
        log.warn(sm.getString("standardEngine.jvmRouteFail"));
    }
    // By default, the engine will hold the reloading thread
    backgroundProcessorDelay = 10;
}
```

## 3.1、valve工作原理
```java
connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
```
- `connector.getService()`：获取当前Connector所属的service实例。
- `getService().getContainer()`：从service中获取其管理的顶层容器，即Engine。
- `getContainer().getPipeline()`：获取Engine容器的pipeline对象。
- `getPipeline().getFirst()`：获取pipeline中第一个自定义valve；未定义，返回基础valve。
- `getFirst().invoke`：除非第一个valve的`invoke()`方法，启动责任链处理流程。


## 3.2、pipeline与valve的执行顺序
假设Engine的pipeline配置如下：
```java
<Engine name="Catalina">
  <Valve className="com.example.Valve1" />
  <Valve className="com.example.Valve2" />
</Engine>
```
执行顺序
```text
Valve1.invoke() → Valve2.invoke() → StandardEngineValve.invoke() → Host 的 Pipeline
```

这里有2种valve：自定义valve和默认valve

### 3.2.1、自定义valve
自定义valve的实现通常遵循以下模式：
```java
public void invoke(Request request, Response response) {
  // 1. 执行当前 Valve 的逻辑（如记录日志）
  doSomething(request, response);
  // 2. 调用下一个 Valve
  getNext().invoke(request, response);
}
```

### 3.2.2、默认valve
默认valve的实现，以`StandardEngineValve`为例，触发子容器的pipeline的执行。
```java
public final void invoke(Request request, Response response) {
  // 1. 获取匹配的 Host 容器
  Host host = request.getHost();
  // 2. 调用 Host 的 Pipeline 的第一个 Valve
  host.getPipeline().getFirst().invoke(request, response);
}
```
由此，pipeline的链式执行已经分析完毕。

# 五、servlet的执行
常见的servlet，如springmvc的`DispatcherServlet`的类图如下：
- 实现了Servlet接口。
![DispatcherServlet](2019-12-22-tomcat请求过程/DispatcherServlet.png)

`HttpServlet`重写了`Servlet.service()`方法
```java
public abstract class HttpServlet extends GenericServlet {
    @Override
    public void service(ServletRequest req, ServletResponse res)
            throws ServletException, IOException {
        HttpServletRequest request;
        HttpServletResponse response;

        if (!(req instanceof HttpServletRequest &&
                res instanceof HttpServletResponse)) {
            throw new ServletException("non-HTTP request or response");
        }
        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;

        service(request, response);
    }
}
```


[参考](https://blog.csdn.net/qq_38975553/article/details/103434423)



