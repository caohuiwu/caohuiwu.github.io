---
title: 《mysql》innodb
date: 2020-08-05 11:19:31
categories:
  - [mysql]
tags:
  - [innodb]
---
<style>
.orange {
   color: orange
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>

    这是“mysql”系列的第二篇文章，主要介绍的是innodb存储引擎。

# 一、mysql

<code>MySQL</code> 是一种广泛使用的开源关系型数据库管理系统（`RDBMS--Relational Database Management System`）

<!-- more -->
基本结构：
![基本结构](2020-08-05-mysql-innodb/基本结构.png)

# 二、mysql存储引擎

`MySQL` 存储引擎是 `MySQL` 数据库管理系统中负责数据存储和检索的组件，不同的存储引擎具有不同的特点和适用场景。


**常见的存储引擎如下：**

| 存储引擎             |                                                            说明 |
|------------------|--------------------------------------------------------------|
| InnoDB           |                     5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢 |
| MyISAM           |                                      高速引擎，拥有较高的插入，查询速度，但不支持事务 |
| Memory           | 内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失 |
| MRG_MyISAM（MERGE） |                                    将多个表联合成一个表使用，在超大规模数据存储时很有用 |
| Falcon           |                               一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者 |
| Archive          |               将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作 |
| CSVCSV           |                             存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换) |

**InnoDB和MyISAM存储引擎区别：**

|       | InnoDB                    | MyISAM                       |
|-------|---------------------------|------------------------------|
| 存储文件  | .frm 表定义文件 .ibd 数据文件和索引文件 | .frm 表定义文件.myd 数据文件.myi 索引文件 |
| 锁     | 表锁、行锁                     | 表锁                           |
| 事务    | 支持                        | 不支持                          |
| CRDU  | 读、写                       | 读多                           |
| count | 扫表                        | 专门存储的地方                      |
| 索引结构  | B+ Tree                   | B+ Tree                      |


# 三、innodb架构
从下图中可见，InnoDB存储引擎由**内存池，后台线程和磁盘文件**三大部分组成。

| 架构                                                    | 简化后架构                                                      |
|-------------------------------------------------------|------------------------------------------------------------|
| ![innodb_架构图](2020-08-05-mysql-innodb/innodb_架构图.png) | ![innodb_架构图](2020-08-05-mysql-innodb/innodb_存储引擎体系架构.png) |


## 3.1、内存区域
![内存结构](2020-08-05-mysql-innodb/innodb_内存结构.png)
- <code>Buffer Pool</code> 缓冲区，放经常使用的**数据页和索引页**
- <code>Change Buffer</code> 修改缓冲区，对数据进行增删改操作时，先把数据放到这里
- <code>Log Buffer</code> 重做日志缓冲区，`redo log`, 保证数据库不丢失数据的重要环节，只要数据写入`redo log`成功，则认为更新成功。



## 3.2、文件区域
如下为真实示例：


| 整体结构                                    | Undo日志                                                         | 表空间                                              | redo日志                                                                        |
|-----------------------------------------|----------------------------------------------------------------|--------------------------------------------------|-------------------------------------------------------------------------------|
| ![文件](2020-08-05-mysql-innodb/磁盘文件.png) | ![文件](2020-08-05-mysql-innodb/磁盘文件2.png)                       | ![文件](2020-08-05-mysql-innodb/磁盘文件_表空间.png)      | ![文件](2020-08-05-mysql-innodb/磁盘文件_redo.png)                                  |
| 整体结构                                    | **系统表空间**：`ibdata1`文件，存储表结构、索引的定义等元数据；**回滚日志**：`undo_001, undo_002` | **用户表空间**：每一个表对应一个表空间（`*.ibd`文件）存储用户表的**数据以及索引** | **redo文件**：MySQL8版本，重做日志文件使用`#ib_redoN`命名约定，其中N是重做日志文件编号。备用重做日志文件由后缀表示`_tmp`。 |

总结如下：
![innodb_磁盘文件](2020-08-05-mysql-innodb/innodb_磁盘文件.png)
`InnoDB`的主要的磁盘文件主要分为三大块：
- 一是**系统表空间**：文件名：`ibdata1`
- 二是**用户表空间**：文件名：`*.ibd`
- 三是**redo日志文件和归档文件**：文件名：`ib_redo*`

> 二进制文件(binlog)等文件是`MySQL Server`层维护的文件，所以未列入InnoDB的磁盘文件中。


## 3.3、后台线程
**后台线程**的主要作用是负责刷新内存池中的数据，保证缓存中的数据是最新的。此外将已经修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常时**innodb**能够恢复到正常运行状态。

| 线程                | 描述                                                                                                 |
|-------------------|----------------------------------------------------------------------------------------------------|
| **master thread** | `master thread` 是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（insert buffer）、undo页的回收等。 |
| **IO thread**     | 在innodb中大量使用了`AIO（async io）`来处理写IO请求。而`IO thread`的工作主要是负责这些IO请求的回调（`call back`）处理。                 |
| **purge thread**  | 事务提交后，其所使用的`undo log`可能不再需要，因此需要`purge thread` 来回收已经使用并分配的`undo` 页。                                |

### 3.3.1. master thread
`Master Thread`主要流程伪代码如下
```c
void master_thread() {
    goto loop;
// 主循环
loop:
for(int i = 0; i < 10; i++) {
    // 每秒一次操作
    thread_sleep(1)
    // 日志缓冲刷新到磁盘，即使这个事务没提交
    do log buffer flush to disk
    // 合并插入缓冲（如果前一秒IO次数少于5次，InnoDB认为IO压力很小，执行该操作）
    if(last_one_second_ios < 5)
        do merge at most 5 insert buffer
    // 至多刷新100个InnoDB的脏页到磁盘（脏页比例超过innodb_max_dirty_pages_pct）   
    if(buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct)
        do buffer poll flush 100 dirty page
    // 没有用户活动，跳转到   backgroupo loop
    if(no user activity)
        goto backgroupo loop
}   
// 每10秒操作
// 刷新100个脏页到磁盘（过去10秒内IO操作小于200次）
if(last_ten_second_ios < 200)
    do buffer pool flush 100 dirty page
// 合并最多5个插入缓冲
do merge at most 5 insert buffer
// 合并最多5个插入缓冲
do log buffer flush to disk
// 删除无用的Undo页（最多20个undo页）
do full purge
//脏页比例超过innodb_max_dirty_pages_pct，刷新100个脏页到磁盘，否则刷新10个脏页
if(buf_get_modified_ratio_pct > 70%)
    do buffer pool flush 100 dirty page
else    
    do buffer pool flush 10 dirty page
goto loop

// 后台循环
backgroup loop:
// 删除无用的Undo
do full purge
// 合并20个插入缓冲
do merge 20 insert buffer
if not idel:
    goto loop
else 
    goto flush loop

// 刷新循环
flush loop:
// 刷新100个脏页到磁盘，直到脏页比例小于innodb_max_dirty_pages_pct
do buffer pool flush 100 dirty page
if(buf_get_modified_ratio_pct>innodb_max_dirty_pages_pct)
    goto flush loop
goto suspend loop

// 暂停循环
suspend loop:
// 暂停线程
suspend_thread()
// 等待事件
waiting event;
goto loop;  
}
```


# 四、InnoDB逻辑存储结构
`InnoDB`逻辑存储结构可分为五级：**表空间、段、区、页、行**

| 总结构                                                   | 表空间    | 段            | 区           | 页      | 行 |
|-------------------------------------------------------|--------|--------------|-------------|--------|---|
| ![innodb_表空间](2020-08-05-mysql-innodb/innodb_表空间.png) | 默认10MB | 初始1个区，每个段中的区对应的 XDES Entry 结构建立了三个链表 | 有64个页，默认1MB | 默认16Kb |   |



`innodb`是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。

真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差几个数量级，所以当我们想从表中获取某些记录时，<code>innodb</code> 存储引擎需要一条一条的把记录从磁盘上读取出来么？

不，那样会慢死，<code>innodb</code>采用的方式是：<font color=green>**将数据划分为若干个页，以`页`作为磁盘和内存之间交互的基本单位，`innodb`中页的大小一般为 <code>16KB</code>**</font>。也就是在一般情况下，一次最少从磁盘中读取<code>16KB</code>的内容到内存中，一次最少把内存中的<code>16KB</code>内容刷新到磁盘中。

## 4.1、innodb数据页结构
<code>页</code>的概念，是`innodb`管理存储空间的**基本单位**，一个页的大小一般是 <code>16KB</code>。可以理解是盛放记录的大盒子。


### 4.1.1、页的种类
`innodb`为了不同的目的设计了许多**不同类型的页**，比如
- 存放表空间头部信息的页
- 存放 <code>insert buffer</code> 信息的页
- 存放 <code>INODE</code> 信息的页
- 存放 <code>undo</code> 日志信息的页
- 存放记录的页 （**数据页**）


### 4.1.2、数据页结构
**数据页**代表的这块 `16KB` 大小的存储空间，可以划分为多个部分，不同部分有不同的功能，各个部分如图所示：
![innodb_数据页结构](2020-08-05-mysql-innodb/innodb_数据页结构.png)

#### 4.1.2.1、File header
文件头部，存放页的一些通用信息。常见的信息如下：

| 数据                                | 描述                                                                                                |
|-----------------------------------|---------------------------------------------------------------------------------------------------|
| **FIL_PAGE_OFFSET**               | 每一个页都有一个单独的页号，InnoDB 通过页号来唯一定位一个页。                                                                |
| **FIL_PAGE_SPACE_OR_CHKSUM**      | 这个代表当前页面的校验和（`checksum`），每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来。在一个页面被刷到磁盘的时候，首先被写入磁盘的就是这个 `checksum`。        |
| **FIL_PAGE_PREV 和 FIL_PAGE_NEXT** | 通过 `FIL_PAGE_PREV` 和 `FIL_PAGE_NEXT` 将上一页和下一页连起来，就形成了一个双向链表。这样就通过一个***双向链表***把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。 |
| **FIL_PAGE_TYPE**                 | 这个代表当前页的类型，InnoDB 为了不同的目的而设计了**许多种不同类型的页**。- **数据页（`Data Page`）**：用于存储实际的数据行。- **索引页（`Index Page`）**：用于存储索引信息，如主键索引或二级索引。- **系统页（`System Page`）**：包含系统表空间的一些元数据信息。- **事务数据页（`Transaction Data Page`）**：与事务处理相关的页。- **插入缓冲页（`Insert Buffer Page`）**：用于合并非聚集索引的插入操作。|

如图所示：数据页是有`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`着两个属性的，所以所有的**数据页其实是一个双向链表**。
![File_header](2020-08-05-mysql-innodb/File_header.png)

#### 4.1.2.2、Page Header
为了得到一个数据页中存储的记录的状态信息，比如本页中**已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等**，特意在页中定义了一个叫 `Page Header`的部分，是页的第二部分，占用固定的 `56` 个字节，专门存储各种状态信息。
![page_header](2020-08-05-mysql-innodb/page_header.png)
数据页专有的一些信息
- **PAGE_LEVEL**
  当前页在索引树中的位置，Ox00代表叶节点，叶节点总是在第0层
- **PAGE_N_HEAP**
  本页中的记录的数量，包括**最小记录**（`Infimum`）和**最大记录**（`Supremum`）以及标记为删除（`delete_mask=1`）的记录

#### 4.1.2.3、Infimum + supermum
**最小记录**和**最大记录**：两个虚拟的行记录
- 最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。
- 最小记录是数据页上最小的记录，所有用户记录都大于它。

他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。

#### 4.1.2.4、user records + Free space
存储的记录会按照我们指定的 **行格式** 存储到 <code>User Records</code> 区域。

但是在一开始生成页的时候，其实并没有 <code>User Records</code>区域，每当我们插入一条记录，都会从 <code>Free Space</code>（也就是尚未使用的存储空间）中申请一个记录大小的空间划分到<code>User Records</code>。

当所有的 <code>Free Space</code> 使用完后，意味着这个页使用完了，如果插入新的数据，则需要去申请新的页了。

##### 1. 如何管理 <code>User Records</code>中的记录
之前的innodb**行格式**章节中介绍了行记录的记录头信息，如下图：
![innodb_行记录_记录头](2020-08-05-mysql-innodb/innodb_行记录_记录头.png)
###### delete_mask
- 这个属性标记着当前记录是否被删除，占用1个二进制位，值为 `0` 的时候代表记录并没有被删除，为 `1` 的时候代表记录被删除掉了。
- 啥？被删除的记录还在 页 中么？是的，摆在台面上的和背地里做的可能大相径庭，你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的 垃圾链表，在这个链表中的记录占用的空间称之为 “可重用空间”，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

###### min_rec_mask
B+树的每层**非叶子节点**中最小记录都会添加该标记

###### heap_no
这个属性表示当前记录在本页中的位置。

###### next_record
非常重要，表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的`next_record`值为`32`，意味着从第一条记录的真实数据的地址处向后找`32字节`便是下一条记录的真实数据。
![innodb_行记录_链表](2020-08-05-mysql-innodb/innodb_行记录_链表.png)
从图中可以看到，记录按照主键从小到大的顺序形成了一个**单链表**。最大记录的`next_record=0`，也就是说没有下一条记录了。

> tips：会不会觉得`next_record`这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置？也就是记录的额外信息开头的位置呢？
>
> 因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。可能会提高高速缓存的命中率。

<code class='red'>存在的问题</code>：单链表查找数据，时间复杂度为O(n)，随着数据越来越多，性能会越来越差。怎么解决呢？
> 通过`next_record`这个指针，将页中的数据**小到大顺序串联成了一个单链表**，那如果我们想根据主键值查找页中的某条记录该咋办呢？
> 比如查询语句 <code>select * from table where c1 = 3;</code>
>
> **最笨的方法**：从 `Infimum` 记录（最小记录）开始，沿着链表一直往后找，总有一天会找到。这个方法在页中存储的记录数量比较少的情况没啥问题，但是如果一个页中存储了非常多的记录，那么性能有损耗。
> 
> _**优化：**_
> 平常我们想从一本书中查找某个内容，一般会先看**目录**，找对需要查找的内容对应的**页码**，然后到对应的**页码**查看内容。优化方向就是制作一个类似的目录。所以引入了**页目录（Page Directory）**。


#### 4.1.2.5、Page Directory【页目录】
`Page directory（页目录）`是Innodb中数据页的核心结构之一，用于加速记录的查找和管理。它通过<code class='red'>将记录划分成多个组，并为每个组维护一个“槽（Slot）”</code>，实现高效的二分查找。

##### 1. 作用
- **快速定位记录**：通过`槽（Slot）`和`分组机制`，将记录划分为多个组，减少查找范围。
- **支持二分查找**：结合`Page Directory `和 `Page Header`（存储槽（`Slot`）的数量），实现类似二分查找的高效检索。
- **管理记录分组**：通过 `n_owned` 属性维护每个组的记录数量，优化插入和删除操作。


##### 2. 工作原理
`Page Directory`将数据页中的记录划分为若干个槽。每个槽（`Slot`）对应着页中的一组记录。

如下图所示：总共`16`条数据，分成`5`个槽，每个槽`4`条记录
![page_directory](2020-08-05-mysql-innodb/page_directory.png)
- 可以看到，页中的数据经过分组后在 `Page Directory` 中就形成了一个**目录槽**，每个槽就指向了分组中的最大记录，最大记录的记录头中的 `n_owned` 就记录了这个组中的记录数。
- 有了目录槽之后，`InnoDB`就会利用**二叉查找**迅速确定记录所在的槽，并找到该槽所在分组中主键值最小的那条记录，再通过最小记录的 `next_record` 遍历记录，就能快速定位到匹配的那条记录了。

##### 3. 查找过程
现在来看怎么从这个 **“页目录”** 中查找记录。

上图中有4个槽，编号分别是`0、1、2、3、4`。比如说我们想找主键值为`6`的记录，过程是这样的：
1. **计算中间槽的位置**：`（0+4）/2=2`，所以查找 `槽2` 对应的主键值为`8`，又因为 `8>6`，所以设置 `high=2`，`low`保持不变。
2. **重新计算中间槽的位置**：`(0+2)/2=1`，所以查看 `槽1` 对应的主键值为`4`， 又因为 `4<6`，所以设置 `low=1`，`high`保持不变。
3. 因为 `high-low=1`，所以确定主键值为`5`的记录在 `槽2` 对应的组中。此刻我们需要找到 `槽2` 中主键值最小的那条记录，然后沿着单向链表遍历 `槽2` 中的记录。



#### 4.1.2.6、数据页小结
1. 每个数据页的`File Header` 部分都有**上一个**和**下一个页**的编号，所以所有的数据页会组成一个**双向链表**。
2. 每个记录的头信息中都有一个`next_record`属性，从而使页中的所有记录串联成一个 **单链表**。
1. 为了**提高单链表的查询效率**，页中引入了 “`page dictory`（页目录）”，通过**二分查找**提高查询效率。


#### 4.1.2.7、多个数据页如何查询
示例如下：B+树的**叶子节点**，组成一个**双向链表**
![数据页查询](2020-08-05-mysql-innodb/数据页查询.png)
如果我们要查找 `ID=32` 的这行数据，那流程是怎么样的呢？
> 具体流程，查看后面的索引文章。


既然解析了**页**，那接下来解析页中的记录。

## 4.2、innodb 行数据（记录）
我们平常是以**记录**为单位来向表中插入数据的，这些记录**在磁盘上的存放方式**也被称为 <font color=green>**行格式**</font> 或者 <font color=green>**记录格式**</font>。

innodb存储引擎有4种不同类型的行格式：
- compact
- redundant
- dynamic
- compressed

### 4.2.1、如何设置行格式？
```
CREATE TABLE 表 (
...
)ROW_FORMST=COMPACT
```

### 4.2.2、compact行格式
![innodb_compact_行格式](2020-08-05-mysql-innodb/innodb_compact_行格式.png)
一条完整的记录，其实可以分为 “**记录的额外信息**” 和 “**记录的真实数据**” 两大部分。

#### 4.2.2.1、额外信息
额外信息分为3类：
- 变长字段长度列表
- NULL值列表
- 记录头信息

##### 1. 变长字段长度表
对于像 `varchar， varbinary，text，blob，json`以及他们的各种类型的可变长度字段【可称为变长字段】，需要将他们到底占用多少字节存储起来，这样就省去了列数据之间的边界定义，MySQL 就可以分清楚哪些数据属于这一列，哪些不属于。

所以这些变长字段占用的存储空间分为两部分：
1. 真正的数据内容。
2. 占用的字节数。

在`compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序<font color=green>**逆序存放**</font>。


##### 2. NUll值列表
`NULL`值列表（`NULL Value list`），这个列表是行记录的一部分，用于优化存储空间和提高查询效率。

作用：
- **标识NULL列**：对于允许 NULL的列，如果某一行的该列值为NULL，则不需要实际存储NULL值，而是通过NULL值列表中的位(bit)来标识。
- **节省空间**：通过位图的方式存储NULL值信息，避免了为每个NULL值分配额外的存储空间。

##### 3. 记录头信息
记录头固定为5字节大小：
![innodb_compact_记录头](2020-08-05-mysql-innodb/innodb_compact_记录头.png)
```
无用位 2   目前没用到
deleted_flag   1     记录是否被删除
min_rec_flag  1     B+树中非叶子节点最小记录标记
n_owned         4    该记录对应槽所拥有记录数量
heap_no          13   该记录在堆中的序号，也可以理解为在堆中的位置信息
record_type     3    记录类型，普通数据记录为000，节点指针类型为001，伪记录首记录 infimum 行为010，伪记录最后一个记录 supremum 行为011，1xx的为保留的
next_record pointer    16     页中下一条记录的相对位置
```
- delted_flag
  被删除的记录还在数据页中，不立即删除是因为移除删除数据后需要对其他在磁盘中的数据重新排列回导致性能消耗，所以只是打了一个删除标记。
  所有被删除的记录都会组成一个 垃圾链表，在链表中的记录占用的空间称为“可重用空间”，之后如果有新记录插入到表中的话，可能会将被占用的存储空间覆盖掉。
- record_type
  - 0：普通记录
  - 2：最小记录
  - 3：最大记录
  - 1：目录项记录（索引）



#### 4.2.2.2、真实数据

##### 1. 隐藏列
mysql会为每个记录默认的添加一些列（也称为 隐藏列），具体的列如下：

- `DB_ROW_ID`
  - 6字节
  - 主键ID，这个列不一定会生成。优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则会为表默认添加一个名为 DB_ROW_ID 的隐藏列作为主键
- `DB_TRX_ID`
  - 6字节
  - 产生当前记录项的事务id，每开始一个新的事务时，系统版本号会自动递增，而事务开始时刻的系统版本号会作为事务id，事务 commit 的话，就会更新这里的 DB_TRX_ID
- `DB_ROLL_PTR`
  - 7字节
  - undo log 指针，指向当前记录项的 undo log，找之前版本的数据需通过此指针。如果事务回滚的话，则从 undo Log 中把原始值读取出来再放到记录中去


#### 4.2.2.3、示例：
```
+-------+------------+------+----------+------------------+
| id    | score      | name | content  | extra            |
+-------+------------+------+----------+------------------+
|     1 |       78.5 | hash | wodetian | nidetiantadetian |
+-------+------------+------+----------+------------------+
```
有两个数据不为NULL的字段
- `content`：长度分别是 8。转换为 16 进制分别是：0x08
- `extra`：长度分别是 16，转换为 16 进制分别是：0x10。

倒序的顺序排列就是10 08
```
变长字段长度列表：10 08
Null值列表：00
记录头信息：00 00 10 00 47
隐藏列DB_ROW_ID：00 00 00 00 08 0c
隐藏列DB_TRX_ID：00 00 00 03 c9 4d
隐藏列DB_ROLL_PTR：b9 00 00 01 2d 01 10
列数据id(1)：80 00 00 00 00 00 00 01
列数据score(78.5)：00 00 00 00 00 a0 53 40
列数据name(hash)：68 61 73 68
列数据content(wodetian)：77 6f 64 65 74 69 61 6e
列数据extra(nidetiantadetian)：6e 69 64 65 74 69 61 6e 74 61 64 65 74 69 61 6e
```


### 4.2.3、redundant行格式
这个是最古老的，最简单粗暴的行格式了，现在基本上已经不用了，因为占用空间最多，从而导致内存碎片化最严重，是最低效的行格式了。
![innodb_redundant_行格式](2020-08-05-mysql-innodb/innodb_redundant_行格式.png)




## 4.3、表空间
**表空间**（`Tablespace`）是一个逻辑概念，它是用来管理存储在硬盘上的表数据和索引数据的容器。

### 4.3.1、为什么需要表空间？
主要是为了组织和管理数据库的数据，提高存储和查询效率，以及方便数据库的维护和恢复。

### 4.3.2、表空间结构
`innodb` 是使用 **“页”** 为基本单位来管理存储空间的，默认的大小为 `16KB`。为了管理这些页，`innodb` 提出了一个 “**表空间**” 或者 “**文件空间**”（英文名：`table space` 或者 `file space`）的概念。

这个**表空间**是一个抽象的概念，它可以对应文件系统上**一个或多个真实文件**。每一个 “表空间” 可以被划分为很多很多很多个 “页”，我们的表数据就存放在某个 “**表空间**” 下的某些页里。

|     | 系统表空间                                                                                                                                                                          | 独立表空间                                                                                           |
|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| 文件  | `ibdata1`文件                                                                                                                                                                    | `.ibd`文件                                                                                        |
| 开启  |                                                                                                                                                                                | `innodb_file_per_table`：控制每个表是否使用独立的表空间文件，`MySQL5.6.6` 以及之后的版本中默认启用。开启时，元数据仍然存储在共享表空间（如ibdata1） |
| 作用  | 存储`数据字典（Data Dictionary）`：存储所有表、索引的元数据（如表结构、列定义、索引类型等）；`双写缓冲区（DoubleWrite Buffer）`：用于崩溃恢复时防止页损坏；`变更缓冲区（Change buffer）`：缓存对非唯一索引的更新操作；`回滚段（Rollback Segments)`：存储事务的回滚信息，支持MVCC | 每个表有独立的`.ibd`文件，存储该表的**数据和索引**。                                                                 |
| 结构  | ![innodb_系统表空间结构](2020-08-05-mysql-innodb/innodb_系统表空间结构.png)                                                                                                                  | ![innodb_独立表空间结构](2020-08-05-mysql-innodb/innodb_独立表空间结构.png)                                   |
| 优点  | 集中管理                                                                                                                                                                           | 允许独立备份、恢复和迁移表。减少系统表空间负载，便于管理单个表的碎片                                                              |
| 缺点  | 文件过大，难以独立备份或迁移，易产生I/O瓶颈                                                                                                                                                        | 文件数量过多，影响维护效率                                                                                   |

**元数据的定义**
- 表名、列名、数据类型。
- 索引的定义（如主键、唯一索引）
- 表空间的分配信息（如.ibd文件的路径）
- 事务和锁的信息。

### 4.3.3、系统表空间 & 独立表空间
从上文可以看到，系统表空间和独立表空间的前`3个页`的类型都是一样的（`FSP_HDR, IBUF_BITMAP, INODE`），只是 `3~7` 的页是系统表空间独有的。
![innodb_系统表空间_独有结构](2020-08-05-mysql-innodb/innodb_系统表空间_独有结构.png)


### 4.3.3、表空间数据解析
通过 `ibdNinja`工具解析 `ibdata` 文件，并查看其中的表数据。假设目标数据库为 `mydb`，表名为 `mytable`，且 `ibdata` 文件路径为 `/var/lib/mysql/ibdata1`


|    | 表信息                                                  | Page信息                                                                                                     | Record信息                                                                                                                                              |
|----|------------------------------------------------------|------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| 命令 | `./ibdNinja -f /var/lib/mysql/ibdata1 --list-tables` | `./ibdNinja -f /var/lib/mysql/ibdata1 --parse-page 7`                                                      |                                                                                                                                                       |
| 信息 | ![表信息](2020-08-05-mysql-innodb/表空间_表信息.png)          | ![Page信息](2020-08-05-mysql-innodb/表空间_page.png)                                                            | ![Page信息](2020-08-05-mysql-innodb/表空间_records.png)                                                                                                    |
| 描述 | ibd文件包含的所有表的表ID及表名                                                     | 比如`slibling pages no` 可以知道该`page`的左及右`page no`，`Belongs to`可以知道该`page`数据那个索引，`Page leve`可以知道该`Page`所处的层数等等 | `Length`是`89B`，其中`header`是`11B`，`body`是`78B`，包含`10`个fields，然后是`Header`的`11`个字节的`16`进制打印，接着是每一个`field`的详细信息，如`name`，`length`，`type`及`16`进制的详细`value`打印 |




## 4.4、段（segment）
**表空间**是由各个段组成的，常见的段有
- **数据段**：存储表的行数据（如主键索引的数据页）
- **索引段**：存储索引的叶子节点和非叶子节点。
- **回滚段**：存储事务的回滚信息（用于MVCC）

一个**段**的空间大小是随着表的大小自动扩展的：表有多大，段就有多大。

一个段会包含多个区，至少会有一个区，段扩展的最小单位是区。

### 4.4.1、为什么需要段？

#### 4.4.1.1、B+ 树索引的结构特点
- `B+` 树的叶子节点存储的是实际数据，而非叶子节点存储的是索引键值和指针。
- 如果不区分**叶子节点**和**非叶子节点**的存储，会导致以下问题：
  - **查询性能下降**：范围查询需要扫描所有节点，而非叶子节点可能包含大量冗余的索引键值。
  - **空间利用率低**：非叶子节点的存储需求与叶子节点不同，混合存储可能导致碎片化。

解决方案
- 为每个索引创建两个段：
  - 叶子节点段（Leaf Segment）：存储B+ 树的叶子节点（实际数据）
  - 非叶子节点段（Non-leaf Segment）：存储B+ 树的非叶子节点（索引键值和指针）
- 通过这种分离，Innodb 可以针对不同类型的节点进行优化存储和访问。


#### 4.4.1.2、提高存储空间管理效率
- `区`（Extent）的局限性
  - 区是连续的 `64` 个页（默认`1MB`），但直接按区分配存储可能导致以下问题
    - **空间浪费**：如果某个索引需要频繁扩展，按区分配可能导致区未被充分利用。
    - **碎片化**：频繁的插入/删除操作可能导致页分散，降低I/O性能。


### 4.4.2、段的结构
`InnoDB` 为**每个段**都定义了一个 `INODE Entry` 结构来记录**段**中的属性。
![INODE Entry结构示意图](2020-08-05-mysql-innodb/innodb_段_结构.png)

|                   | 描述                                                                                                                   |
|-------------------|----------------------------------------------------------------------------------------------------------------------|
| **Segment ID**        | 就是指这个 INODE Entry 结构对应的段的编号（ID）。                                                                                     |
| **NOT_FULL_N_USED**   | 这个字段指的是在 `NOT_FULL` 链表中已经使用了多少个页面。下次从 NOT_FULL 链表分配空闲页面时可以直接根据这个字段的值定位到。而不用从链表中的第一个页面开始遍历着寻找空闲页面。                      |
| **List Base Node**    | 分别为段的 `FREE` 链表、 `NOT_FULL` 链表、 FULL 链表定义了 List Base Node ，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的 List Base Node 。 |
| **Magic Number**      | 这个值是用来标记这个 `INODE Entry` 是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个数字是值的 97937874 ，表明该 INODE Entry 已经初始化，否则没有被初始化。           |
| **Fragment Array Entry** | 每个 `Fragment Array Entry` 结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。                                                        |

#### 4.4.2.1、段链表
`InnoDB` 为每个段中的区对应的 `XDES Entry` 结构建立了三个链表：

|           | 描述                                                                                   |
|-----------|--------------------------------------------------------------------------------------|
| FREE 链表   | 同一个段中，所有页面都是空闲的区对应的 `XDES Entry` 结构会被加入到这个链表。注意和直属于表空间的FREE链表区别开了，此处的 FREE 链表是附属于某个段的。 |
| NOT_FULL 链表 | 同一个段中，仍有空闲空间的区对应的 `XDES Entry` 结构会被加入到这个链表。                                            |
| FULL 链表   | 同一个段中，已经没有空闲空间的区对应的 XDES Entry 结构会被加入到这个链表。                                          |

每个段都会维护上述的三个链表。

## 4.3、区（extent）
表空间中的页实在是太多了，为了更好的管理这些页面，innodb提出了<code>区（英文名：extent）</code>的概念。
- 对于 `16KB` 的页来说，连续的`64个页`就是一个 **区**，也就是说一个区默认占用`1MB`空间大小。 `区 = 64 * 页（1M = 64 * 16KB）`

### 4.3.1、为什么引入区？
当数据量非常多的时候，如果链表中**相邻的两个页**物理位置离得非常远（<font color=gray>**页会组成一个双向链表，具体查看后续的索引章节**</font>），就是所谓的“随机I/O”，效率很低。

所以为了<code class='red'>尽量让链表中相邻的页的物理位置也相邻</code>，这样进行范围查询的时候才可以使用所谓的 “顺序I/O”，所以才引入了 <code>区（英文名：extent）</code>的概念。
> 一个区中的页，在物理空间中是连续的，所以在读取时可以减少随机 IO 的次数，从而提高读取速度。

当表中的数据量大的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照 **区** 为单位分配。

### 4.3.2、区的结构
`innodb`设计了一个称为 `XDES Entry`的结构（全称就是 `Extent Descriptor Entry`），每一个区对应着一个`XDES Entry`结构。
![innodb_区_结构](2020-08-05-mysql-innodb/innodb_区_结构.png)
- `Segment ID`：每一个段都有一个唯一的 ID。`Segment ID` 字段表示该区所在的段，前提是该区已经被分配给某个段了，不然该字段的值没有意义；
- `ListNode`：这个部分可以将若干个 `XDES Entry` 结构串联成一个双向链表；
- `State`：区的状态，总共有四种类型。处于 `FREE、FREE_FRAG、FULL_FRAG` 这三种状态的区都是独立的，算是直属于表空间；而处于 `FSEG` 状态的区是附属于某个段的：
  - `FREE`，空闲的区：现在还没有用到这个区中的任何页面；
  - `FREE_FRAG`，有剩余空间的碎片区：表示碎片区中还有可用的页面；
  - `FULL_FRAG`，没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面；
  - `FSEG`，附属于某个段的区：每一个索引都可以分为叶子节点段和非叶子节点段，除此之外 InnoDB 还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。
- `Page State Bitmap`：这个部分共占用 `16` 字节，也就是 `128` 位，一个区默认有 `64` 个页，这 `128` 位被划分为 `64` 个部分，每个部分有 `2` 位，对应区中的 `1` 个页。第一个位表示对应的页是否是空闲的，第二个比特位还没有用。




# 五、innodb内存结构
![innodb_内存结构](2020-08-05-mysql-innodb/innodb_内存结构.png)

## 5.1、缓冲池（buffer pool）
缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。
- 在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“fix”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。
- 对数据库页的修改操作，首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘上。

缓存池中缓存的数据页类型有：索引页、数据页、undo 页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、innodb存储的锁信息（lock info）、数据字典信息（data dictionary）等。

## 5.2、LRU list、Free List 和 Flush List
如果对内存区域进行管理的呢？

通常来说，数据库中的缓冲池是通过 `LRU（latest recent used`，最近最少使用）算法来进行管理的。

## 5.3、重做日志缓存（redo log buffer）
`redo log`是一个顺序写的日志文件，符合`WAL(Write Ahead Log)`模式。顺序写比随机写效率高很多。`redo log`暂存已经提交成功的数据。若系统崩溃，可以使用`redo log` 恢复数据。

`redo log` 是一个缓冲区，定时将缓冲区的数据保存到磁盘。默认`1`秒保存一次。默认在执行`commit`操作之前刷新`redo log buffer`。
![innodb_redolog_buffer](2020-08-05-mysql-innodb/innodb_redolog_buffer.png)
如上图所示，`InnoDB`在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合`Force-log-at-commit`原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据`checkpoint`机制择时写入到磁盘中，这符 合`WAL`原则。

在通常情况下，`8MB` 的`redo log buffer`缓冲池足以满足绝大部分的应用，因为重做日志在下列三种情况下会将`redo log buffer`内容刷新到磁盘的`redo log`文件中
- `master thread` 每一秒将`redo log buffer`刷新到`redo log `磁盘文件。
- 每个事务`commit`时，将`redo log buffer`刷新到`redo log` 磁盘文件。
- 当`redo log buffer`剩余空间小于 `1/2` 时，将`redo log buffer`刷新到`redo log` 磁盘文件。

InnoDB的<code>innodb_flush_log_at_trx_commit</code>属性可以控制每次事务提交时InnoDB的行为。
- 当属性值为`0`时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入每秒写入一次；
- 当属性值为`1`时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync(操作系统的一个函数，调用此函数，操作系统会立即执行刷盘操作，将缓冲区的数据刷新到磁盘)，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；
- 当属性值为`2`时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用`fsync`，而是让文件系统自己去判断何时将缓存写入磁盘

<code>redo log </code>的刷盘机制如下图所示：
![innodb_redolog_刷盘](2020-08-05-mysql-innodb/innodb_redolog_刷盘.png)

## 5.4、自适应哈希索引
InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。

## 5.5、锁信息
我们都知道，InnoDB存储引擎会在行级别上对表数据进行上锁。不过InnoDB也会在数据库内部其他很多地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。

## 5.6、内存数据刷盘
InnoDB内存缓冲池中的数据page要完成持久化的话，是通过两个流程来完成的：
- 一个是脏页落盘；
- 一个是预写redo log日志。

当缓冲池中的页的版本比磁盘要新时，数据库需要将新版本的页从缓冲池刷新到磁盘。但是如果每次一个页发送变化，就进行刷新，那么性能开发是非常大的，于是InnoDB采用了<code>Write Ahead Log（WAL）</code>策略和<code>Force Log at Commit</code>机制实现事务级别下数据的持久性。
- WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；
- `Force-log-at-commit`要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。

为了确保每次日志都写入到重做日志文件，在每次将重做日志缓冲写入重做日志后，必须调用一次<code>fsync</code>操作，将缓冲文件从文件系统缓存中真正写入磁盘。可以通过 <code>innodb_flush_log_at_trx_commit</code> 来控制重做日志刷新到磁盘的策略。

> 脏页：指的是在内存中已被修改但尚未写回磁盘的数据页。

## 5.7、double write
`double write`（两次写）带给innodb存储引擎的是数据页的可靠性。

当发生数据库宕机时，可能innodb正在写入某个页到表中，而这个页只写了一部分（比如`16KB`的页，只写了前`4KB`），之后就宕机，这种情况称之为部分写失效（`partial page write`）。在`innodb`未使用 `double write`技术前，曾经出现过因为部分写失效而导致数据丢失的情况。

### 5.7.1、定义
在应用（`apply`）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是`double write`。

`double write`由两部分组成
- 一部分是内存中的`double write buffer`，大小为 `2MB`
- 另一部分是物理磁盘上共享表空间中连续的`128`个页，即`2个区（extent）`，大小同样为 `2MB`。

在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过`memcpy`函数将脏页先复制到内存中的`double write buffer`，之后再通过`double write buffer`再分两次，每次`1MB`顺序的写入共享表空间的物理磁盘上，然后马上调用`fsync`函数同步磁盘。
![innodb_doublewrite](2020-08-05-mysql-innodb/innodb_doublewrite.png)


查看完整：
[InnoDB存储引擎架构详解](https://juejin.cn/post/6914672970866622471)
[ibdNinja：MySQL 8.0 数据文件(.ibd)解析、分析工具](https://zhuanlan.zhihu.com/p/16505194635)