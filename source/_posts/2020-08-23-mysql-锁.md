---
title: 《mysql》锁
date: 2020-08-23 12:09:31
categories:
  - [mysql]
tags:
  - [锁]
---

    这是“mysql”系列的第八篇文章，主要介绍的是锁。

<style>
.my-code {
   color: green;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
</style>

# 一、mysql

<code>MySQL</code> 是一种广泛使用的开源关系型数据库管理系统（RDBMS--Relational Database Management System）

<!-- more -->


# 二、锁

在 MySQL 中，锁是用于控制并发访问的重要机制，它可以保证数据的一致性和完整性，避免多个事务同时对同一数据进行修改而产生冲突。下面从锁的类型、使用场景等方面详细介绍
MySQL 锁。

## 2.1、锁的分类

MySQL锁可以按模式分类为：乐观锁与悲观锁。按粒度分可以分为全局锁、表级锁、页级锁、行级锁。按属性可以分为：共享锁、排它锁。按状态分为：意向共享锁、意向排它锁。按算法分为：间隙锁、临键锁、记录锁。

### 2.1.1、按模式分类

在 MySQL 中，按模式对锁进行分类，主要分为乐观锁和悲观锁，这里的 “模式” 指的是对待数据并发访问时的<code class='orange'>**不同态度和处理策略**</code>。

#### 2.1.1.1、乐观锁

##### （1）模式特点

乐观锁秉持乐观的态度，假设在大多数情况下，多个事务对数据的并发操作不会产生冲突。因此，在操作数据时，它不会立即对数据加锁，而是在更新数据的最后阶段，检查数据是否在自己读取之后被其他事务修改过。如果没有被修改，则正常更新数据；如果被修改了，则说明发生了冲突，此时需要回滚操作或者重试。

##### (2) 应用场景

适用于读多写少，因为如果出现大量的写操作，写冲突的可能性就会增大，业务层需要不断重试，会大大降低系统性能。

##### (3) 实现方式

一般使用数据版本（Version）记录机制实现，在数据库表中增加一个数字类型的“version”字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

示例代码：

```
-- 假设表中有 id、name 和 version 字段
-- 读取数据时获取版本号
SELECT id, name, version FROM users WHERE id = 1;
-- 更新数据时检查版本号
UPDATE users 
SET name = 'new_name', version = version + 1 
WHERE id = 1 AND version = [之前读取的版本号];
```

##### （4）实战

商户表中id, status,version分别代表商户ID，状态，版本号。

1. 查询商户信息
   select id,status,version from place where id=#{id};
2. 用户支付成功
3. 修改订单状态
   update set status="close",version=version+1 where id=#{id} and version=#{ version};

#### 2.1.1.2、悲观锁

##### （1）模式特点

悲观锁则持悲观的态度，认为在并发环境下，多个事务对数据的操作很可能会产生冲突。因此，在操作数据之前，它会先对数据加锁，防止其他事务对该数据进行修改，直到当前事务完成操作并释放锁。这样可以确保数据在被操作期间不会被其他事务干扰，保证了数据的一致性和完整性。

##### (2) 应用场景

适用于写多的场景，或者对数据一致性要求较高的场景。例如，在银行转账业务中，涉及到资金的增减操作，必须保证数据的一致性，此时使用悲观锁可以防止出现数据不一致的问题。但悲观锁会增加锁的开销，降低系统的并发性能。

##### (3) 实现方式

在 MySQL 中，主要通过使用共享锁（SELECT ... LOCK IN SHARE MODE）和 排他锁（SELECT ... FOR
UPDATE）来实现悲观锁。当一个事务获取了共享锁或排他锁后，其他事务需要等待该锁释放才能对同一数据进行相应的操作。

示例代码：

```
-- 使用排他锁更新数据
START TRANSACTION;
SELECT * FROM products WHERE product_id = 1 FOR UPDATE;
UPDATE products SET stock = stock - 1 WHERE product_id = 1;
COMMIT;
```

##### （4）实战

订单数据的更新，使用悲观锁。

1. 查询订单信息
   select id,status,version from order where id=#{id} FOR UPDATE;
2. 用户支付成功
3. 修改订单状态
   update set status="pay" where id=#{id};

### 2.1.2、按粒度分类

在 MySQL 中，按锁的粒度分类，可分为全局锁、表级锁、页级锁和行级锁，不同粒度的锁在加锁范围、加锁开销、并发性能等方面存在差异。

#### 2.1.2.1、全局锁

##### （1）概念

全局锁会对整个数据库实例进行锁定，当一个事务获取全局锁后，整个数据库就只能进行读操作，其他任何的写操作（如插入、更新、删除）以及创建、修改表结构等操作都将被阻塞，直到全局锁被释放。

##### （2）使用场景

主要用于数据库的全量逻辑备份，在备份过程中使用全局锁可以保证数据的一致性，因为在锁定期间数据不会被修改。

示例代码

```
-- 加全局读锁
FLUSH TABLES WITH READ LOCK;
-- 进行备份操作
-- 释放全局锁
UNLOCK TABLES;
```

##### （3）优缺点

- **优点**：实现简单，能确保在备份期间数据库的数据处于一个稳定的状态，保证备份数据的一致性。
- **缺点**：对数据库的影响较大，在加锁期间数据库基本处于不可用状态，严重影响数据库的并发性能和业务的正常运行。

#### 2.1.2.2、表级锁

##### （1）概念

表级锁是对整张表进行锁定，锁定粒度较大。当一个事务对某张表加上表级锁后，其他事务对该表的读写操作会受到限制，具体限制取决于锁的类型（共享锁或排他锁）。

##### （2）类型

- **表共享读锁（Table Read Lock）**：多个事务可以同时对同一张表加共享读锁，在持有读锁期间，事务只能读取表中的数据，不能修改。
- **表独占写锁（Table Write Lock）**：一个表在同一时间只能有一个事务持有写锁，持有写锁的事务可以对表进行读写操作，其他事务不能对该表进行任何操作，直到写锁被释放。

##### （3）使用场景

适用于对表进行批量操作的场景，如批量插入、批量更新等。

示例代码

```
sql
-- 加表共享读锁
LOCK TABLES users READ;
-- 进行读操作
SELECT * FROM users;
-- 释放锁
UNLOCK TABLES;

-- 加表独占写锁
LOCK TABLES users WRITE;
-- 进行写操作
UPDATE users SET age = 25 WHERE id = 1;
-- 释放锁
UNLOCK TABLES;
```

##### （4）优缺点

- **优点**：加锁和释放锁的速度快，开销小，因为只需要对表进行一次锁定和解锁操作。
- **缺点**：并发度低，因为对整张表加锁会限制其他事务对该表的访问，容易造成锁冲突。

#### 2.1.2.3、页级锁

##### （1）概念

页级锁的锁定粒度介于表级锁和行级锁之间，它一次会锁定相邻的一组行，通常是数据库中一个数据页的大小。一个数据页包含了多个行的数据。

##### （2）使用场景

BDB（Berkeley DB）存储引擎支持页级锁，但在 MySQL 中，常用的 InnoDB 存储引擎并不使用页级锁。页级锁适用于一些特定的应用场景，需要在并发性能和锁开销之间进行平衡。

##### （3）优缺点

- **优点**：相比于表级锁，页级锁的并发度有所提高，因为它只锁定部分数据，而不是整个表。
- **缺点**：相比于行级锁，页级锁的并发度仍然较低，而且加锁和释放锁的开销相对较大。

#### 2.1.2.4、行级锁

##### （1）概念

行级锁是对表中的某一行或几行数据进行锁定，锁定粒度最小。当一个事务对某一行数据加上行级锁后，其他事务可以对表中的其他行进行操作，只有对被锁定的行的操作会受到限制。

##### （2）类型

- **共享锁（Shared Lock，S 锁）**：多个事务可以同时对同一行数据加共享锁，用于只读操作，防止其他事务对该行数据加排他锁。
- **排他锁（Exclusive Lock，X 锁）**：一个事务对某行数据加排他锁后，其他事务不能再对该行数据加任何类型的锁，用于写操作，保证数据的独占性。

##### （3）使用场景

适用于高并发的事务处理场景，如在线交易系统、电商系统等，因为行级锁可以最大程度地减少锁冲突，提高并发性能。

示例代码

```
sql
-- 加行级共享锁
START TRANSACTION;
SELECT * FROM orders WHERE order_id = 1 LOCK IN SHARE MODE;
-- 进行读操作
SELECT * FROM orders WHERE order_id = 1;
COMMIT;

-- 加行级排他锁
START TRANSACTION;
SELECT * FROM products WHERE product_id = 1 FOR UPDATE;
-- 进行写操作
UPDATE products SET stock = stock - 1 WHERE product_id = 1;
COMMIT;
```

##### （4）优缺点

- **优点**：并发度高，因为不同事务可以同时对表中的不同行进行操作，减少了锁冲突的概率。
- **缺点**：加锁和释放锁的开销大，因为需要对每一行数据进行锁定和解锁操作，而且行级锁的实现相对复杂。

### 2.1.3、按属性分类

在 MySQL 里按属性对锁分类，主要是分成共享锁和排他锁，这种分类是<code class='orange'>**基于锁对数据资源访问的控制特性**</code>。

#### 2.1.3.1、共享锁（Shared Lock，S 锁）

共享锁也叫读锁，其核心属性是
“共享”。当一个事务给数据加上共享锁后，其他事务也能够对同一数据加上共享锁来进行读取操作，但在有共享锁存在时，不能对该数据加排他锁。这就好比图书馆里的一本公开书籍，多个读者可以同时阅读它，但在阅读期间不能对书籍进行涂改等修改操作。

##### （1）使用语法

在 MySQL 的 InnoDB 存储引擎中，可以使用 SELECT ... LOCK IN SHARE MODE 语句来为查询操作添加共享锁。示例如下：

```
sql
START TRANSACTION;
SELECT * FROM products WHERE product_id = 1 LOCK IN SHARE MODE;
-- 这里可以继续执行其他读操作
COMMIT;
```

##### （2）适用场景

常用于多个事务需要同时读取同一数据，且不会对数据进行修改的场景。例如，在电商系统中，多个用户同时查看某一商品的详细信息，此时可以使用共享锁，多个查询操作可以并发执行，提高系统的并发性能。

#### 2.1.3.2、排他锁（Exclusive Lock，X 锁）

排他锁也叫写锁，其属性为
“排他”。一旦某个事务对数据加上排他锁，其他事务就不能再对该数据加任何类型的锁（包括共享锁和排他锁）。这类似于对一份重要文件加了保密锁，只有持有钥匙（排他锁）的人才能对文件进行查看和修改，其他人在锁被释放前无法操作。

##### （1）使用语法

在 MySQL 中，可以使用 SELECT ... FOR UPDATE 语句为查询操作添加排他锁，或者在执行 INSERT、UPDATE、DELETE
操作时，数据库会自动为涉及的数据行加上排他锁。示例如下：

```
sql
START TRANSACTION;
SELECT * FROM products WHERE product_id = 1 FOR UPDATE;
UPDATE products SET stock = stock - 1 WHERE product_id = 1;
COMMIT;
```

##### （2）适用场景

适用于对数据进行修改的操作，如在银行转账业务中，当一个账户进行资金转出操作时，需要对该账户记录加上排他锁，防止其他事务同时对该账户进行操作，避免出现数据不一致的情况。

#### 2.1.3.3、锁的兼容性

共享锁和排他锁之间的兼容性规则如下：

| 当前锁状态 \ 待加锁类型                                    |     	共享锁（S 锁）      |     	排他锁（X 锁） |
|:-------------------------------------------------|:------------------:|--------------:|
| 共享锁（S 锁）                                         | 	兼容，多个事务可同时持有 S 锁	 | 不兼容，需等待 S 锁释放 |
| 排他锁（X 锁）                                         |  	不兼容，需等待 X 锁释放	   | 不兼容，需等待 X 锁释放 |

通过这种基于属性的分类方式，数据库能够根据不同的操作需求（读或写）和并发情况，灵活地控制对数据资源的访问，保证数据的一致性和完整性。 

### 2.1.4、按状态分类
在 MySQL 锁的状态分类里，“状态” 可以理解为一种<code class='orange'>**预先声明或者标记**</code>，用来告知数据库系统事务接下来对表内数据行的锁定意图，主要包括意向共享锁（IS 锁）和意向排他锁（IX 锁）这两种状态

**意向锁是表锁**，为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。

#### 2.1.4.0、意向锁的作用
- 仅声明“表中某些行被加了行级排他锁”，本身不直接锁定表。
- 避免其他事务对表加表级排他锁（如DROP TABLE），提升锁冲突检测效率。

为什么会有意向锁这个玩意儿？说直白点，就是当对表上锁时，如何知道当前有木有行锁？遍历是不可能遍历的，所以有了意向锁这个玩意儿，快速的知道表中的行是否加了锁

#### 2.1.4.1、意向共享锁（IS锁）
##### （1）状态含义
意向共享锁是一种表示事务有对表中某些行添加共享锁计划的状态。共享锁通常用于读操作，允许多个事务同时读取同一数据。当事务打算对表内部分行进行读操作时，会先把表标记为 IS 锁状态，就好像在门上贴了个告示，告诉其他人 “我一会儿要进来安静地看看里面某些东西，不会乱动”。

##### （2）生活实例类比
想象一个资料室，里面有很多文件柜。现在有几个学生想要查阅不同文件柜里的资料。在进入资料室之前，他们先在资料室门口挂了一个 “大家可安静查阅资料” 的牌子，这就类似于数据库里给表加上了意向共享锁。此时，其他学生看到这个牌子，知道可以进来一起查阅资料，但不能对资料进行修改。

##### （3）数据库操作体现
当执行 SELECT ... LOCK IN SHARE MODE 语句时，事务先给表加上 IS 锁，再给涉及的行加共享锁。例如：
```
sql
START TRANSACTION;
SELECT * FROM books WHERE category = 'Science' LOCK IN SHARE MODE;
```
这里事务先把 books 表标记为 IS 锁状态，然后对 category 为 'Science' 的行加共享锁，让其他事务也能同时读取这些行的数据。

#### 2.1.4.2、意向排他锁（IX 锁）状态
##### （1）状态含义
意向排他锁表示事务有对表中某些行添加排他锁的打算。排他锁用于写操作，同一时间只允许一个事务对数据进行读写，其他事务不能访问。当事务准备对表内部分行进行写操作时，会把表标记为 IX 锁状态，如同在门上贴告示 “我一会儿要进来修改里面某些东西，其他人先别进”。

##### （2）生活实例类比
还是以资料室为例，有一个工作人员要对部分文件进行修改。在进入资料室之前，他在门口挂了一个 “正在整理资料，请勿入内” 的牌子，这就类似于给表加上了意向排他锁。此时，其他学生看到牌子就知道不能进入资料室，要等工作人员完成修改工作。

##### （3）数据库操作体现
执行 INSERT、UPDATE、DELETE 或 SELECT ... FOR UPDATE 语句时，事务先给表加 IX 锁，再给涉及的行加排他锁。例如：
```
START TRANSACTION;
UPDATE employees SET salary = salary * 1.1 WHERE department = 'Sales';
```
这里事务先把 employees 表标记为 IX 锁状态，接着对 department 为 'Sales' 的行加排他锁，阻止其他事务同时访问这些行。

#### 2.1.4.3、状态的作用
这两种锁状态主要是为了让数据库系统更高效地管理不同粒度的锁。当数据库要对整个表加锁时，通过查看表的意向锁状态，就能快速知道表中是否有行已经被锁定或即将被锁定，避免逐行检查的开销，提高加锁和解锁的效率。

#### 2.1.4.4、意向锁的兼容性
![意向锁的兼容性](2020-08-23-mysql-锁/意向锁的兼容性.png)
- 意向排他锁和意向排他锁是兼容的
  - 意味着可以更新未被锁定的行：如果其他事务更新的行未被意向排他锁关联的行锁锁定，则允许操作。


### 2.1.5、按算法分类
在 MySQL 中，按算法对锁进行分类，主要有记录锁、间隙锁和临键锁，这些锁算法是 InnoDB 存储引擎为实现不同隔离级别下的并发控制而设计的，下面为你详细介绍：

#### 2.1.5.1、记录锁（Record Lock）
记录锁是对索引记录加的锁，它直接锁定表中的某一条记录，防止其他事务对该记录进行修改或删除操作。记录锁可以是共享锁（S 锁）或排他锁（X 锁）。
- <font color=red>**记录锁主要锁定的是索引记录**</font>

##### （1）示例
假设存在一个 users 表，有 id（主键）和 name 字段。当执行以下语句时：
```
START TRANSACTION;
SELECT * FROM users WHERE id = 1 FOR UPDATE;
```
如果 id 是索引列，那么这条语句会对 id 为 1 的记录加上排他记录锁。在该事务提交之前，其他事务无法对该记录进行修改或加排他锁，但可以加共享锁进行读取。

##### （2）作用
记录锁主要用于在对特定记录进行操作时，保证该记录的一致性和完整性，避免其他事务同时修改该记录导致的数据冲突。

#### 2.1.5.2、间隙锁（Gap Lock）
间隙锁是锁定索引记录之间的间隙，而不是具体的记录。它的作用是防止其他事务在该间隙插入新的记录，从而避免幻读问题。间隙锁只在可重复读（REPEATABLE READ）隔离级别下使用。
- 这里的索引可以是主键索引，也可以是辅助索引。当对表中的数据进行查询或操作时，InnoDB 会根据索引的值来界定各个记录之间的间隙，并对这些间隙加锁。

##### （1）示例
假设 users 表中的 id 列有值 1、3、5，当执行以下语句时：
```
START TRANSACTION;
SELECT * FROM users WHERE id BETWEEN 1 AND 5 FOR UPDATE;
```
除了对 id 为 1、3、5 的记录加锁外，还会对 (-∞，1)、(1, 3)、(3, 5)、(5, +∞) 这些间隙加上间隙锁。在该事务提交之前，其他事务无法在这些间隙插入新的记录。

##### （2）作用
间隙锁主要用于可重复读隔离级别下，防止幻读现象的发生。幻读是指在一个事务中，多次执行相同的查询语句，由于其他事务插入了新的记录，导致查询结果集发生了变化。

#### 2.1.5.3、临键锁（Next-Key Lock）
临键锁是记录锁和间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间，是一个左开右闭区间。临键锁也是在可重复读隔离级别下使用，是 InnoDB 存储引擎默认的行锁算法。
- **临键锁的主要目的，也是为了避免幻读(Phantom Read)**。如果把事务的隔离级别降级为RC，临键锁则也会失效。

##### （1）示例
还是以 users 表为例，假设 id 列有值 1、3、5，当执行以下语句时：
```
START TRANSACTION;
SELECT * FROM users WHERE id > 1 FOR UPDATE;
```
会对 id 大于 1 的记录加上临键锁。例如，对于 id 为 3 的记录，临键锁会锁定该记录本身以及 (1, 3) 这个间隙。在该事务提交之前，其他事务无法修改 id 为 3 的记录，也无法在 (1, 3) 间隙插入新的记录。

##### （2）作用
临键锁结合了记录锁和间隙锁的功能，在可重复读隔离级别下，既能保证对特定记录的操作一致性，又能防止幻读问题，确保事务在多次读取同一范围的数据时，结果保持一致。

##### （3）锁退化 - 等值查询时临键锁退化为记录锁

###### 原理
当使用唯一索引（如主键）进行等值查询时，InnoDB 可以精确地定位到一条记录。由于唯一索引的特性保证了索引值的唯一性，不会出现幻读问题（即不会有其他符合该等值条件的记录插入），所以此时临键锁会退化为记录锁，仅对匹配的那一条记录加锁，而不会对其前后的间隙加锁。

###### 示例
假设有一个表 orders，其主键为 order_id，表中已有 order_id 为 1、3、5 的记录，执行以下 SQL 语句：
```
START TRANSACTION;
SELECT * FROM orders WHERE order_id = 3 FOR UPDATE;
```
在这个等值查询中，因为 order_id 是主键，InnoDB 只会对 order_id 为 3 的这条记录加排他记录锁，不会对 (1, 3) 和 (3, 5) 这些间隙加锁。也就是说，其他事务仍然可以在这些间隙插入新的记录

##### （4）范围查询时可能存在临键锁
###### 原理
当使用唯一索引进行范围查询时，由于无法确定查询范围外是否会有新的符合条件的记录插入，为了防止幻读，InnoDB 会使用临键锁。临键锁会锁定查询范围内的记录以及它们前面的间隙。

###### 示例
还是以 orders 表为例，执行以下范围查询语句：
```
START TRANSACTION;
SELECT * FROM orders WHERE order_id > 3 FOR UPDATE;
```
InnoDB 会对 order_id 大于 3 的记录加上临键锁。对于 order_id 为 5 的记录，不仅会锁定该记录本身，还会锁定 (3, 5) 这个间隙。在该事务提交之前，其他事务无法修改 order_id 为 5 的记录，也无法在 (3, 5) 间隙插入新的记录，以此来避免幻读问题。

综上所述，唯一索引列（包括主键列）上并非不存在临键锁，在等值查询时通常会退化为记录锁，但范围查询时临键锁机制仍可能发挥作用。

综上所述，记录锁、间隙锁和临键锁在不同的场景下发挥着重要作用，它们共同构成了 InnoDB 存储引擎强大的并发控制机制，保证了数据库在高并发环境下的数据一致性和完整性。


# 三、innodb的锁

## 3.1、InnoDB锁的内存结构
我们来看一下InnoDB锁的内存结构，InnoDB中用lock_t这个结构来定义：
![lock_t](2020-08-23-mysql-锁/lock_t.png)
<font color=green>**「对一条记录加锁的本质就是在内存中创建一个锁结构与之关联」**</font>，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢？如果一个事务要获取10000条记录的锁，就要生成10000个这样的结构，开销就太大了。

InnoDB在对不同记录加锁时，如果符合下边这些条件，那么这些记录的锁就可以被放到一个锁结构中：
- 在同一个事务中进行加锁操作
- 被加锁的记录在同一个页面中
- 加锁的类型是一样的
- 等待状态是一样的

锁的内存结构示意图如下：
![锁的内存结构示意图](2020-08-23-mysql-锁/锁的内存结构示意图.png)
接下来具体分析一下每个结构所代表的是什么信息
- 锁所在的事务信息：哪个事务生成了这个锁结构，就记载这个事务的信息。
- 索引信息：对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。
- 表锁/行锁信息 ：表锁结构和行锁结构在这个位置的内容是不同的：
  - 表锁：记载着这是对哪个表加的锁，还有其他的一些信息。
  - 行锁，记载了三个重要的信息：
    - <code>Space ID</code>：记录所在表空间。
    - <code>Page Number</code>：记录所在页号。
    - <code>n_bits</code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位。 
  - <code>type_mode</code>：这是一个32位的数，被分成了<code>lock_mode、lock_type</code>和<code>rec_lock_type</code>三个部分。
    - ![type_mode](2020-08-23-mysql-锁/type_mode.png)
    - 锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：
      - <code>LOCK_IS（十进制的0）</code>：表示共享意向锁，也就是IS锁。
      - <code>LOCK_IX（十进制的1）</code>：表示独占意向锁，也就是IX锁。
      - <code>LOCK_S（十进制的2）</code>：表示共享锁，也就是S锁。
      - <code>LOCK_X（十进制的3）</code>：表示独占锁，也就是X锁。
      - <code>LOCK_AUTO_INC（十进制的4）</code>：表示AUTO-INC锁。
    - 锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：
      - <code>LOCK_TABLE（十进制的16）</code>，也就是当第5个比特位置为1时，表示表级锁。
      - <code>LOCK_REC（十进制的32）</code>，也就是当第6个比特位置为1时，表示行级锁。
    - 行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在lock_type的值为LOCK_REC时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：
      - <code>LOCK_ORDINARY（十进制的0）</code>：表示<code>**next-key锁**</code>。
      - <code>LOCK_GAP（十进制的512）</code>：也就是当第10个比特位置为1时，表示<code>**gap锁**</code>。
      - <code>LOCK_REC_NOT_GAP（十进制的1024）</code>：也就是当第11个比特位置为1时，表示<code>**行锁**</code>。
      - <code>LOCK_INSERT_INTENTION（十进制的2048）</code>：也就是当第12个比特位置为1时，表示<code class='orange'>插入意向锁</code>。
        - <code class='orange'>插入意向锁</code>是行锁的一种，是一种特殊的间隙锁，在插入操作前设置的
          - 核心目标是<code class='orange'>允许不同事务在同一个间隙范围内插入不冲突的数据</code>，同时避免幻读的问题
          - 与已经存在的排他间隙锁<code class='orange'>（X Gap Lock）</code>冲突，必须等待其释放
      - 其他的类型：还有一些不常用的类型。


> 在InnoDB的实现中，InnoDB的行锁是与记录一一对应的，对于间隙锁（gap）来说也是如此，虽说间隙锁锁住的是一个间隙，但是是通过在指定记录上加锁生成锁结构，然后指定锁的类型为间隙锁，并不是在一个专门的区间生成一个间隙锁。他的工作方式就是在插入记录式检查下一条记录上的锁结构是否存在间隙锁，如果存在的话就无法插入。

# 四、Innodb到底是怎么加锁的

假设<code>hero</code>表就有了两个索引（一个二级索引，一个聚簇索引），示意图如下：
![hero_表](2020-08-23-mysql-锁/hero_表.png)

## 4.1、加锁受哪些因素影响？
一条语句加什么锁受多种因素影响，如果你不能确认下边这些因素的时候，最好不要抢先发言说"XXX语句对XXX记录加了什么锁"：
- 事务的隔离级别
- 语句执行时使用的索引类型（比如聚簇索引、唯一二级索引、普通二级索引）
- 是否是精确匹配
- 是否是唯一性搜索
- 具体执行的语句类型（SELECT、INSERT、DELETE、UPDATE）
- 是否开启innodb_locks_unsafe_for_binlog系统变量
- 记录是否被标记删除

这里边有几个概念大家可能不是很清楚，我们先解释一下。


### 4.1.1、扫描区间
```dtd
SELECT * FROM hero WHERE name <=  'l刘备' ;
```
以这条sql为例，MySQL可以使用下边**两种方式来执行**上述查询：
- 使用二级索引idx_name执行上述查询，那么就需要扫描name值在<code>**(-∞, 'l刘备']**</code>这个区间中的所有二级索引记录，针对获取到的每一条二级索引记录，都需要执行回表操作来获取相应的聚簇索引记录。
- 直接扫描所有的聚簇索引记录，即进行全表扫描。此时相当于扫描number值在<code>**(-∞, +∞)**</code>这个区间中的所有聚簇索引记录。

可能有人会有疑惑，name不是二级索引吗？为啥还有可能不走索引去全表扫描呢？
> SQL 的执行成本（cost）是 MySQL 优化器选择 SQL 执行计划时一个重要考量因素。当优化器认为使用索引的成本高于全表扫描的时候，优化器将会选择全表扫描，而不是使用索引。**那为什么使用索引的成本比全表扫描还高呢？** 因为当普通索引并不包括查询的所有列（没有使用覆盖索引的情况），因此需要通过 name 的索引树找到对应的主键 id ，然后再到 id 的索引树进行数据查询，即**回表（通过索引查出主键，再去查数据行）**，这样成本必然上升。尤其是当回表的数据量比较大的时候，经常会出现 MySQL 优化器认为回表查询代价过高而不选择索引的情况。

当使用二级索引执行查询时，我们把(-∞, 'l刘备']称作扫描区间，意味着需要扫描name列值在这个区间中的所有二级索引记录，我们也可以把形成这个扫描区间的条件name <= 'l刘备'称作是形成这个扫描区间的边界条件；当使用全表扫描执行查询时，我们把(-∞, +∞)称作扫描区间，意味着需要扫描number值在这个区间中的所有聚簇索引记录。

### 4.1.2、精确匹配
对于形成扫描区间的边界条件来说，如果是等值匹配的条件，我们就把对这个扫描区间的匹配模式称作**精确匹配**。
```
SELECT * FROM hero WHERE name = 'l刘备' AND country = '魏';
```
如果使用二级索引idx_name执行上述查询时，扫描区间就是['l刘备', 'l刘备']，形成这个扫描区间的边界条件就是name = 'l刘备'。我们就把在使用二级索引idx_name执行上述查询时的匹配模式称作**精确匹配**。

### 4.1.3、唯一性搜索
如果在扫描某个扫描区间的记录前，就能事先确定该扫描区间**最多只包含1条记录**的话，那么就把这种情况称作唯一性搜索。那满足什么样的情况可以确定是唯一性搜索呢？
![唯一性搜索_代码](2020-08-23-mysql-锁/唯一性搜索_代码.png)
1. 匹配模式是精确匹配
2. 使用的索引是聚簇索引或唯一索引（非聚簇索引）
3. 如果索引中包含多个列，则每个列在生成扫描区间时都应该被用到
> 举个例子：比方说我们为某个表的a、b两列建立了一个唯一索引uniquek_a_b(a, b)，那么对于搜索条件a=1形成的扫描区间来说，不能保证该扫描区间最多只包含一条记录；对于搜索条件a=1 AND b= 1形成的扫描区间来说，才可以保证该扫描区间中仅包含1条记录
4. 如果使用的索引是唯一索引（非聚簇索引），那么在搜索时不能搜索某个索引列为NULL的记录（因为对于唯一索引来说，是可以存储多个值为NULL的记录的）。


## 4.2、row_search_mvcc
我们知道MySQL其实是分成server层和存储引擎层两部分，每当执行一个查询时，server层负责生成执行计划，即选取即将使用的索引以及对应的扫描区间。我们这里以InnoDB为例，针对每一个扫描区间，都会：
- server层向InnoDB要扫描区间的第1条记录
- InnoDB通过B+树定位到扫描区间的第1条记录（如果定位的是二级索引记录并有回表需求则回表获取完整的聚簇索引记录），然后返回给server层
- server层判断记录是否符合搜索条件，如果符合则发送给客户端，不符合则跳过。继续向InnoDB要下一条记录。
> 小贴士：
>
> 此处将记录发送给客户端其实是发送到本地的网络缓冲区，缓冲区大小由net_buffer_length控制，默认是16KB大小。等缓冲区满了才真正发送网络包到客户端。
- InnoDB根据记录的单向链表以及页面之间的双向链表找到下一条记录（如果定位的是二级索引记录并有回表需求则回表获取完整的聚簇索引记录），返回给server层。
- server层处理该记录，并向InnoDB要下一条记录
- ... 不停执行上述过程，直到InnoDB读到一条不符合边界条件的记录为止

可见一般情况下，server层和存储引擎层是以记录为单位进行通信的，而InnoDB读取一条记录最重要的函数就是<code class='my-code'>row_search_mvcc</code>：
![row_search_mvcc](2020-08-23-mysql-锁/row_search_mvcc.png)
可以看到这个函数长到吓人，有一千多行。

在<code class='orange'>row_search_mvcc</code>里，对一条记录进行诸如多版本的可见性判断，要不要对记录进行加锁的判断，要是加锁的话加什么锁的选择，完成记录从InnoDB的存储格式到server层存储格式的转换等等等等十分繁杂的工作。

其实对于UPDATE、DELETE语句来说，执行它们前都需要先在B+树中定位到相应的记录，所以它们也会调用<code class='orange'>row_search_mvcc</code>。

InnoDB对记录的加锁操作主要是在<code class='orange'>row_search_mvcc</code>中的，像<code class='my-code'>SELECT ... LOCK IN SHARE MODE、SELECT ... FOR UPDATE、UPDATE、DELETE</code>这样的语句都会调用<code class='orange'>row_search_mvcc</code>完成加锁操作。<code class='my-code'>SELECT ... LOCK IN SHARE MODE</code>会为记录添加S型锁，<code class='my-code'>SELECT ... FOR UPDATE、UPDATE、DELETE</code>会为记录添加X型锁。

InnoDB每当读取一条记录时，都会调用一次<code class='orange'>row_search_mvcc</code>，在做了足够长的铺垫之后，我们终于可以看一下在<code class='orange'>row_search_mvcc</code>函数中是怎么对某条记录进行加锁的。


## 4.3、语句到底是怎么加锁的
首先看一个十分重要的变量：
![set_also_gap_locks](2020-08-23-mysql-锁/set_also_gap_locks.png)
<code class='orange'>set_also_gap_locks</code>表示是否要给记录添加gap锁（next-key锁可以看成是正经记录锁和gap锁的组合），它的默认值是<code class='orange'>TRUE</code>，表示默认会给记录添加gap锁。

<code class='orange'>set_also_gap_locks</code>可能会在下边这个地方发生变化：
![set_also_gap_locks_变化](2020-08-23-mysql-锁/set_also_gap_locks_变化.png)
即如果当前执行的是SELECT ... LOCK IN SHARE MODE或者SELECT ... FOR UPDATE这样的加锁读语句（非DELETE或UPDATE语句），并且隔离级别不大于READ COMMITTED 时，将set_also_gap_locks设置为FALSE。

其中prebuilt->select_lock_type表示加锁的类型，LOCK_NONE表示不加锁，LOCK_S表示加S锁（比方说执行SELECT ... LOCK IN SHARE MODE时），LOCK_X表示加X锁（比方说执行SELECT ... FOR UPDATE、DELETE、UPDATE时）。


### 4.3.1、对普通的SELECT的处理和意向锁的添加
![普通select](2020-08-23-mysql-锁/普通select.png)
- 标号1的箭头是对普通的SELECT的处理，在查询开启前需要生成ReadView。
> 小贴士：
> 
> 对于Repeatable Read隔离级别来说，只在首次执行SELECT语句时生成Readview，之后的SELECT语句都复用这个ReadView；对于Read Committed隔离级别来说，每次执行SELECT语句时都会生成一个ReadView。这一点并不是在上边截图中的代码里实现的。
- 标号2的箭头是对加锁读的语句的处理，在首次读取记录（prebuilt->sql_stat_start表示是否是首次读取）前，需要添加表级别的意向锁（IS或IX锁）。

下边是真正处理记录并给记录加锁的流程，我们给这些流程编个号。

#### 第1. 定位扫描区间的第一条记录
下边开始通过B+树定位某个扫描区间中的第一条记录了（对于一个扫描区间来说，只执行一次下述函数，因为只要定位到扫描区间的第一条记录之后，就可以沿着记录所在的单向链表进行查询了）：
![btr_pcur_open_with_no_init](2020-08-23-mysql-锁/btr_pcur_open_with_no_init.png)
其中btr_pcur_open_with_no_init是用于定位扫描区间中的第一条记录的函数。

#### 第2. 对于ORDER BY ... DESC条件形成的扫描区间的第一条记录的处理
在B+树的每层节点中，记录是按照键值从小到大的方式进行排序的。对于某个扫描区间来说，InnoDB通常是定位到扫描区间中最左边的那条记录，也就是键值最小的那条记录，然后沿着从左往右的方式向后扫描。

但是对于下边这个查询来说：
```
SELECT * FROM hero WHERE name < 's孙权' AND country = '魏' ORDER BY name DESC FOR UPDATE ;
```
如果优化器决定使用二级索引idx_name执行上述查询的话，那么对应的扫描区间就是<code class='orange'>(-∞, 's孙权')</code>。由于上述查询要求记录是按照从大到小的顺序返回给用户，所以InnoDB定位到扫描区间中的第一条记录应该是该扫描区间中最右边的那条记录，也就是键值最大的那条记录（在执行<code class='orange'>btr_pcur_open_with_no_init</code>时就定位到最右边的那条记录），我们看一下idx_name二级索引示意图：
![第2_二级索引图](2020-08-23-mysql-锁/第2_二级索引图.png)
很显然，name值为<code class='orange'>'l刘备'</code>的二级索引记录是扫描区间<code class='orange'>(-∞, 's孙权')</code>中最右边的记录。

对于从右向左扫描<code class='orange'>扫描区间</code>中记录的情况，针对从扫描区间中定位到的最右边的那条记录，需要做如下处理：
![第2_sel_set_rec_lock](2020-08-23-mysql-锁/第2_sel_set_rec_lock.png)
其中<code class='orange'>sel_set_rec_lock</code>就是对一条记录进行加锁的函数。

可以看到，对于加锁读来说，在隔离级别不小于<code class='orange'>REPEATABLE READ</code>并且也没有开启<code class='orange'>innodb_locks_unsafe_for_binlog</code>系统变量的情况下，会对扫描区间中最右边的那条记录的下一条记录加一个类型为<code class='orange'>LOCK_GAP</code>的锁，这个类型为LOCK_GAP的锁其实就是<code class='orange'>gap锁</code>。

在本例中，假设事务的隔离级别是REPATABLE　READ。扫描区间<code class='orange'>(-∞, 's孙权')</code>中最右边的那条记录就是name值为<code class='orange'>'l刘备'</code>的二级索引记录，接下来就应该为该记录的下一条记录，也就是name值为<code class='orange'>'s孙权'</code>的二级索引记录加一个<code class='orange'>gap锁</code>。

#### 第3. 真正的加锁流程才开始——对Infimum和Supremum记录的处理
**步骤1**是用来定位扫描区间中的第一条记录，针对一个扫描区间只执行1次。

**步骤2**是针对从右向左扫描的扫描区间中最右边的那条记录的下一条记录进行加锁，针对一个扫描区间也执行1次。

从第3步骤开始以及往后的步骤，扫描区间中的每一条记录都要经历。

先看一下如果当前记录是<code class='orange'>Infimum记录</code>或者<code class='orange'>Supremum记录</code>时的处理：
![第3_处理Infimum](2020-08-23-mysql-锁/第3_处理Infimum.png)
从上边的代码中可以看出，如果当前读取的记录是Infimum记录，则啥也不做，直接去读下一条记录。

如果当前读取的记录是Supremum记录，则在下边这些条件成立的时候就会为记录添加一个类型为<code class='orange'>LOCK_ORDINARY</code>的锁，其实也就是<code class='orange'>next-key锁</code>：
- set_also_gap_locks是TRUE（这个变量只在前边设置过，当隔离级别不大于READ COMMITTED的SELECT语句的加锁读会设置为FALSE，否则为TRUE）
- 未开启innodb_locks_unsafe_for_binlog系统变量并且事务的隔离级别不小于REPEATABLE READ。
- 本次读取属于加锁读
- 所使用的不是空间索引。

其实由于Supremum记录本身是一条伪记录，别的事务并不会更新或删除它，所以给它添加next-key锁起到的效果和给它添加gap锁是一样的。

#### 第4. 真正的加锁流程才开始——对精确匹配的特殊处理
如果当前记录不是Infimum记录或者Supremum记录，下边进入对匹配模式是<code class='orange'>精确匹配</code>的一个特殊处理：
![第4_精确匹配](2020-08-23-mysql-锁/第4_精确匹配.png)
可以看到，对于匹配模式是精确匹配的扫描区间来说，如果执行本次row_search_mvcc获取到的记录不在扫描区间中<code class='orange'>（0 != cmp_dtuple_rec(search_tuple, rec, offsets)）</code>，则需要进行一些特殊处理，即：

对于加锁读来说，如果事务的隔离级别不小于Repeatable Read并且未开启innodb_locks_unsafe_for_binlog系统变量，那么就对该记录加一个gap锁，并且直接返回（代码中直接跳转到normal_return处），就不进行后续的加锁操作了。

我们举一个例子，比方说当前事务的隔离级别为Repeatable Read，执行如下语句：
```
SELECT * FROM hero WHERE name = 's孙权' FOR UPDATE;
```
如果使用二级索引idx_name执行上述查询，那么对应的扫描区间就是<code class='orange'>['s孙权', 's孙权']</code>。该语句会首先对name值是<code class='orange'>'s孙权'</code>的记录进行加锁，不过该记录是在扫描区间中的，上述代码并不处理这种正常情况，关于正常情况的加锁我们稍后分析。

当读取完<code class='orange'>'s孙权'</code>的记录后，InnoDB会根据记录的next_record属性找到下一条二级索引记录，即name值为'x荀彧'的二级索引记录，该记录不在扫描区间<code class='orange'>['s孙权', 's孙权']</code>中，即符合 <code class='orange'>0 != cmp_dtuple_rec(search_tuple, rec, offsets)</code>条件，那么就执行上述代码的加锁流程 —— 对name值为<code class='orange'>'x荀彧'</code>的二级索引记录加一个gap锁。另外，err被赋值为DB_RECORD_NOT_FOUND，这意味着向server层报告当前扫描区间的记录都已经扫描完了，server层在收到这个信息后就会停止向Innodb索要下一条记录的请求，即结束本扫描区间的查询。
> 小贴士：
> 
> 这一步骤是对精确匹配的扫描区间的一个特殊处理，即当server层收到InnoDB返回的扫描区间的最后一条记录，server层仍会向InnoDB索要下一条记录。InnoDB仍会沿着记录所在的链表向后读取，此次读取到的记录就不在扫描区间中了，如例子中的name值为'x荀彧'的二级索引记录就不在扫描区间['s孙权', 's孙权']中。如果这是一个精确匹配的扫描区间，那么就进行如步骤4所示的特殊处理，如果不是的话，就继续执行第5步，也就是走正常的加锁流程。


#### 第5. 真正的加锁流程才开始——这回真的开始了
![第5](2020-08-23-mysql-锁/第5.png)
我们在代码中画了2个红框，这两个红框是对记录是不对记录加gap锁的场景。我们具体看一下。

对于1号红框来说：
- set_also_gap_locks是FALSE（这个变量只在前边设置过，当隔离级别不大于READ COMMITTED的SELECT语句的加锁读会设置为FALSE，否则为TRUE）
- 开启innodb_locks_unsafe_for_binlog系统变量
- 事务的隔离级别不大于READ COMMITTED
- 唯一性搜索并且该记录的delete_flag不为1
- 该索引是空间索引

也就是说只要上边任意一个条件成立，该记录就不应该被加gap锁，而应该添加正经记录锁。其余情况就应该加next-key锁（gap锁和正经记录锁的合体）了。

紧接着2号红框就又叙述了一个不加gap锁的场景：
<code class='orange'>**对于>= 主键的这种边界条件来说，如果当前记录恰好是开始边界，就仅需对该记录加正经记录锁，而不需添加gap锁**</code>。

1号红框的内容比较好理解，我们举个例子看一下<code class='orange'>2号红框</code>是在说什么。比方说下边这个查询：
```
SELCT * FROM hero WHERE number >= 8 FOR UPDATE;
```
我们假设这个语句在隔离级别为<code class='orange'>REPEATABLE READ</code>。

很显然，优化器会扫描<code class='orange'>[8, +∞)</code>的聚簇索引记录。首先要通过B+树定位到扫描区间<code class='orange'>[8, +∞)</code>的第一条记录，也就是number值为8的聚簇索引记录，这条记录就是扫描区间<code class='orange'>[8, +∞)</code>的开始边界记录。按理说在REPEATABLE READ隔离级别下应该添加<code class='orange'>next-key锁</code>，但由于2号红框中代码的存在，仅会给number值为8的聚簇索引记录添加<code class='orange'>正经记录锁</code>。
> 小贴士：
> 
> 2号方框的优化主要是基于“主键值是唯一的”这条约束，在一个事务执行了上述查询之后，其他事务是不能插入number值为8的记录的，这也用不着gap锁了。

除了1号方框和2号方框的场景，其余场景都给记录加next-key锁就好喽～

#### 第6. 判断索引条件下推的条件是否成立
如果是使用二级索引执行查询，并且有索引条件下推（Index Condition Pushdown，简称ICP）的条件的话，判断下推的条件是否成立：
![第6_icp](2020-08-23-mysql-锁/第6_icp.png)
这里大家特别注意一下，在使用二级索引执行查询，对于非精确匹配的扫描区间来说，形成扫描区间的边界条件也会被当作ICP条件下推到存储引擎判断，比方说下边这个查询：
```dtd
mysql> EXPLAIN SELECT * FROM hero WHERE name > 's孙权' AND name < 'z诸葛亮' FOR UPDATE;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | hero  | NULL       | range | idx_name      | idx_name | 303     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.03 sec)

```
可以看到优化器决定使用idx_name执行上述查询，对应的扫描区间就是<code class='orange'>('s孙权', 'z诸葛亮')</code>，形成这个扫描区间的边界条件就是<code class='orange'>name > 's孙权' AND name < 'z诸葛亮'</code>。在执行计划的Extra列中出现了Using index condition，表明将边界条件<code class='orange'>name > 's孙权' AND name < 'z诸葛亮'</code>作为ICP条件下推到了存储引擎。

不下推不要紧，一下推的话<code class='orange'>row_search_idx_cond_check</code>就会判断当前记录是否已经不在扫描区间中了，如果不在扫描区间中的话，该函数就会返回<code class='orange'>ICP_OUT_OF_RANGE</code>。这样的话，err被赋值为DB_RECORD_NOT_FOUND，这意味着向server层报告当前扫描区间的记录都已经扫描完了，server层在收到这个信息后就会停止向Innodb索要下一条记录的请求，即结束本扫描区间的查询。

当然，如果本次查询没有ICP条件，<code class='orange'>row_search_idx_cond_check</code>直接返回ICP_MATCH，那就没有上述的麻烦事儿，继续向下走。

#### 第7. 回表对记录加锁
如果<code class='orange'>row_search_mvcc</code>读取的是二级索引记录，则还需进行回表，找到相应的聚簇索引记录后需对该聚簇索引记录加一个<code class='orange'>正经记录锁</code>：
![第7_正经记录锁](2020-08-23-mysql-锁/第7_正经记录锁.png)
其中，<code class='orange'>row_sel_get_clust_rec_for_mysql</code>便是用于回表的函数，对聚簇索引进行加锁的逻辑在该函数中实现，我们这里就不展开了。

需要注意的是，即使是对于覆盖索引的场景下，如果我们想对记录加X型锁（也就是使用SELECT ... FOR UPDATE、DELETE、UPDATE语句时）时，也需要对二级索引记录执行回表操作，并给相应的聚簇索引记录添加<code class='orange'>正经记录锁</code>。


#### 第8. row_search_mvcc返回，判断是否已经到达边界
每当处理完一条记录后，还需要判断一下这条记录还在不在扫描区间中，判断的代码如下：
![第8](2020-08-23-mysql-锁/第8.png)
如果当前记录还在扫描区间中，就给server层正常返回，如果不在了，就给server层返回一个<code class='orange'>HA_ERR_END_OF_FILE</code>信息，表示当前扫描区间的记录都已经扫描完了，server层在收到这个信息后就会停止向Innodb索要下一条记录的请求，即结束本扫描区间的查询。

#### 第9. 然后，再处理下一条记录
server层收到InnoDB的一条记录后，如果收到InnoDB通知的本扫描区间已经扫描完毕的信息，则结束本扫描区间的查询；否则继续向InnoDB要下一条记录，也就是需要继续执行一遍<code class='orange'>row_search_mvcc</code>函数了。

不过此时并不是定位扫描区间中的第一条记录，而是根据记录所在的链表去取下一条记录即可，所以直接从步骤3开始执行就好了，又开始了新的一条记录的加锁流程。。。

循环往复，直到server层收到本扫描区间所有记录都扫描完了的信息为止。

## 4.4、总结
其实大家再回头看<code class='orange'>row_search_mvcc</code>里的关于加锁的代码就会发现，其实流程还是很简单的：
- <code>步骤1.</code> 定位扫描区间的第一条记录。
- <code>步骤2.</code> 如果扫描区间是从右到左扫描，那么需要给扫描区间最右边的记录的下一条记录添加一个gap锁（在隔离级别不小于<code class='orange'>REPEATABLE READ</code>并且也没有开启<code class='orange'>innodb_locks_unsafe_for_binlog</code>系统变量的情况下）。
- <code>步骤3.</code> 对于<code class='orange'>Infimum记录</code>是不加锁的，对于<code class='orange'>Supremum</code>记录加<code class='orange'>next-key锁</code>（在隔离级别不小于<code class='orange'>REPEATABLE READ并且也没有开启<code class='orange'>innodb_locks_unsafe_for_binlog</code>系统变量的情况下）。
- <code>步骤4.</code> 对于精确匹配的扫描区间来说，当扫描区间中的记录都被读完后，需对扫描区间后的第一条记录加一个gap锁即可，并且向server层返回可结束本扫描区间的查询的信息（在隔离级别不小于REPEATABLE READ并且也没有开启<code class='orange'>innodb_locks_unsafe_for_binlog</code>系统变量的情况下）。
- <code>步骤5.</code> 事务的隔离级别不大于<code class='orange'>READ COMMITTED</code>，开启<code class='orange'>innodb_locks_unsafe_for_binlog</code>系统变量，唯一性搜索并且该记录的delete_flag不为1，对于<code class='orange'>>=</code> 主键的这种边界条件来说，当前记录恰好是开始边界记录，则对记录加<code class='orange'>正经记录锁</code>，否则添加<code class='orange'>next-key锁</code>。
- <code>步骤6.</code> 判断ICP条件是否成立。如果当前记录是二级索引记录，并且已经不在扫描区间中，则向server层返回可<code class='red'>**结束本扫描区间的查询**</code>的信息。
- <code>步骤7.</code> 如果对二级索引记录进行加锁，还需要对相应的聚簇索引记录加<code class='orange'>正经记录锁</code>（使用覆盖索引，并且加S型锁的记录可跳过此步骤）。
- <code>步骤8.</code> 判断当前记录是否已不在扫描区间中，如果不在的话，则向server返回可<code class='red'>**结束本扫描区间的查询**</code>的信息。
- <code>步骤9.</code> 如果server层收到可<code class='red'>**结束本扫描区间的查询**</code>的信息，则结束本扫描区间的查询，否则继续向InnoDB要下一条记录，InnoDB根据记录所在的链表获取到下一条记录后，从<code class='orange'>步骤3</code>开始新一轮的轮回。

好了，到现在为止大家应该明白为什么最开始说的即使是全表扫描的加锁读，加的也是行锁而不是表锁了。在使用InnoDB存储引擎时，当进行全表扫描时，其实就是相当于扫描主键值在(-∞, +∞)这个扫描区间中的聚簇索引记录，针对每一条聚簇索引记录，都需要执行一次<code class='orange'>row_search_mvcc</code>函数，都需要进行如上所述的各种判断，最后决定给扫描的记录加什么锁。


# 五、死锁



参考文章：
[史上最全MySQL各种锁详解](https://juejin.cn/post/6931752749545553933)
[从源码看MySQL的加锁规则](https://juejin.cn/post/7133014068830404622)
[完整版：Innodb到底是怎么加锁的](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247486432&idx=1&sn=720f7a8c8fe06dea56f016d2eb1600ae&chksm=97968212a0e10b048f2f98663a13c2aac1fb004a918f8f20344d0b14c5e353ee14d5e3d80b4a&scene=20&xtrack=1#rd)
[Mysql行锁、间隙锁、临键锁](https://www.cnblogs.com/ZhuChangwu/p/14439764.html)


