---
title: 《分库分表》数据迁移
date: 2021-09-04
categories:
  - [ 分布式系统 ]
  - [ mybatis ]
tags:
  - [ 分库分表]
  - [ ShardingJDBC]
---


<style>
.orange {
   color: orange
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>



# 一、数据平滑迁移的“双写法”方案实施步骤

在数据迁移中，“**双写法**”是一种常见策略，其核心是在迁移期间同时向**旧系统（系统A）**和**新系统（系统B）**写入数据，确保数据一致性并降低切换风险。以下是是否需要**先完成全量迁移再开启双写**的详细分析及实施方案：

<!-- more -->

# 二、双写方案的两种模式
## 2.1. 先全量迁移，再开启双写（推荐）
- **核心逻辑**：
    1. 完成全量数据迁移，确保系统B与系统A的基线数据完全一致。
    2. 开启双写，后续所有写入操作同时落到系统A和系统B。
    3. 通过增量同步工具（如CDC）追平双写前的数据差异（如有）。
    4. 最终流量切换至系统B，下线系统A。

- **适用场景**：
    - 系统允许停机时间完成全量迁移。
    - 对数据一致性要求极高（如金融交易系统）。

- **优势**：
    - **数据一致性强**：双写开启时，系统B已包含全量数据，避免写入冲突。
    - **风险可控**：迁移步骤清晰，回滚简单（关闭双写即可）。

- **典型流程**：
  ```plaintext
  系统A（旧） → [全量迁移] → 系统B（新）  
                      ↓  
         [开启双写] → 同时写入A和B  
                      ↓  
           [校验一致性] → 流量切换至B  
  ```

## 2.2. 边双写边迁移（复杂场景）
- **核心逻辑**：
    1. 先开启双写，所有新数据同时写入A和B。
    2. 在双写运行期间，异步完成全量数据迁移。
    3. 迁移完成后，校验并修复历史数据差异。
    4. 流量切换至系统B，下线系统A。

- **适用场景**：
    - 系统无法停机，需保证业务连续性（如高并发在线服务）。
    - 全量数据量极大，迁移时间窗口不足。

- **风险与挑战**：
    - **数据冲突**：双写期间旧数据可能被修改，需处理覆盖逻辑。
    - **复杂度高**：需额外校验工具确保全量数据最终一致。
    - **回滚困难**：若迁移失败，需清理系统B中的脏数据。

- **典型流程**：
  ```plaintext
  开启双写 → 同时写入A和B  
     ↓  
  [异步全量迁移] → 迁移历史数据  
     ↓  
  [增量数据对比修复] → 流量切换至B  
  ```
---

### 2.2.1. 存在的问题
边双写边迁移过程中，系统B未同步数据导致更新操作异常的问题（主键不存在或记录未找到）。
- 更新操作依赖目标系统的数据存在性。
- 双写过程中数据同步存在延迟或缺失。

#### 方案1：更新操作前检查系统B数据存在性
- **若数据操作**：直接执行更新。
- **若数据不存在**：先插入基础数据，再执行更新。


- **优点**：确保系统B始终存在完整数据，避免更新异常。
- **缺点**：增加一次查询和插入操作，可能影响性能。

#### 方案2：upsert操作（数据库层兼容）
利用数据库的`upsert`语法（如`insert ... on DUPLICATE KEY UPDATE`）：
```sql
INSERT INTO systemB.table (id, field1, field2)
VALUES (:id, :field1, :field2)
ON DUPLICATE KEY UPDATE
  field1 = VALUES(field1),
  field2 = VALUES(field2);
```
- **优点**：减少应用层逻辑，依赖数据库原子性保证。
- **缺点**：需数据库支持`upsert`语法。

#### 方案3：异步补偿机制（最终一致性）
容忍系统B的更新失败，但记录失败操作到消息队列或日志：
- 后台任务消费失败日志，重试或修复数据。
- 若数据存在但版本冲突：按时间戳/版本号合并更新。


- **优点**：对主流程性能影响小，适合高并发场景。
- **缺点**：数据一致性延迟，需额外维护补偿系统。


**方案对比与选型建议**

| 方案       | 一致性   | 性能 | 复杂度 | 适用场景                 |
|----------|-------|----|-----|----------------------|
| 先插入后更新   | 强一致性  | 低  | 中   | 数据强一致性要求，低并发场景       |
| upsert操作 | 强一致性  | 高  | 低   | 数据库支持upsert且无需复杂业务逻辑 |
| 异步补偿机制   | 最终一致性 | 高  | 高   | 高并发、允许短暂不一致的场景       |

## 2.3、是否需要先完成全量迁移再开双写？
- **结论**：  
  **建议优先采用“先全量迁移再开双写”模式**，除非存在不可接受的停机时间。  
  若必须边双写边迁移，需设计完善的冲突解决机制和数据校验方案。

- **原因分析**：
    1. **数据一致性**：  
       若未完成全量迁移即开启双写，系统B中缺失历史数据，可能导致以下问题：
        - 业务查询时部分数据仅存在于A，部分在B，结果混乱。
        - 双写期间对旧数据的更新可能覆盖迁移中的历史数据。
    2. **复杂度对比**：
        - **先全量后双写**：仅需处理增量数据同步，逻辑简单。
        - **边双写边迁移**：需处理全量迁移与增量写入的交叉影响，极易出错。

---

# 三、实施方案（推荐：先全量迁移再双写）
## 步骤1：全量数据迁移**
1. **数据导出**：从系统A导出全量数据（如MySQL的`mysqldump`）。
2. **数据清洗**：转换格式、处理脏数据，适配系统B的模型。
3. **数据导入**：使用批量工具（如Spark、Sqoop）导入系统B。
4. **一致性校验**：对比系统A和B的记录数、关键字段哈希值。

## 步骤2：开启双写
1. **代码改造**：在业务层插入/更新逻辑中增加对系统B的写入。
   ```java
   // 伪代码示例
   public void createOrder(Order order) {
       // 旧系统写入
       systemA.insert(order);
       // 新系统写入
       systemB.insert(order);
   }
   ```
2. **双写开关**：通过配置中心（如`Nacos`）动态控制双写启用/关闭。
3. **异常处理**：
    - 系统B写入失败时，需回滚系统A操作或记录日志人工修复。
    - 使用本地事务表（如`Transactional Outbox`）保证双写原子性。

## 步骤3：增量数据同步
1. **同步工具**：使用CDC工具（如`Debezium`）捕获系统A的增量变更，写入系统B。
2. **追平数据**：确保双写开启前的数据差异（如有）被修复。

## 步骤4：流量切换与验证
1. **读流量灰度**：逐步将读请求导向系统B，观察性能及错误率。
2. **写流量切换**：关闭双写，所有写入直接进入系统B。
3. **监控回滚**：预留快速回滚机制（如重新开启双写）。

---

# 四、关键问题与解决方案
## 4.1. 双写性能下降
- **优化方案**：
    - 异步双写：将系统B的写入改为异步操作（如MQ解耦）。
    - 批量提交：合并多次写入请求，减少网络开销。

## 4.2. 数据冲突
- **场景**：全量迁移后，双写期间某条数据在系统A被更新，但迁移工具未捕获该变更。
- **解决**：
    - 在双写开启前，确保全量迁移已完成且增量同步工具已就绪。
    - 使用**版本号**或**更新时间戳**标记记录，以最后一次写为准。

## 4.3. 历史数据差异
- **校验工具**：  
  定期运行数据对比任务，修复不一致记录。
  ```sql
  -- 示例：检测差异主键
  SELECT pk FROM A 
  WHERE pk NOT IN (SELECT pk FROM B)
  UNION
  SELECT pk FROM B 
  WHERE pk NOT IN (SELECT pk FROM A);
  ```

---

# 五、总结
**双写法方案通常要求先完成全量迁移再开启双写**，以最大限度降低数据不一致风险。若因业务连续性要求必须边双写边迁移，需投入额外资源设计冲突解决机制和自动化修复工具。实际选型时，建议通过影子流量压测验证方案可行性，最终实现平滑过渡。