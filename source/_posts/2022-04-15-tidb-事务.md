---
title: 《TIDB》事务
date: 2022-04-15
categories:
  - [ 数据库, tidb ]
---

<style>
.my-code {
   color: green;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #6260ff;
}
</style>

# 一、tidb
传统的单机数据库已经在很多场景下表现的力不从心，为了解决海量数据平台的扩展性的问题，TiDB 分布式数据库应运而生

<!--more-->

# 二、事务

TIDB的事务通过`两阶段提交（2PC）`和 `乐观锁（optimistic locking）`实现分布式事务。

## 2.1、乐观事务
乐观事务原理
1. 客户端 `begin` 了一个事务。
TiDB 从 `PD` 获取一个全局唯一递增的版本号作为当前事务的开始版本号，这里我们定义为该事务的 `start_ts`
2. 客户端发起读请求
TiDB 从 PD  获取数据路由信息，数据具体存在哪个 `TiKV` 上
TiDB 向 TiKV 获取 `start_ts`版本下对应的数据信息
3. 客户端发起写请求
TiDB 对写入数据进行校验，如数据类型是否正确、是否符合唯一索引约束等，确保新写入数据事务符合一致性约束，将检查通过的`数据存放在内存里`
4. 客户端发起 `commit`【此时进行<code class="red">两阶段提交</code>】
   - TiDB 开始两阶段提交将事务原子地提交，数据真正落盘
     - TiDB 从当前要写入的数据中选择一个 Key 作为当前事务的 `Primary Key`
     - TiDB 从 PD 获取所有数据的写入路由信息，并将所有的 Key 按照所有的路由进行分类
     - TiDB 并发向所有涉及的 `TiKV` 发起 `prewrite` 请求，`TiKV` 收到 `prewrite` 数据后，检查数据版本信息是否存在冲突、过期，符合条件给数据加锁
     - TiDB 收到所有的 `prewrite` 成功
     - TiDB 向 `PD` 获取第二个全局唯一递增版本，作为本次事务的 `commit_ts`
     - TiDB 向 `Primary Key` 所在 TiKV 发起第二阶段提交 `commit` 操作，`TiKV` 收到 `commit` 操作后，检查数据合法性，清理 `prewrite` 阶段留下的锁
     - TiDB 收到 `f` 成功信息
5. TiDB 向客户端返回事务提交成功
6. TiDB 异步清理本次事务遗留的锁信息

# 三、大事务
1. 客户端 commit 之前写入数据都在内存里面，TiDB 内存暴涨，一不小心就会 OOM
2. 第一阶段写入与其他事务出现冲突的概率就会指数级上升，事务之间相互阻塞影响
3. 事务的提交完成会变得很长很长

`建议每 100～500 行写入一个事务`

# 四、事务冲突
主要指事务并发执行时，对相同的 Key 有读写操作
	
主要分两种
- `读写冲突`：存在并发的事务，部分事务对相同的 Key 读，部分事务对相同的 Key 进行写。
- `写写冲突`：存在并发的事务，同时对相同的 Key 进行写入。

> 在 TiDB 的乐观锁机制中，因为是在客户端对事务 commit 时，才会触发两阶段提交，检测是否存在写写冲突。所以，在乐观锁中，存在写写冲突时，很容易在事务提交时暴露，因而更容易被用户感知

乐观锁下事务的默认行为，可以知道在冲突比较大的时候，Commit 很容易出现失败，客户端就会根据需求去重试


参考文章：
https://tidb.net/blog/fe4f7b05#%E5%88%86%E5%8A%9F%E8%83%BD%E6%A2%B3%E7%90%86/DML%20-%20%E8%AF%BB%E6%93%8D%E4%BD%9C