---
title: ã€Šmysqlã€‹æºç åˆ†æ
date: 2020-08-11 18:19:31
categories:
  - [mysql]
---

    è¿™æ˜¯â€œmysqlâ€ç³»åˆ—çš„ç¬¬å››ç¯‡æ–‡ç« ï¼Œä¸»è¦ä»‹ç»çš„æ˜¯éƒ¨åˆ†æºç ã€‚

# ä¸€ã€mysql

<code>MySQL</code> æ˜¯ä¸€ç§å¹¿æ³›ä½¿ç”¨çš„å¼€æºå…³ç³»å‹æ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼ˆRDBMS--Relational Database Management Systemï¼‰

<!-- more -->
åŸºæœ¬ç»“æ„ï¼š
![åŸºæœ¬ç»“æ„](2020-08-10-mysql-ç´¢å¼•/åŸºæœ¬ç»“æ„.png)

# äºŒã€æºç æ¶æ„å›¾
é¦–å…ˆçœ‹ä¸€ä¸‹MySQLçš„æºç æ¶æ„å›¾ï¼Œä¸»è¦å¯ä»¥åˆ†æˆä¸‰å±‚ã€‚
![æºç æ¶æ„](2020-08-11-mysql-æºç åˆ†æ/æºç æ¶æ„.png)

## 2.1ã€æºç ç»“æ„
ä¸‹é¢æ˜¯8.0.41ç‰ˆæœ¬çš„æºç ç»“æ„å›¾ï¼š
![æºç ç»“æ„å›¾](2020-08-11-mysql-æºç åˆ†æ/æºç ç»“æ„å›¾.png)
MySqlå…¶å®å°±ä¸¤å¤§å—ï¼Œä¸€å—æ˜¯MySql Serverå±‚ï¼Œä¸€å—å°±æ˜¯Storage Engineså±‚ã€‚
- **<1> Client**
ä¸åŒè¯­è¨€çš„sdkéµå®ˆmysqlåè®®å°±å¯ä»¥ä¸mysqldè¿›è¡Œäº’é€šã€‚
- **<2> Connection/Thread Pool**
MySqlä½¿ç”¨C++ç¼–å†™ï¼ŒConnectionæ˜¯éå¸¸å®è´µçš„ï¼Œåœ¨åˆå§‹åŒ–çš„æ—¶å€™ç»´æŠ¤ä¸€ä¸ªæ± ã€‚
- **<3> SqlInterface,Parse,Optimizer,Cache**
å¯¹sqlå¤„ç†ï¼Œè§£æï¼Œä¼˜åŒ–ï¼Œç¼“å­˜ç­‰å¤„ç†å’Œè¿‡æ»¤æ¨¡å—ï¼Œäº†è§£äº†è§£å³å¯ã€‚
- **<4> Storage Engines**
è´Ÿè´£å­˜å‚¨çš„æ¨¡å—ï¼Œå®˜æ–¹ï¼Œç¬¬ä¸‰æ–¹ï¼Œç”šè‡³æ˜¯ä½ è‡ªå·±éƒ½å¯ä»¥è‡ªå®šä¹‰å®ç°è¿™ä¸ªæ•°æ®å­˜å‚¨ï¼Œè¿™å°±æŠŠç”Ÿæ€åšèµ·æ¥äº†ï¼ŒğŸ®ğŸ‘ƒã€‚



# ä¸‰ã€æºç åˆ†æ

## 3.1ã€å…¥å£å‡½æ•°ï¼šmain() -> mysald_main()
MySQLçš„å¯åŠ¨å…¥å£æ˜¯main()å‡½æ•°ï¼ˆä½äºsql/main.ccï¼‰ï¼Œä½†å®é™…é€»è¾‘ç”±<code>mysqld_main</code>å‡½æ•°ï¼ˆä½äº<code>sql/main.cc</code>ï¼‰å®ç°ã€‚
```cpp
// sql/main.cc
int main(int argc, char **argv)
{
  return mysqld_main(argc, argv);
}
```

## 3.2ã€åˆå§‹åŒ–å…¨å±€ç¯å¢ƒ
åœ¨<code>mysqld_main</code> å‡½æ•°ä¸­ï¼Œé¦–å…ˆè¿›è¡Œå…¨å±€åˆå§‹åŒ–

### 3.2.1ã€åŸºç¡€åˆå§‹åŒ–ï¼šmy_init()
- åˆå§‹åŒ–å†…å­˜åˆ†é…ã€çº¿ç¨‹åº“ã€ä¿¡å·å¤„ç†ç­‰ã€‚
- è®¾ç½®ç¨‹åºåç§°å’Œé”™è¯¯å¤„ç†ã€‚

```cpp
// sql/mysqld.cc
my_init(argv[0]);//åˆå§‹åŒ–å…¨å±€ç¯å¢ƒ
```

### 3.2.2ã€åŠ è½½é…ç½®ï¼šload_defaults()
- è§£æå‘½ä»¤è¡Œå‚æ•°å’Œé…ç½®æ–‡ä»¶ï¼ˆå¦‚my.cnfï¼‰ã€‚
- åˆå¹¶é»˜è®¤é…ç½®å’Œç”¨æˆ·è‡ªå®šä¹‰é…ç½®ã€‚

```cpp
//åŠ è½½é…ç½®æ–‡ä»¶ï¼ˆå¦‚my.cnfï¼‰
if (load_defaults("my", load_default_groups, &argc, &argv) {
   exit(1);
}
//å¤„ç†å‘½ä»¤è¡Œå‚æ•°
handle_options(&argc, &argv, my_long_options, mysqld_get_one_option);
```


## 3.3ã€æ ¸å¿ƒå­ç³»ç»Ÿåˆå§‹åŒ–
MySQLå¯åŠ¨çš„æ ¸å¿ƒåœ¨äºåˆå§‹åŒ–å„ä¸ªå­ç³»ç»Ÿï¼Œç¡®ä¿æœåŠ¡ç»„ä»¶å°±ç»ª

<details style="background-color: #dbdbdb;padding: 10px;">
<summary><strong> > init_server_componentsæºç </strong> (ç‚¹å‡»å±•å¼€)</summary>

```cpp
/*
* æ ¸å¿ƒæ¨¡å—
*/
static int init_server_components()
{
  DBUG_ENTER("init_server_components");
  /*
    We need to call each of these following functions to ensure that
    all things are initialized so that unireg_abort() doesn't fail
    éœ€è¦è°ƒç”¨ä»¥ä¸‹æ¯ä¸ªå‡½æ•°æ¥ç¡®ä¿æ‰€æœ‰å†…å®¹éƒ½å·²åˆå§‹åŒ–
  */
  // åˆå§‹åŒ– mdl å­ç³»ç»Ÿã€‚ç‰¹åˆ«æ˜¯, åˆå§‹åŒ–æ–°çš„å…¨å±€å˜é‡é”å’Œç›¸å…³çš„æ¡ä»¶å˜é‡: LOCK_mdl å’Œ COND_mdlã€‚
  mdl_init();
  // åˆå§‹åŒ– partitioning, å½“å‰åªæœ‰ PSI Keysã€‚
  partitioning_init();
  // åˆå§‹åŒ– table definition cache hashè¡¨ å’Œ hostname cache hashè¡¨
  if (table_def_init() | hostname_cache_init(host_cache_size))
    unireg_abort(MYSQLD_ABORT_EXIT);
  // åˆå§‹åŒ– timer ç»„ä»¶
  if (my_timer_initialize())
    sql_print_error("Failed to initialize timer component (errno %d).", errno);
  else
    have_statement_timeout = SHOW_OPTION_YES;
  // åˆå§‹åŒ– query cache
  init_server_query_cache();
  // éšæœºæ•°æ¨¡å—åˆå§‹åŒ–
  randominit(&sql_rand, (ulong)server_start_time, (ulong)server_start_time / 2);
  // æµ®ç‚¹è¿ç®—å™¨
  setup_fpu();
#ifdef HAVE_REPLICATION
  // åˆå§‹åŒ– slave list
  init_slave_list();
#endif
 
  /* Setup logs */
 
  /*
    Enable old-fashioned error log, except when the user has requested
    help information. Since the implementation of plugin server
    variables the help output is now written much later.
 
    log_error_dest can be:
    disabled_my_option     --log-error was not used or --log-error=
    ""                     --log-error without arguments (no '=')
    filename               --log-error=filename
  */
#ifdef _WIN32
  /*
    Enable the error log file only if console option is not specified
    and --help is not used.
  */
  bool log_errors_to_file = !opt_help && !opt_console;
#else
  /*
    Enable the error log file only if --log-error=filename or --log-error
    was used. Logging to file is disabled by default unlike on Windows.
  */
  // æ˜¯å¦å¯ç”¨ error log
  bool log_errors_to_file = !opt_help && (log_error_dest != disabled_my_option);
#endif
  // å¯ç”¨ error log
  if (log_errors_to_file)
  {
    // Construct filename if no filename was given by the user.
    // å¦‚æœ æ²¡æœ‰æŒ‡å®š error log filename, åˆ™è‡ªåŠ¨ç”Ÿæˆ
    if (!log_error_dest[0] || log_error_dest == disabled_my_option)
      fn_format(errorlog_filename_buff, pidfile_name, mysql_data_home, ".err",
                MY_REPLACE_EXT); /* replace '.<domain>' by '.err', bug#4997 */
    else
      fn_format(errorlog_filename_buff, log_error_dest, mysql_data_home, ".err",
                MY_UNPACK_FILENAME);
    /*
      log_error_dest may have been set to disabled_my_option or "" if no
      argument was passed, but we need to show the real name in SHOW VARIABLES.
    */
    log_error_dest = errorlog_filename_buff;
    // open error log
    if (open_error_log(errorlog_filename_buff, false))
      unireg_abort(MYSQLD_ABORT_EXIT);
  }
  else
  {
    // We are logging to stderr and SHOW VARIABLES should reflect that.
    // è®°å½• error log åˆ° stderr
    log_error_dest = "stderr";
    // Flush messages buffered so far.
    flush_error_log_messages();
  }
    
  enter_cond_hook = thd_enter_cond;
  exit_cond_hook = thd_exit_cond;
  is_killed_hook = (int (*)(const void *))thd_killed;
  // transaction_cache init
  if (transaction_cache_init())
  {
    sql_print_error("Out of memory");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
 
  /*
    initialize delegates for extension observers, errors have already
    been reported in the function
    åˆå§‹åŒ–å„ç§ xxx_delegate ç±»å‹çš„æŒ‡é’ˆ, ä¸ºä»–ä»¬åˆ†é…å¯¹è±¡, å¯¹åŠ¨æ€æ’ä»¶çš„æ”¯æŒ
  */
  if (delegates_init())
    unireg_abort(MYSQLD_ABORT_EXIT);
 
  /* need to configure logging before initializing storage engines
     åœ¨åˆå§‹åŒ– storage engines ä¹‹å‰éœ€è¦é…ç½® binlog.
  */
  if (opt_log_slave_updates && !opt_bin_log)
  {
    sql_print_warning("You need to use --log-bin to make "
                      "--log-slave-updates work.");
  }
  if (binlog_format_used && !opt_bin_log)
    sql_print_warning("You need to use --log-bin to make "
                      "--binlog-format work.");
 
  /* Check that we have not let the format to unspecified at this point */
  assert((uint)global_system_variables.binlog_format <=
         array_elements(binlog_format_names) - 1);
 
#ifdef HAVE_REPLICATION
  // replicate_same_server_id
  if (opt_log_slave_updates && replicate_same_server_id)
  {
    if (opt_bin_log)
    {
      sql_print_error("using --replicate-same-server-id in conjunction with \
--log-slave-updates is impossible, it would lead to infinite loops in this \
server.");
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
    else
      sql_print_warning("using --replicate-same-server-id in conjunction with \
--log-slave-updates would lead to infinite loops in this server. However this \
will be ignored as the --log-bin option is not defined.");
  }
#endif
 
  opt_server_id_mask = ~ulong(0);
#ifdef HAVE_REPLICATION
  // æ£€æŸ¥ serverid è¶…é•¿
  opt_server_id_mask = (opt_server_id_bits == 32) ? ~ulong(0) : (1 << opt_server_id_bits) - 1;
  if (server_id != (server_id & opt_server_id_mask))
  {
    sql_print_error("server-id configured is too large to represent with"
                    "server-id-bits configured.");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
#endif
  //
  if (opt_bin_log)
  {
    /* Reports an error and aborts, if the --log-bin's path
       is a directory.
       --log-bin æŒ‡å‘ä¸€ä¸ªç›®å½•
       */
    if (opt_bin_logname &&
        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR)
    {
      sql_print_error("Path '%s' is a directory name, please specify \
a file name for --log-bin option",
                      opt_bin_logname);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
 
    /* Reports an error and aborts, if the --log-bin-index's path
       is a directory.
       --log-bin-index æŒ‡å‘ä¸€ä¸ªç›®å½•
    */
    if (opt_binlog_index_name &&
        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] == FN_LIBCHAR)
    {
      sql_print_error("Path '%s' is a directory name, please specify \
a file name for --log-bin-index option",
                      opt_binlog_index_name);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
 
    char buf[FN_REFLEN];
    const char *ln;
    ln = mysql_bin_log.generate_name(opt_bin_logname, "-bin", buf);
    if (!opt_bin_logname && !opt_binlog_index_name)
    {
      /*
        User didn't give us info to name the binlog index file.
        Picking `hostname`-bin.index like did in 4.x, causes replication to
        fail if the hostname is changed later. So, we would like to instead
        require a name. But as we don't want to break many existing setups, we
        only give warning, not error.
      */
      sql_print_warning("No argument was provided to --log-bin, and "
                        "--log-bin-index was not used; so replication "
                        "may break when this MySQL server acts as a "
                        "master and has his hostname changed!! Please "
                        "use '--log-bin=%s' to avoid this problem.",
                        ln);
    }
    if (ln == buf)
    {
      my_free(opt_bin_logname);
      opt_bin_logname = my_strdup(key_memory_opt_bin_logname,
                                  buf, MYF(0));
    }
 
    /*
      Skip opening the index file if we start with --help. This is necessary
      to avoid creating the file in an otherwise empty datadir, which will
      cause a succeeding 'mysqld --initialize' to fail.
    */
    if (!opt_help && mysql_bin_log.open_index_file(opt_binlog_index_name, ln, TRUE))
    {
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }
 
  if (opt_bin_log)
  {
    /*
      opt_bin_logname[0] needs to be checked to make sure opt binlog name is
      not an empty string, incase it is an empty string default file
      extension will be passed
      log_bin basename å’Œ log_bin index æ£€æŸ¥
     */
    log_bin_basename =
        rpl_make_log_name(key_memory_MYSQL_BIN_LOG_basename,
                          opt_bin_logname, default_logfile_name,
                          (opt_bin_logname && opt_bin_logname[0]) ? "" : "-bin");
    log_bin_index =
        rpl_make_log_name(key_memory_MYSQL_BIN_LOG_index,
                          opt_binlog_index_name, log_bin_basename, ".index");
    if (log_bin_basename == NULL || log_bin_index == NULL)
    {
      sql_print_error("Unable to create replication path names:"
                      " out of memory or path names too long"
                      " (path name exceeds " STRINGIFY_ARG(FN_REFLEN) " or file name exceeds " STRINGIFY_ARG(FN_LEN) ").");
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }
 
#ifndef EMBEDDED_LIBRARY
  // reply_log basename & index
  DBUG_PRINT("debug",
             ("opt_bin_logname: %s, opt_relay_logname: %s, pidfile_name: %s",
              opt_bin_logname, opt_relay_logname, pidfile_name));
  /*
    opt_relay_logname[0] needs to be checked to make sure opt relaylog name is
    not an empty string, incase it is an empty string default file
    extension will be passed
   */
  relay_log_basename =
      rpl_make_log_name(key_memory_MYSQL_RELAY_LOG_basename,
                        opt_relay_logname, default_logfile_name,
                        (opt_relay_logname && opt_relay_logname[0]) ? "" : "-relay-bin");
 
  if (relay_log_basename != NULL)
    relay_log_index =
        rpl_make_log_name(key_memory_MYSQL_RELAY_LOG_index,
                          opt_relaylog_index_name, relay_log_basename, ".index");
 
  if (relay_log_basename == NULL || relay_log_index == NULL)
  {
    sql_print_error("Unable to create replication path names:"
                    " out of memory or path names too long"
                    " (path name exceeds " STRINGIFY_ARG(FN_REFLEN) " or file name exceeds " STRINGIFY_ARG(FN_LEN) ").");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
#endif /* !EMBEDDED_LIBRARY */
 
  /* call ha_init_key_cache() on all key caches to init them
  key cache handle, ä»…é€‚ç”¨äºISAM è¡¨
  */
  process_key_caches(&ha_init_key_cache);
 
  /* Allow storage engine to give real error messages */
  if (ha_init_errors())
    DBUG_RETURN(1);
 
  if (opt_ignore_builtin_innodb)
    sql_print_warning("ignore-builtin-innodb is ignored "
                      "and will be removed in future releases.");
  // åˆå§‹åŒ– GTID server
  if (gtid_server_init())
  {
    sql_print_error("Failed to initialize GTID structures.");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
 
  /*
    Set tc_log to point to TC_LOG_DUMMY early in order to allow plugin_init()
    to commit attachable transaction after reading from mysql.plugin table.
    If necessary tc_log will be adjusted to point to correct TC_LOG instance
    later.
    tc_log å°½æ—©æŒ‡å‘ TC_LOG_DUMMY, ä»¥ä¾¿å…è®¸ plugin_init() åœ¨è¯»å– mysql.plugin è¡¨ä¹‹åæäº¤é™„åŠ çš„äº‹åŠ¡ã€‚
  */
  tc_log = &tc_log_dummy;
 
  /*Load early plugins */
  if (plugin_register_early_plugins(&remaining_argc, remaining_argv,
                                    opt_help ? PLUGIN_INIT_SKIP_INITIALIZATION : 0))
  {
    sql_print_error("Failed to initialize early plugins.");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  /* Load builtin plugins, initialize MyISAM, CSV and InnoDB
  æ³¨å†Œå†…ç½®æ’ä»¶, åˆå§‹åŒ– MyYSAM, CSV, InnoDB
  æ ¸å¿ƒéƒ¨åˆ†ã€‚
  */
  if (plugin_register_builtin_and_init_core_se(&remaining_argc,
                                               remaining_argv))
  {
    sql_print_error("Failed to initialize builtin plugins.");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  /*
    Skip reading the plugin table when starting with --help in order
    to also skip initializing InnoDB. This provides a simpler and more
    uniform handling of various startup use cases, e.g. when the data
    directory does not exist, exists but is empty, exists with InnoDB
    system tablespaces present etc.
  */
  // æ³¨å†Œå¹¶åˆå§‹åŒ–åŠ¨æ€æ’ä»¶ã€‚è¿˜è¦åˆå§‹åŒ–å°šæœªåˆå§‹åŒ–çš„å†…ç½®æ’ä»¶[MyISAM CSV INNODB å¤–çš„å…¶ä»–å†…ç½®æ’ä»¶]ã€‚
  if (plugin_register_dynamic_and_init_all(&remaining_argc, remaining_argv,
                                           (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : 0) |
                                               (opt_help ? (PLUGIN_INIT_SKIP_INITIALIZATION |
                                                            PLUGIN_INIT_SKIP_PLUGIN_TABLE)
                                                         : 0)))
  {
    sql_print_error("Failed to initialize dynamic plugins.");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  plugins_are_initialized = TRUE; /* Don't separate from init function */
  // session_track_system_variableså˜é‡æ£€æŸ¥: æ§åˆ¶serveræ˜¯å¦è·Ÿè¸ªåˆ†é…ç»™ä¼šè¯ç³»ç»Ÿå˜é‡çš„ä»»åŠ¡
  Session_tracker session_track_system_variables_check;
  LEX_STRING var_list;
  char *tmp_str;
  size_t len = strlen(global_system_variables.track_sysvars_ptr);
  tmp_str = (char *)my_malloc(PSI_NOT_INSTRUMENTED, len * sizeof(char) + 2,
                              MYF(MY_WME));
  strcpy(tmp_str, global_system_variables.track_sysvars_ptr);
  var_list.length = len;
  var_list.str = tmp_str;
  if (session_track_system_variables_check.server_boot_verify(system_charset_info,
                                                              var_list))
  {
    sql_print_error("The variable session_track_system_variables either has "
                    "duplicate values or invalid values.");
    if (tmp_str)
      my_free(tmp_str);
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  if (tmp_str)
    my_free(tmp_str);
  /* we do want to exit if there are any other unknown options */
  if (remaining_argc > 1)
  {
    int ho_error;
    struct my_option no_opts[] =
        {
            {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}};
    /*
      We need to eat any 'loose' arguments first before we conclude
      that there are unprocessed options.
    */
    my_getopt_skip_unknown = 0;
    // å¤„ç†å‘½ä»¤è¡Œé€‰é¡¹
    if ((ho_error = handle_options(&remaining_argc, &remaining_argv, no_opts,
                                   mysqld_get_one_option)))
      unireg_abort(MYSQLD_ABORT_EXIT);
    /* Add back the program name handle_options removes */
    remaining_argc++;
    remaining_argv--;
    my_getopt_skip_unknown = TRUE;
 
    if (remaining_argc > 1)
    {
      sql_print_error("Too many arguments (first extra is '%s').",
                      remaining_argv[1]);
      sql_print_information("Use --verbose --help to get a list "
                            "of available options!");
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
  }
 
  if (opt_help)
    unireg_abort(MYSQLD_SUCCESS_EXIT);
 
  /* if the errmsg.sys is not loaded, terminate to maintain behaviour
  å¦‚æœ errmsg.sys æœªåŠ è½½, åˆ™ä¸­æ­¢
  */
  if (!my_default_lc_messages->errmsgs->is_loaded())
  {
    sql_print_error("Unable to read errmsg.sys file");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
 
  /* We have to initialize the storage engines before CSV logging
  åœ¨ CSV loggingä¹‹å‰, æˆ‘ä»¬å¿…é¡»åˆå§‹åŒ–å­˜å‚¨å¼•æ“
  */
  // åˆå§‹åŒ– system database name cacheã€å½“å‰system database åªæœ‰ mysqlã€‘
  if (ha_init())
  {
    sql_print_error("Can't init databases");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
   
  if (opt_bootstrap)
    log_output_options = LOG_FILE;
 
  /*
    Issue a warning if there were specified additional options to the
    log-output along with NONE. Probably this wasn't what user wanted.
  */
  if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))
    sql_print_warning("There were other values specified to "
                      "log-output besides NONE. Disabling slow "
                      "and general logs anyway.");
 
  if (log_output_options & LOG_TABLE)
  {
    /* Fall back to log files if the csv engine is not loaded. */
    LEX_CSTRING csv_name = {C_STRING_WITH_LEN("csv")};
    if (!plugin_is_ready(csv_name, MYSQL_STORAGE_ENGINE_PLUGIN))
    {
      sql_print_error("CSV engine is not present, falling back to the "
                      "log files");
      log_output_options = (log_output_options & ~LOG_TABLE) | LOG_FILE;
    }
  }
 
  query_logger.set_handlers(log_output_options);
 
  // Open slow log file if enabled.  æ‰“å¼€ slow log æ–‡ä»¶
  if (opt_slow_log && query_logger.reopen_log_file(QUERY_LOG_SLOW))
    opt_slow_log = false;
 
  // Open general log file if enabled.  æ‰“å¼€ general log æ–‡ä»¶
  if (opt_general_log && query_logger.reopen_log_file(QUERY_LOG_GENERAL))
    opt_general_log = false;
 
  /*
    Set the default storage engines; è®¾ç½®é»˜è®¤å­˜å‚¨å¼•æ“
  */
  // æ£€æŸ¥Innodbå­˜å‚¨å¼•æ“æ˜¯å¦åˆå§‹åŒ–
  if (initialize_storage_engine(default_storage_engine, "",
                                &global_system_variables.table_plugin))
    unireg_abort(MYSQLD_ABORT_EXIT);
  // æ£€æŸ¥ Innodb å­˜å‚¨å¼•æ“
  if (initialize_storage_engine(default_tmp_storage_engine, " temp",
                                &global_system_variables.temp_table_plugin))
    unireg_abort(MYSQLD_ABORT_EXIT);
 
  if (!opt_bootstrap && !opt_noacl)
  {
    std::string disabled_se_str(opt_disabled_storage_engines);
    ha_set_normalized_disabled_se_str(disabled_se_str);
 
    // Log warning if default_storage_engine is a disabled storage engine.
    handlerton *default_se_handle =
        plugin_data<handlerton *>(global_system_variables.table_plugin);
    if (ha_is_storage_engine_disabled(default_se_handle))
      sql_print_warning("default_storage_engine is set to a "
                        "disabled storage engine %s.",
                        default_storage_engine);
 
    // Log warning if default_tmp_storage_engine is a disabled storage engine.
    handlerton *default_tmp_se_handle =
        plugin_data<handlerton *>(global_system_variables.temp_table_plugin);
    if (ha_is_storage_engine_disabled(default_tmp_se_handle))
      sql_print_warning("default_tmp_storage_engine is set to a "
                        "disabled storage engine %s.",
                        default_tmp_storage_engine);
  }
  // ä¸¤é˜¶æ®µæäº¤ tc_log
  if (total_ha_2pc > 1 || (1 == total_ha_2pc && opt_bin_log))
  {
    if (opt_bin_log)
      tc_log = &mysql_bin_log;
    else
      tc_log = &tc_log_mmap;
  }
  // init tc_log
  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))
  {
    sql_print_error("Can't init tc log");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
  // before recovery
  (void)RUN_HOOK(server_state, before_recovery, (NULL));
  // xa recovery æ“ä½œ
  if (ha_recover(0))
  {
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
 
  /// @todo: this looks suspicious, revisit this /sven
  // gtid_mode
  enum_gtid_mode gtid_mode = get_gtid_mode(GTID_MODE_LOCK_NONE);
  // ENFORCE_GTID_CONSISTENCY
  if (gtid_mode == GTID_MODE_ON &&
      _gtid_consistency_mode != GTID_CONSISTENCY_MODE_ON)
  {
    sql_print_error("GTID_MODE = ON requires ENFORCE_GTID_CONSISTENCY = ON.");
    unireg_abort(MYSQLD_ABORT_EXIT);
  }
 
  if (opt_bin_log)
  {
    /*
      Configures what object is used by the current log to store processed
      gtid(s). This is necessary in the MYSQL_BIN_LOG::MYSQL_BIN_LOG to
      corretly compute the set of previous gtids.
       
    */
    assert(!mysql_bin_log.is_relay_log);
    mysql_mutex_t *log_lock = mysql_bin_log.get_log_lock();
    mysql_mutex_lock(log_lock);
    // æ‰“å¼€ binlog æ–‡ä»¶
    if (mysql_bin_log.open_binlog(opt_bin_logname, 0,
                                  max_binlog_size, false,
                                  true /*need_lock_index=true*/,
                                  true /*need_sid_lock=true*/,
                                  NULL))
    {
      mysql_mutex_unlock(log_lock);
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
    mysql_mutex_unlock(log_lock);
  }
 
  if (opt_myisam_log)
    (void)mi_log(1);
 
#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT) && !defined(EMBEDDED_LIBRARY)
  if (locked_in_memory && !getuid())
  {
    if (setreuid((uid_t)-1, 0) == -1)
    { // this should never happen
      sql_print_error("setreuid: %s", strerror(errno));
      unireg_abort(MYSQLD_ABORT_EXIT);
    }
    if (mlockall(MCL_CURRENT))
    {
      sql_print_warning("Failed to lock memory. Errno: %d\n", errno); /* purecov: inspected */
      locked_in_memory = 0;
    }
#ifndef _WIN32
    if (user_info)
      set_user(mysqld_user, user_info);
#endif
  }
  else
#endif
    locked_in_memory = 0;
 
  /* Initialize the optimizer cost module
  åˆå§‹åŒ–ä¼˜åŒ–å™¨æˆæœ¬æ¨¡å—
  */
  init_optimizer_cost_module(true);
  ft_init_stopwords();
  // åˆå§‹åŒ– max_user_conns
  init_max_user_conn();
  // åˆå§‹åŒ– sql_command_flags å’Œ server_command_flags æ•°ç»„ã€‚
  init_update_queries();
  DBUG_RETURN(0);
}

```

</details>


### 3.3.1ã€æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–
- åˆå§‹åŒ–é”™è¯¯æ—¥å¿—ã€æ…¢ç¨‹åºæ—¥å¿—ã€é€šç”¨æ—¥å¿—ç­‰ã€‚

```cpp
log_tables();
error_log();
slow_log();
general_log();
```

### 3.3.2ã€å­˜å‚¨å¼•æ“åˆå§‹åŒ–
åŠ è½½å¹¶åˆå§‹åŒ–å­˜å‚¨å¼•æ“æ’ä»¶ï¼ˆå¦‚innodbã€myisamï¼‰
```cpp
//åˆå§‹åŒ–æ’ä»¶ç³»ç»Ÿ
plugin_init(&argc, &argv, PLUGIN_INIT_SKIP_PLUGIN_TABLE);
//åˆå§‹åŒ–å­˜å‚¨å¼•æ“æ¥å£
ha_init();
```
- <code>plugin_init()</code>(sql/sql_plugin.cc)ä¼šè°ƒç”¨å­˜å‚¨å¼•æ“çš„åˆå§‹åŒ–å‡½æ•°ã€‚
  - ä¾‹å¦‚ï¼Œinnodbçš„å…¥å£æ˜¯<code>innodb_init()</code>(storage/innobase/handler/ha_innodb.cc).
- <code>ha_init()</code>(sql/handler.cc)åˆå§‹åŒ–Handler APIï¼Œæ³¨å†Œå­˜å‚¨å¼•æ“


### 3.3.3ã€ç½‘ç»œæ¨¡å—åˆå§‹åŒ–
åˆ›å»ºç›‘å¬å¥—æ¥å­—ï¼Œç»‘å®šç«¯å£ï¼Œå‡†å¤‡æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥ã€‚
```cpp
//åˆå§‹åŒ–ç½‘ç»œæ¨¡å—
network_init();//åˆå§‹åŒ–ç½‘ç»œåè®®ï¼ˆTCP/IPã€Socketï¼‰
create_socket();//åˆ›å»ºç›‘å¬å¥—æ¥å­—å¹¶ç»‘å®šç«¯å£
```
- å…³é”®å‡½æ•° <code>network_init()</code>(sql/conn_handler/socket_connection.cc)å’Œ create_socketï¼ˆï¼‰

### 3.3.4ã€çº¿ç¨‹æ± ä¸åå°çº¿ç¨‹
åˆå§‹åŒ–çº¿ç¨‹æ± ã€å¯åŠ¨åå°çº¿ç¨‹ï¼ˆå¦‚ä¸»çº¿ç¨‹ã€IOçº¿ç¨‹ï¼‰
```cpp
//åˆå§‹åŒ–çº¿ç¨‹æ± 
thread_pool_init();
//å¯åŠ¨ä¿¡å·å¤„ç†çº¿ç¨‹
start_signal_handler()
//å¯åŠ¨åå°çº¿ç¨‹ï¼ˆå¦‚ innodbçš„ä¸»çº¿ç¨‹ï¼‰
start_handle_manager();
```
- innodbçš„ä¸»çº¿ç¨‹ <code>srv_master_thread</code>(storage/innobase/srv/srv0start.cc)è´Ÿè´£è„é¡µåˆ·æ–°ã€æ£€æŸ¥ç‚¹ç­‰ä»»åŠ¡ã€‚

## 3.4ã€å¯åŠ¨æœåŠ¡ä¸»å¾ªç¯
åˆå§‹åŒ–å®Œæˆåï¼ŒMySQLè¿›å…¥æœåŠ¡ä¸»å¾ªç¯ï¼Œç›‘å¬å®¢æˆ·ç«¯è¯·æ±‚ã€‚

### 3.4.1ã€å¤„ç†å®¢æˆ·ç«¯è¿æ¥
è°ƒç”¨<code>handle_connection_sockets()</code> (sql/conn_handler/socket_connection.cc)è¿›å…¥äº‹ä»¶å¾ªç¯ï¼Œç›‘å¬è¿æ¥ã€‚
```cpp

int mysqld_main(int argc, char **argv)
{
    //åˆ›å»ºæœåŠ¡ç›‘å¬çº¿ç¨‹
    handle_connections_sockets();
}

void handle_connections_sockets()
{
     //ç›‘å¬è¿æ¥
     new_sock= mysql_socket_accept(key_socket_client_connection, sock,
                                    (struct sockaddr *)(&cAddr), &length);

    if (mysql_socket_getfd(sock) == mysql_socket_getfd(unix_sock))
      thd->security_ctx->set_host((char*) my_localhost);

    //åˆ›å»ºè¿æ¥
    create_new_thread(thd);
}

//åˆ›å»ºæ–°çº¿ç¨‹å¤„ç†å¤„ç†ç”¨æˆ·è¿æ¥
static void create_new_thread(THD *thd){
   
   thd->thread_id= thd->variables.pseudo_thread_id= thread_id++;
   
   //çº¿ç¨‹è¿›äº†çº¿ç¨‹è°ƒåº¦å™¨
   MYSQL_CALLBACK(thread_scheduler, add_connection, (thd));   
}

```
- è¯¥å‡½æ•°ä½¿ç”¨poll()æˆ–epoll()ç›‘å¬å¥—æ¥å­—ï¼Œæ¥å—æ–°è¿æ¥å¹¶ä¸ºæ¯ä¸ªè¿æ¥åˆ›å»ºçº¿ç¨‹ï¼ˆæˆ–ä½¿ç”¨çº¿ç¨‹æ± ï¼‰ã€‚
- MySQL åç»­<code>Connection_handler_manager ï¼ˆsql/conn_handler/connection_handler_manager.ccï¼‰</code>æ›¿ä»£handle_connections_socketsï¼Œè¿™ä¸ªç±»æ˜¯è¿æ¥å¤„ç†çš„æ ¸å¿ƒç®¡ç†ç±»ï¼Œè´Ÿè´£ç®¡ç†ä¸åŒç±»å‹çš„è¿æ¥å¤„ç†ç¨‹åºã€‚
  - mysqld_socket_acceptor->connection_event_loop();//ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œä¸æ–­ä»äº‹ä»¶å¤šè·¯å¤ç”¨å™¨ä¸­è·å–å°±ç»ªçš„äº‹ä»¶ï¼Œå¹¶æ ¹æ®äº‹ä»¶ç±»å‹è¿›è¡Œå¤„ç†ã€‚


```cpp
/**
    Connection acceptor loop to accept connections from clients.
  */
  void connection_event_loop() {
    Connection_handler_manager *mgr =
        Connection_handler_manager::get_instance();
    while (!connection_events_loop_aborted()) {
      Channel_info *channel_info = m_listener->listen_for_connection_event();
      if (channel_info != nullptr) mgr->process_new_connection(channel_info);
    }
  }
```
<font color=green>**æ›´å¤šå†…å®¹æŸ¥çœ‹ç¬¬å››ç« èŠ‚ã€‚**</font>

### 3.4.2ã€è¯·æ±‚å¤„ç†
æ¯ä¸ªå®¢æˆ·ç«¯è¿æ¥ç”± THDï¼ˆçº¿ç¨‹æè¿°ç¬¦ï¼‰ç®¡ç†ï¼Œæ‰§è¡ŒSQLè§£æã€ä¼˜åŒ–ã€æ‰§è¡Œç­‰æµç¨‹ã€‚
è¯·æ±‚å¤„ç†å…¥å£ä¸º do_command() (sql/sql_parse.cc)

<font color=green>**æ›´å¤šå†…å®¹æŸ¥çœ‹ç¬¬å››ç« èŠ‚ã€‚**</font>


## 3.5ã€ä¿¡å·å¤„ç†ä¸ä¼˜é›…å…³é—­
MySQLæ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°ï¼Œå“åº” SIGTERMã€SIGINTç­‰ä¿¡å·ï¼Œæ‰§è¡Œä¼˜é›…å…³é—­ã€‚
```cpp
//æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°
my_init_signals()
//ä¿¡å·å¤„ç†é€»è¾‘ï¼ˆå¦‚ shutdownï¼‰
signal_hand_thd = new Signal_handler_thread();
```
- å…³é—­æ—¶è°ƒç”¨ clean_up() (sql/mysqld.cc)ï¼Œé‡Šæ”¾èµ„æºå¹¶é€€å‡ºã€‚





# å››ã€MySQLè¿æ¥çš„å»ºç«‹ä¸ä½¿ç”¨
åœ¨ MYSQLçš„å¯åŠ¨è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥çœ‹åˆ°åœ¨ <code>mysqld_main()</code> å‡½æ•°çš„æœ€åè°ƒç”¨äº† <code>mysqld_socket_acceptor->connection_event_loop()</code> å‡½æ•°ç”¨æ¥å¤„ç†MySQLçš„è¿æ¥ï¼Œè¿™é‡Œé€šè¿‡æºç åˆ†æä¸€ä¸‹MySQLè¿æ¥çš„å»ºç«‹ä¸ä½¿ç”¨è¿‡ç¨‹ï¼š

## 4.1ã€ç¬¬ä¸€æ­¥ï¼Œç­‰å¾…è¿æ¥è¿›å…¥
åœ¨æ­»å¾ªç¯ä¸­è°ƒç”¨ m_listener->listen_for_connection_event() ç­‰å¾…è¿æ¥è¿›å…¥

```cpp
void connection_event_loop() {
    Connection_handler_manager *mgr =
        Connection_handler_manager::get_instance();
    while (!connection_events_loop_aborted()) {
      Channel_info *channel_info = m_listener->listen_for_connection_event();
      if (channel_info != nullptr) mgr->process_new_connection(channel_info);
    }
  }
```


## 4.2ã€ç¬¬äºŒæ­¥ï¼šå¤„ç†è¿æ¥
å¦‚æœæœ‰è¿æ¥è¿›å…¥ï¼Œåˆ™è°ƒç”¨ precess_new_connection() å¤„ç†è¿æ¥
```cpp
// å¦‚æœæœ‰è¿æ¥è¿›å…¥ï¼Œå¤„ç†è¿æ¥void
Connection_handler_manager::process_new_connection(Channel_info* channel_info)
{ã€€ // check_and_incr_conn_count() æ£€æŸ¥æ˜¯å¦æœ‰ç©ºä½™è¿æ¥, å¦‚æœæ²¡æœ‰ç©ºä½™è¿æ¥, ç»“æŸå¤„ç†æµç¨‹
  if (abort_loop || !check_and_incr_conn_count())
  {
    channel_info->send_error_and_close_channel(ER_CON_COUNT_ERROR, 0, true);
    delete channel_info;
    return;
  }
  // è¿™é‡Œæœ‰ç©ºä½™è¿æ¥, connection_accepted = true
  if (m_connection_handler->add_connection(channel_info))
  {
    inc_aborted_connects();
    delete channel_info;
  }
}
```
- è°ƒç”¨ check_and_incr_conn_count() æ£€æŸ¥æ˜¯å¦æœ‰ç©ºä½™è¿æ¥[å½“å‰è¿æ¥æ•°æ˜¯å¦å¤§äº max_connections], å¦‚æœæ²¡æœ‰ç©ºä½™è¿æ¥, ç»“æŸå¤„ç†æµç¨‹ï¼›
  æ³¨æ„ï¼šè¿™é‡Œå…è®¸ max_connections + 1 ä¸ªè¿æ¥ï¼Œæœ€åä¸€ä¸ªè¿æ¥æ˜¯ä¸º super userä¿ç•™çš„ã€‚
- å¦‚æœå­˜åœ¨ç©ºä½™è¿æ¥ï¼Œåˆ™å¯¹è¿æ¥è¿›è¡Œå¤„ç†


## 4.3ã€ç¬¬ä¸‰æ­¥ï¼šè·å–çº¿ç¨‹ï¼Œå¤„ç†è¿æ¥

```cpp
// åœ¨è¿™é‡Œåˆ›å»ºè¿æ¥bool 
Per_thread_connection_handler::add_connection(Channel_info *channel_info)
{
  int error = 0;
  my_thread_handle id;
 
  DBUG_ENTER("Per_thread_connection_handler::add_connection");
 
  // Simulate thread creation for test case before we check thread cache
  DBUG_EXECUTE_IF("fail_thread_create", error = 1; goto handle_error;);
  // æ£€æŸ¥ thread cache ä¸­æ˜¯å¦æœ‰ç©ºé—² threadï¼Œå¦‚æœæœ‰ï¼Œä½¿ç”¨ cached thread
  if (!check_idle_thread_and_enqueue_connection(channel_info))
    DBUG_RETURN(false);
 
  /*
    There are no idle threads avaliable to take up the new
    connection. Create a new thread to handle the connection    æ²¡æœ‰å¯ç”¨çš„ç©ºé—²çº¿ç¨‹æ¥å¤„ç†æ–°çš„è¿æ¥ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹æ¥å¤„ç†è¿™ä¸ªè¿æ¥ã€‚
  */
  channel_info->set_prior_thr_create_utime();
  error = mysql_thread_create(key_thread_one_connection, &id,
                              &connection_attrib,
                              handle_connection,
                              (void *)channel_info);
#ifndef NDEBUG
handle_error:
#endif // !NDEBUG
 
  if (error)
  {
    connection_errors_internal++;
    if (!create_thd_err_log_throttle.log())
      sql_print_error("Can't create thread to handle new connection(errno= %d)",
                      error);
    channel_info->send_error_and_close_channel(ER_CANT_CREATE_THREAD,
                                               error, true);
    Connection_handler_manager::dec_connection_count();
    DBUG_RETURN(true);
  }
 
  Global_THD_manager::get_instance()->inc_thread_created();
  DBUG_PRINT("info", ("Thread created"));
  DBUG_RETURN(false);
}
```
- æŸ¥çœ‹ thread cache ä¸­æ˜¯å¦æœ‰ç©ºé—² threadï¼Œå¦‚æœæœ‰ï¼Œä½¿ç”¨ cached thread
```cpp
bool Per_thread_connection_handler::check_idle_thread_and_enqueue_connection(
    Channel_info *channel_info)
{
  bool res = true;
 
  mysql_mutex_lock(&LOCK_thread_cache);<br>  // å¦‚æœ blocked_pthread > wake_threadï¼Œåˆ™ thread cache ä¸­å­˜åœ¨ç©ºé—² thread
  if (Per_thread_connection_handler::blocked_pthread_count > wake_pthread)
  {
    DBUG_PRINT("info", ("waiting_channel_info_list->push %p", channel_info));<br>    // å°† channel_info æ”¾å…¥ waiting_channel_info_listï¼Œwake_pthread ++
    waiting_channel_info_list->push_back(channel_info);
    wake_pthread++;
    mysql_cond_signal(&COND_thread_cache);
    res = false;
  }
  mysql_mutex_unlock(&LOCK_thread_cache);
 
  return res;
}
```
- å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹æ¥å¤„ç†è¿™ä¸ªè¿æ¥
```cpp
/**
  Block the current pthread for reuse by new connections.
  é˜»å¡å½“å‰çš„ç‰©ç†çº¿ç¨‹ï¼Œä¾›æ–°çš„è¿æ¥ä½¿ç”¨
  @retval NULL   Too many pthreads blocked already or shutdown in progress.
  @retval !NULL  Pointer to Channel_info object representing the new connection
                 to be served by this pthread.
*/
 
Channel_info *Per_thread_connection_handler::block_until_new_connection()
{
  Channel_info *new_conn = NULL;
  mysql_mutex_lock(&LOCK_thread_cache);
  if (blocked_pthread_count < max_blocked_pthreads &&
      !kill_blocked_pthreads_flag)
  {
    /* Don't kill the pthread, just block it for reuse */
    DBUG_PRINT("info", ("Blocking pthread for reuse"));
 
    /*
      mysys_var is bound to the physical thread,
      so make sure mysys_var->dbug is reset to a clean state
      before picking another session in the thread cache.
    */
    DBUG_POP();
    assert(!_db_is_pushed_());
 
    // Block pthread ++
    blocked_pthread_count++;
    while (!abort_loop && !wake_pthread && !kill_blocked_pthreads_flag)<br>      // è¿™é‡Œç­‰å¾…ä¿¡å·
      mysql_cond_wait(&COND_thread_cache, &LOCK_thread_cache);
    blocked_pthread_count--;
 
    if (kill_blocked_pthreads_flag)
      mysql_cond_signal(&COND_flush_thread_cache);
    else if (wake_pthread)
    {<br>      // wake_pthread è®¡æ•°å™¨ -1
      wake_pthread--;
      if (!waiting_channel_info_list->empty())
      {<br>        // å¦‚æœ waiting_channel_info_list ä¸æ˜¯ç©ºçš„, åˆ™å–å‡ºç¬¬ä¸€ä¸ª
        new_conn = waiting_channel_info_list->front();
        waiting_channel_info_list->pop_front();
        DBUG_PRINT("info", ("waiting_channel_info_list->pop %p", new_conn));
      }
      else
      {
        assert(0);
      }
    }
  }
  mysql_mutex_unlock(&LOCK_thread_cache);
  return new_conn;
}
```


## 4.4ã€ç¬¬å››æ­¥ï¼šå¼€å§‹å¤„ç† handle_connection
çº¿ç¨‹è°ƒç”¨ <code>handle_connection()</code> çº¿ç¨‹å¤„ç†å‡½æ•°ï¼Œåˆå§‹åŒ–ä¸€ä¸ª thd å¯¹è±¡ï¼Œå¹¶å°†å…¶åŠ å…¥ thd list; å¹¶åˆå§‹åŒ– lex è¯æ³•è§£æå™¨ï¼Œè¿›è¡Œè¿æ¥èº«ä»½éªŒè¯ï¼Œåˆå§‹åŒ– thdï¼Œå‡†å¤‡æ‰§è¡Œè¯­å¥ã€‚
```cpp
/**
  Thread handler for a connection
  çº¿ç¨‹å¤„ç†å‡½æ•°ã€‚
  @param arg   Connection object (Channel_info)
 
  This function (normally) does the following:
  - Initialize thread
  - Initialize THD to be used with this thread
  - Authenticate user
  - Execute all queries sent on the connection
  - Take connection down
  - End thread  / Handle next connection using thread from thread cache
*/
extern "C" void *handle_connection(void *arg)
{
  Global_THD_manager *thd_manager = Global_THD_manager::get_instance();
  Connection_handler_manager *handler_manager =
      Connection_handler_manager::get_instance();
  Channel_info *channel_info = static_cast<Channel_info *>(arg);
  bool pthread_reused MY_ATTRIBUTE((unused)) = false;
  
  if (my_thread_init())
  {
    connection_errors_internal++;
    channel_info->send_error_and_close_channel(ER_OUT_OF_RESOURCES, 0, false);
    handler_manager->inc_aborted_connects();
    Connection_handler_manager::dec_connection_count();
    delete channel_info;
    my_thread_exit(0);
    return NULL;
  }
 
  for (;;)
  {    // åˆå§‹åŒ–ä¸€ä¸ª thd å¯¹è±¡
    THD *thd = init_new_thd(channel_info);
    if (thd == NULL)
    {
      connection_errors_internal++;
      handler_manager->inc_aborted_connects();
      Connection_handler_manager::dec_connection_count();
      break; // We are out of resources, no sense in continuing.
    }
 
    // å°†æ–°åˆ›å»ºçš„ thd æ·»åŠ åˆ° thd listï¼›
    thd_manager->add_thd(thd);
    /**     1. åˆå§‹åŒ– lex è¯æ³•è§£æå™¨     2. è¿›è¡Œè¿æ¥èº«ä»½éªŒè¯     3. åˆå§‹åŒ– thd , å‡†å¤‡æ‰§è¡Œè¯­å¥    */
    if (thd_prepare_connection(thd))
      handler_manager->inc_aborted_connects();
    else
    {      // åªè¦è¿æ¥ aliveï¼Œå°±ä¼šä¸€ç›´å¾ªç¯ä¸‹å»
      while (thd_connection_alive(thd))
      {        // å¤„ç†å‘½ä»¤ï¼Œè¿™æ˜¯ MySQL çš„æ ¸å¿ƒæ“ä½œ
        if (do_command(thd))
          break;
      }      // å‡å°‘å½“å‰ç”¨æˆ·çš„è¿æ¥è®¡æ•°ç­‰
      end_connection(thd);
    }    // å…³é—­ä¸€ä¸ªè¿æ¥
    close_connection(thd, 0, false, false);
    // é‡Šæ”¾èµ„æº
    thd->get_stmt_da()->reset_diagnostics_area();
    thd->release_resources();
 
    // Clean up errors now, before possibly waiting for a new connection.
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    ERR_remove_thread_state(0);
#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
    // ä» thd list ä¸­ç§»é™¤ thd
    thd_manager->remove_thd(thd);    // å‡å°‘å½“å‰è¿æ¥æ•°
    Connection_handler_manager::dec_connection_count();
 
    delete thd;
 
    if (abort_loop) // Server is shutting down so end the pthread.
      break;
    // é˜»å¡å½“å‰çš„ç‰©ç†çº¿ç¨‹ï¼Œä½¿å¾—ç‰©ç†çº¿ç¨‹è¢«æ–°çš„è¿æ¥é‡ç”¨
    channel_info = Per_thread_connection_handler::block_until_new_connection();
    if (channel_info == NULL)
      break;
    pthread_reused = true;
    if (abort_loop)
    {
      // Close the channel and exit as server is undergoing shutdown.
      channel_info->send_error_and_close_channel(ER_SERVER_SHUTDOWN, 0, false);
      delete channel_info;
      channel_info = NULL;
      Connection_handler_manager::dec_connection_count();
      break;
    }
  }
 
  my_thread_end();
  my_thread_exit(0);
  return NULL;
}
```


## 4.5ã€ç¬¬äº”æ­¥ï¼šå¤„ç†ç”¨æˆ·å‘½ä»¤
è°ƒç”¨ <code>do_command()</code>. å¤„ç†ç”¨æˆ·å‘½ä»¤ã€‚
```cpp
//ç»§ç»­åˆ†å‘
bool do_command(THD *thd)
{
    return_value= dispatch_command(command, thd, packet+1, (uint) (packet_length-1));
}
bool dispatch_command(enum enum_server_command command, THD *thd, char* packet, uint packet_length)
{
      switch (command) {
         case COM_INIT_DB: ....  break;
         ...
         case COM_QUERY:   //æŸ¥è¯¢è¯­å¥ï¼š  insert xxxx
             mysql_parse(thd, thd->query(), thd->query_length(), &parser_state);  //sqlè§£æ
           break;
      }
}
//sqlè§£ææ¨¡å—
void mysql_parse(THD *thd, char *rawbuf, uint length, Parser_state *parser_state)
{
      error= mysql_execute_command(thd);
}
```
ç»§ç»­æ‰§è¡Œ<code>mysql_execute_command</code>
```cpp
//ç»§ç»­æ‰§è¡Œ
int mysql_execute_command(THD *thd)
{
  switch (lex->sql_command) 
  {
      case SQLCOM_SELECT:  res= execute_sqlcom_select(thd, all_tables);  break;

      //è¿™ä¸ª insert å°±æ˜¯æˆ‘è¦è¿½çš„
      case SQLCOM_INSERT:   res= mysql_insert(thd, all_tables, lex->field_list, lex->many_values,
		                                      lex->update_list, lex->value_list,
                                              lex->duplicates, lex->ignore);
  }
}
//insertæ’å…¥æ“ä½œå¤„ç†
bool mysql_insert(THD *thd,TABLE_LIST *table_list,List<Item> &fields, List<List_item> &values_list,
                  List<Item> &update_fields, List<Item> &update_values, 
                  enum_duplicates duplic, bool ignore)
{
      while ((values= its++))
      {
           error= write_record(thd, table, &info, &update);
      }
}
//å†™å…¥è®°å½•
int write_record(THD *thd, TABLE *table, COPY_INFO *info, COPY_INFO *update)
{
    if (duplicate_handling == DUP_REPLACE || duplicate_handling == DUP_UPDATE)
    {
         // ha_write_row  é‡ç‚¹æ˜¯è¿™ä¸ªå‡½æ•°
         while ((error=table->file->ha_write_row(table->record[0])))
         {
             ....
         }
    }
}
```
ç»§ç»­æŒ– ha_write_row
```cpp
int handler::ha_write_row(uchar *buf)
{
    MYSQL_TABLE_IO_WAIT(m_psi, PSI_TABLE_WRITE_ROW, MAX_KEY, 0,{ error= write_row(buf); })
}

//è¿™æ˜¯ä¸€ä¸ªè™šæ–¹æ³•
virtual int write_row(uchar *buf __attribute__((unused)))
{
    return HA_ERR_WRONG_COMMAND;
}
```
write_rowæ˜¯ä¸ªè™šæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ç»™åº•å±‚æ–¹æ³•å®ç°çš„ï¼Œåœ¨è¿™é‡Œå°±æ˜¯ç»™å„å¤§Storage Enginesçš„å“ˆ

## 4.6ã€å°ç»“
æ€»çš„è¯·æ±‚è°ƒç”¨å †æ ˆå¦‚ä¸‹ï¼š
![è¯·æ±‚è°ƒç”¨å †æ ˆ](2020-08-11-mysql-æºç åˆ†æ/è¯·æ±‚è°ƒç”¨å †æ ˆ.png)


æ–¹æ³•è°ƒç”¨æ€»ç»“å¦‚ä¸‹ï¼š
1. åœ¨æ­»å¾ªç¯ä¸­è°ƒç”¨ m_listener->listen_for_connection_event() ç­‰å¾…è¿æ¥è¿›å…¥
2. å¦‚æœæœ‰è¿æ¥è¿›å…¥ï¼Œåˆ™è°ƒç”¨ precess_new_connection() å¤„ç†è¿æ¥
3. è°ƒç”¨ check_and_incr_conn_count() æ£€æŸ¥æ˜¯å¦æœ‰ç©ºä½™è¿æ¥[å½“å‰è¿æ¥æ•°æ˜¯å¦å¤§äº max_connections], å¦‚æœæ²¡æœ‰ç©ºä½™è¿æ¥, ç»“æŸå¤„ç†æµç¨‹ï¼›
   æ³¨æ„ï¼šè¿™é‡Œå…è®¸ max_connections + 1 ä¸ªè¿æ¥ï¼Œæœ€åä¸€ä¸ªè¿æ¥æ˜¯ä¸º super userä¿ç•™çš„ã€‚
4. å¦‚æœå­˜åœ¨ç©ºä½™è¿æ¥ï¼Œåˆ™å¯¹è¿æ¥è¿›è¡Œå¤„ç†
5. æŸ¥çœ‹ thread cache ä¸­æ˜¯å¦æœ‰ç©ºé—² threadï¼Œå¦‚æœæœ‰ï¼Œä½¿ç”¨ cached thread
6. å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹æ¥å¤„ç†è¿™ä¸ªè¿æ¥
7. çº¿ç¨‹è°ƒç”¨ handle_connection() çº¿ç¨‹å¤„ç†å‡½æ•°ï¼Œåˆå§‹åŒ–ä¸€ä¸ª thd å¯¹è±¡ï¼Œå¹¶å°†å…¶åŠ å…¥ thd list; å¹¶åˆå§‹åŒ– lex è¯æ³•è§£æå™¨ï¼Œè¿›è¡Œè¿æ¥èº«ä»½éªŒè¯ï¼Œåˆå§‹åŒ– thdï¼Œå‡†å¤‡æ‰§è¡Œè¯­å¥ã€‚
8. è°ƒç”¨ do_command(). å¤„ç†ç”¨æˆ·å‘½ä»¤ã€‚
   9. åç»­æµç¨‹ï¼Œå¯æŸ¥çœ‹â€œä¸€æ¡Insertè¯­å¥çš„æ‰§è¡Œè¿‡ç¨‹â€

    
å‚è€ƒæ–‡ç« ï¼š
[MySQLå¯åŠ¨è¿‡ç¨‹è¯¦è§£äºŒï¼šæ ¸å¿ƒæ¨¡å—å¯åŠ¨ init_server_components()](https://www.cnblogs.com/juanmaofeifei/p/16111523.html)
[MySQLå¯åŠ¨è¿‡ç¨‹è¯¦è§£ä¸‰ï¼šInnodbå­˜å‚¨å¼•æ“çš„å¯åŠ¨](https://www.cnblogs.com/juanmaofeifei/p/16129144.html)
[MySQLè¿æ¥çš„å»ºç«‹ä¸ä½¿ç”¨](https://www.cnblogs.com/juanmaofeifei/p/16146201.html)
[MySQL æºç è§£è¯» -- è¿æ¥ç®¡ç†](http://ilongda.com/knowledge/mysql/source_code_reading/server/connection.html)
[MySQL Â· æºç åˆ†æ Â· ä¸€æ¡insertè¯­å¥çš„æ‰§è¡Œè¿‡ç¨‹](http://mysql.taobao.org/monthly/2017/09/10/)
[è¯» MySQL æºç å†çœ‹ INSERT åŠ é”æµç¨‹](https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html)