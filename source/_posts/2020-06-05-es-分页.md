---
title: 《es》分页
date: 2020-06-05
categories:
  - [es]
---

    这是“es”系列的第四篇文章，主要介绍的是ES的分页。

<style>
.my-code {
   color: green;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #6260ff;
}
</style>

# 一、ES

<code class="red">elasticsearch</code>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能.

<!-- more -->

# 二、分页方案
## 2.1、基本分页：from/size方案
这是最常用的分页方式，通过from和size参数控制返回结果的范围。
- `from`指定查询的起始位置
- `size`表示从起始位置开始的文档数量 
- ES默认的分页深度是10000，也就是说from+size超过10000就会报错

示例：
```
GET /my_index/_search
{
  "from": 10,  # 从第 11 条结果开始
  "size": 5,   # 返回 5 条结果
  "query": {
    "match_all": {}
  }
}
```

优缺点：
- `优点`：简单易用
- `缺点`：深度分页时性能较差（如from值较大时）
  - 每个分片shard会在本地执行查询请求后会生成一个命中文档的优先级队列。
    - 这个队列是一个排序好的topN数据的列表，它的size等于from+size的和，也就是说如果你的from是10，size是10，那么这个队列的size就是20，所以这也是为什么深度分页不能用from+size这种方式，因为from越大，性能就越低。

## 2.2、滚动分页：scroll
适用于需要遍历大量数据的场景（如数据导出）

### 2.2.1、参数说明：
- scroll：指定滚动查询的有效时间（如 1m 表示1分钟）
- scroll_id：用于获取下一页结果的标识符。

### 2.2.2、示例：
**初始化滚动查询**
```
POST /my_index/_search?scroll=1m
{
  "size": 100,
  "query": {
    "match_all": {}
  }
}
```
返回结果中包含 `_scroll_id`

**获取下一页结果：**
```
POST /_search/scroll
{
  "scroll": "1m",
  "scroll_id": "DnF1ZXJ5VGhlbkZldGNoBQAAAAAA..."
}
```

**清除滚动查询:**
```
DELETE /_search/scroll
{
  "scroll_id": "DnF1ZXJ5VGhlbkZldGNoBQAAAAAA..."
}
```

### 2.2.3、优缺点
- 优点：适合处理大量数据。
- 缺点：占用资源较多，滚动上下文需要定期清理。

## 2.3、搜索后分页：search after方案
适用于深度分页场景，性能优于 from 和 size。【<code class="red">游标</code>】

### 2.3.1、参数说明
- search_after：指定上一页最后一条结果的排序值。
- sort：指定排序字段（必须包含唯一字段，如_id）

### 2.3.2、示例

第一次查询
```java
GET /my_index/_search
{
  "size": 5,
  "query": {
    "match_all": {}
  },
  "sort": [
    { "created_at": "asc" },
    { "_id": "asc" }
  ]
}
```

后续查询：
```java
GET /my_index/_search
{
  "size": 5,
  "query": {
    "match_all": {}
  },
  "search_after": [1633036800000, "1"],  # 上一页最后一条结果的排序值
  "sort": [
    { "created_at": "asc" },
    { "_id": "asc" }
  ]
}
```

### 2.3.3、优缺点
- **优点**：适合深度分页，性能较好。
- **缺点**：需要指定排序字段，且排序字段必须唯一。

