---
title: 《Java》对象
date: 2020-04-18 12:19:31
categories: 
   - [java, jvm, 虚拟机规范, 对象]
---

	这是Java虚拟机规范系列的第六篇文章，主要介绍的是虚拟机规范中的对象。

# 一、定义
Java 虚拟机是直接支持对象的，这里的对象可以是指动态分配的某个类的实例，也可以指某个数组的实例。虚拟机中使用 reference 类型①来表示对某个对象的引用，reference 类型的值读者可以想象成类似于一个指向对象的指针。每一个对象都可能存在多个指向它的引用，对象的操作、传递和检查都通过引用它的 reference 类型的数据进行操作。

<!-- more -->

# 二、对象的表示
Java 虚拟机规范不强制规定对象的内部结构应当如何表示。
> - 主要是为了给不同的虚拟机实现提供灵活性。在内存布局方面，对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）的具体实现可以因虚拟机而异。
> - Java 虚拟机规范允许不同的垃圾回收算法和实现方式。这也导致了对象内部结构表示的灵活性。
> - 在一些 Oracle 的 Java 虚拟机实现中，指向对象实例的引用是一个指向句柄的指针，这个句柄包含两部分信心，一部分是指向这个对象所包括的方法表以及指向这个对象所属类相关的信息；另一部分是指向在堆中分配的对象实例数据。（译者注：这条注释在 10 多年前出版的 Java 虚拟机规范第二版中就已经存在，第三版中仅仅是将Sun 修改为 Oracle 而已，所表达的实际信息已比较陈旧。在 HotSpot 虚拟机中，指向对象的引用并不通过句柄，而是直接指向堆中对象的实例数据，因此 HotSpot 虚拟机并不包括在上面所描述的“一些 Oracle 的 Java 虚拟机实现”范围之内）


# 三、对象创建与操作
虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：
- 创建类实例的指令：new
- 创建数组的指令：newarray，anewarray，multianewarray
- 访问类字段（static 字段，或者称为类变量）和实例字段（非 static 字段，或者成为实例变量）的指令：getfield、putfield、getstatic、putstatic
- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
- 将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore
- 取数组长度的指令：arraylength
- 检查类实例类型的指令：instanceof、checkcast


# 总结
> 对于对象的定义细节，如对象在内存中的具体布局（像前面提到的对象头、实例数据和对齐填充的具体格式）以及对象创建过程中的内存分配方式（指针碰撞或空闲列表等），规范并没有严格规定。这是因为规范希望给虚拟机实现者一定的灵活性，让他们可以根据具体的应用场景、硬件平台和性能优化目标等来设计虚拟机的实现。
> 
> 对于对象创建过程这种具体的实现细节，规范有意保持一定的灵活性。这是因为不同的虚拟机实现可能会根据目标硬件、性能优化策略、应用场景等因素来设计更合适的实现方式。
> 与 HotSpot 实现对比
**内存分配方式：** 如 HotSpot 中提到的指针碰撞和空闲列表这两种内存分配方式，在虚拟机规范中没有强制规定。规范允许虚拟机实现者自行选择合适的内存分配策略，只要能够保证对象正确地获取到所需的内存空间即可。
**初始化零值：** 虽然在实际的 HotSpot 实现中会对分配后的内存空间（除对象头）初始化零值，但虚拟机规范没有明确这一操作必须如此。从规范角度看，只要对象在使用成员变量时能够保证其有合理的初始值（无论是通过显式赋值还是其他机制）就可以。
**对象头设置和<init>方法执行：** 关于对象头的具体内容（如哈希码、分代年龄等的设置方式）以及<init>方法的执行细节（如在什么阶段以何种方式执行），Java 虚拟机规范也只是提供了比较抽象的要求。例如，规范要求对象在适当的时候要有一个有效的哈希码用于哈希相关操作，但没有规定具体是在对象创建的哪个步骤去设置这个哈希码。对于<init>方法，规范规定了它是用于初始化对象的，但没有像 HotSpot 实现那样详细说明是如何收集构造器代码块等来形成<init>方法。
