---
title: 《spring》事务传播特性
date: 2021-01-30
categories:
  - [spring, 事务]
---

    这是spring系列的第13篇文章，主要介绍的是事务的传播特性及失效场景。

<style>
.my-code {
   color: orange;
}
.orange {
   color: rgb(255, 53, 2)
}
.red {
   color: red
}
code {
   color: #0ABF5B;
}
</style>

# 一、Spring
`spring框架`是Java生态中最主流的轻量级开源应用框架，其核心目标是简化企业级应用开发，通过`IOC（控制反转）`和`AOP（面向切面编程）`两大核心机制实现解耦、模块化和可维护性。

<!-- more -->

# 二、事务传播机制
事务传播特性（）定义了多个事务方法相互调用时，事务应该如何传播和协作。通过合理配置传播行为，可以处理嵌套事务、事务独立性等复杂场景。

## 2.1、传播类型
在`TransactionDefinition`类中，定义了各种传播类型

| 传播行为 | 说明                                                     |
|------|--------------------------------------------------------|
|  PROPAGATION_REQUIRED    | 支持当前事务，如果当前没有事务，则新建一个事务，这是最常见的选择，也是 Spring 默认的一个事务传播属性 |
|   PROPAGATION_SUPPORTS   | 支持当前事务，如果当前没有事务，则以非事务方式执行                              |
|    PROPAGATION_MANDATORY  | 支持当前事务，如果当前没有事务，则抛出异常                                  |
|   PROPAGATION_REQUIRES_NEW   | 新建事务，如果当前存在事务，把当前事务挂起                                  |
|   PROPAGATION_NOT_SUPPORTED   | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起                           |
|   PROPAGATION_NEVER   | 以非事务方式执行，如果当前存在事务，则抛出异常                                |
|   PROPAGATION_NESTED   | Nested的事务和它的父事务是相依的，它的提交是要等和它的父事务一块提交的                 |



```java
if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
    definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
    definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
    SuspendedResourcesHolder suspendedResources = suspend(null);
    try {
        boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
        DefaultTransactionStatus status = newTransactionStatus(
                definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
        doBegin(transaction, definition);
        prepareSynchronization(status, definition);
        return status;
    }
}    
```

### 2.1.1、PROPAGATION_REQUIRED（默认传播行为）
- 如果当前存在事务，则加入该事务
- 如果不存在，则新建一个事务
```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // 操作 1
    methodB(); // methodB 加入 methodA 的事务
}

@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
    // 操作 2
}
```

### 2.1.2、PROPAGATION_REQUIRED_NEW（新建独立事务）
- 无论当前是否存在事务，都新建一个独立事务
- 当前事务（如果有）会被挂起，新事务提交或回滚后恢复原事务
```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
  // 操作 1（属于事务A）
  methodB(); // 开启新事务B，事务A被挂起
  // 操作 3（属于事务A，若此处抛出异常，事务A回滚，但事务B已提交）
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
  // 操作 2（属于独立事务B）
}
```


# 三、事务失效

## 3.1、自调用
在同一个类中，方法A调用方法B（B有@Transactional），由于spring AOP基于代理实现，自调用会绕过代理，导致事务注解失效，示例如下：
```java
@Component
public class OrderController {
    @Resource
    private OrderService orderService;
    @RequestMapping()
    public void test() {
        orderService.createOrder();
    }
}
@Service
public class OrderService {
    public void createOrder() {
        // 自调用事务方法 → 事务失效！
        this.insertOrder();
    }
    @Transactional
    public void insertOrder() {
        // 数据库操作
    }
}
```
在创建`OrderService`实例时，`InfrastructureAdvisorAutoProxyCreator`执行`postProcessAfterInitialization`方法，内部核心方法`AbstractAutoProxyCreator.wrapIfNecessary()`，会解析`@Transactional`注解并生成`OrderService`的代理对象
> 此时注入到OrderController的OrderService是一个代理对象。

### 3.1.1、代理对象执行
执行`DynamicAdvisedInterceptor`的`intercept`方法
```java
private static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable {
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        Object target = null;
        try {
            //被代理对象
            target = getTarget();
            //判断当前调用方法是否有拦截器链
            List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
            Object retVal;
            //拦截器链空
            if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {
                //直接调用被代理对象的目标方法
                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal = methodProxy.invoke(target, argsToUse);
            }
            retVal = processReturnType(proxy, target, method, retVal);
            return retVal;
        }
    }
}
```
通过分析代理对象的执行流程，执行的method的拦截器链为空，直接调用被代理对象的方法。
> 自调用会导致事务失效的原因分析好了。


## 3.2、非public方法导致事务失效
需要回到@Transactional注解的解析流程。
```
AbstractAutoProxyCreator.wrapIfNecessary()
-> AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean()
--> AbstractAdvisorAutoProxyCreator.findEligibleAdvisors()
---> AbstractAdvisorAutoProxyCreator.findCandidateAdvisors()
---> AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply()
----> AopUtils.findAdvisorsThatCanApply()
-----> AopUtils.canApply()：判断 advisor 是否支持
------> TransactionAttributeSourcePointcut.matches()
-------> BeanFactoryTransactionAttributeSourceAdvisor.getTransactionAttributeSource()
--------> AbstractFallbackTransactionAttributeSource.getTransactionAttribute()
---------> AbstractFallbackTransactionAttributeSource.computeTransactionAttribute()：：重点！！！判断方法是否是public
```
在解析流程的AbstractFallbackTransactionAttributeSource.computeTransactionAttribute()中，会判断方法是否public
```java
protected TransactionAttribute computeTransactionAttribute(Method method, Class<?> targetClass) {
    // Don't allow no-public methods as required.
    // 不允许非public方法
    if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
        return null;
    }
}
```

## 3.3、方法用final修饰
final不可被继承。



## 线程安全吗？
```java
@Transactional
public synchronized void selectById() {
    orderMapper.selectByPrimaryKey(0L);
}
```

```java
public final void selectById() {
    try {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$selectById$0$Method, CGLIB$emptyArgs, CGLIB$selectById$0$Proxy);
        } else {
            super.selectById();
        }
    } catch (Error | RuntimeException var1) {
        throw var1;
    } catch (Throwable var2) {
        throw new UndeclaredThrowableException(var2);
    }
}
```
### 线程不安全的根本原因
#### （1）代理对象与锁对象分离
- **动态代理机制**：Spring 通过代理对象调用目标方法，而 `synchronized` 锁定的是原始对象（`this`），而非代理对象。
- **多线程绕过锁**：若多个线程通过不同代理实例调用方法，`synchronized` 无法跨实例同步。

#### (2) 事务与锁的时序问题
- **事务开启在锁外**：事务可能在 `synchronized` 代码块外开启，导致并发操作进入事务但未获得锁。
- **数据库隔离级别影响**：即使方法同步，事务的隔离级别（如 `READ_UNCOMMITTED`）可能导致脏读。