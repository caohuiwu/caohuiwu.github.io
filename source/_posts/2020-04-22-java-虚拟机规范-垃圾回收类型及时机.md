---
title: 《Java》垃圾回收类型及时机
date: 2020-04-22 12:19:31
categories: 
   - [java, jvm, 虚拟机规范, 垃圾回收]
---

	这是Java虚拟机规范系列的第十一篇文章，主要介绍的是垃圾回收相关的内容，例如垃圾回收的时机。

# 一、GC类型
- **新生代收集（Minor GC/Young GC）：** 指目标只是新生代的垃圾收集
- **老年代收集（Major GC/Old GC）：** 指目标只是老年代的垃圾收集
- **混合收集（Mixed GC）：** 收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- **整堆收集（Full GC）：** 收集整个Java堆和方法区的垃圾收集
<!--more-->

# 二、触发Full GC的场景有哪些？

## 2.1、调用System.gc()方法
  显示调用System.gc()方法，可能会触发Full GC。因为System.gc()方法只是建议Java虚拟机尽最大努力去回收所有不可用的对象，不一定立刻执行垃圾回收，如果进行垃圾回收，则会触发Full GC。

## 2.2、老年代空间不足
  需要大量连续存储空间的对象会直接分配到老年代、长期存活的对象晋升到老年代，老年代空间不足以存放这些对象的时候会触发Full GC。

## 2.3、PermGen或Metaspace空间不足
  在JDK8之前的版本中，PermGen(永久代)是HotSpot虚拟机中方法区的一种实现，它用于存放类的信息、常量、静态变量等数据，当系统中要加载的类、反射的类等较多时，永久代出现空间不足，在未配置为采用CMS GC的情况下会触发Full GC。
  在JDK8中移除了永久代，改用了Metaspace，它也是方法区的一种实现，不过它与永久代最大的区别是Metaspace并不在虚拟机中，而是使用本地内存。当Metaspace空间不足进行回收时，需同时满足如下三个条件的类才会被卸载：该类所有的实例都已经被回收、加载该类的ClassLoader已经被回收、该类对应的java.lang.Class对象没有任何地方被引用，进而触发Full GC。

## 2.4、Minor GC晋升到老年代的平均大小大于老年代的剩余空间
  在发生Minor GC前，会检查老年代是否有足够的连续空间，如果当前老年代最大可用连续空间小于平均历次晋升到老年代大小，则触发Full GC。

## 2.5、Cocurrent mode failure
  在执行CMS GC的过程中，如果此时有线程将对象放入老年代，并且老年代空间不足，或者在做Minor GC的时候，新生代Survivor空间不足，需要放入老年代，而老年代空间也不足，则触发Full GC
  CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能